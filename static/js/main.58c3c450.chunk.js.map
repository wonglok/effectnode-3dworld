{"version":3,"sources":["../../src/utils/get-id.js","../../src/lib/Mini.js","../../src/utils/use-mini-engine.js","../../src/utils/use-auto-event.js","../../src/lib/Collider.js","../../src/lib/MapPlayer.js","../../src/utils/make-now.js","../../src/utils/make-shallow-store.js","../../src/compos/Map3D.js","../../src/lib/CursorTrackerTail.js","../../src/compos/UserContorls.js","../../src/compos/TailCursor.js","../../src/compos/SimpleBloomer.js","../../src/compos/StarSky.js","../../src/compos/EnvLightByImage.js","App.js","index.js"],"names":["getID","Math","constructor","parent","this","k","Promise","resolve","ttt","setInterval","clearInterval","isAborted","num","fnc","func","intv","window","clearTimeout","setTimeout","e","isPaused","console","name","duration","start","t","lt","dt","Proxy","get","useMiniEngine","useThree","useState","useEffect","mini","useFrame","st","useAutoEvent","settings","passive","dom","applyAutoEvent","scene","collider","makeCollider","floor","BufferGeometryUtils","require","environment","SkeletonUtils","geometries","c","cloned","key","it","mergedGeometry","MeshBVH","color","scanCenter","raycaster","result","source","first","Now","RoundedBoxGeometry","player","transparent","opacity","radius","segment","avatarDir","playerVelocity","tempVector","tempVector2","tempBox","tempMat","tempSegment","rotationCopier","delta","size","capsuleInfo","intersectsBounds","box","intersectsTriangle","tri","triPoint","capsulePoint","distance","depth","direction","newPosition","deltaVector","playerIsOnGround","clock","i","updatePlayer","makeNow","myObject","___NameSpaceID","Utils","exportJSON","JSON","getNameSpcaeID","onEvent","evName","hh","makeKeyReactive","setSt","s","reloadKey","CustomEvent","detail","proxy","o","set","makeShallowStore","moved","goingTo","camAt","avatarAt","avatarHead","avatarRot","avatarFaceLook","avatarLoading","avatarMode","avatarSpeed","keyW","keyA","keyS","keyD","cursorPos","cursorNormal","cursorType","hoverData","isDown","camMode","overlay","profile","user","reload","onlineUID","Map3D","startAt","colliderRef","useRef","nowRef","mapPlayerRef","colliderManager","mapPlayer","hit","camera","object","children","current","numberOfScans","trailSize","WIDTH","setup","node","renderer","gpu","GPUComputationRenderer","dtPosition","lookUpTexture","addVariable","positionVariable","material","value","h","ii","error","positionShader","str","mouseUniforms","lookupRightLine","fillPositionTexture","theArray","texture","y","x","fillLookupTexture","items","lastOneInArray","render","trackers","uniform","getTextureAfterCompute","posTexture","getCurrentRenderTarget","mounter","count","sim","numSides","subdivisions","openEnded","geometry","getPointAtByT","controlPointsResolution","lineIdx","lineCount","textureName","floatval","Number","getLinesPointAtT","pointLineMaker","matLine0","uniforms","time","matcap","vertexShader","fragmentShader","blending","depthTest","line0","cylinderBufferGeo","baseGeometry","tmpVec","xPositions","angles","uvs","vertices","faceVertexUvs","oPositions","verts","faceUvs","v","angle","posArray","Float32Array","angleArray","uvArray","origPosArray","lineGeo","offset","ddxyz","iii","z","dataLength","cursor","display","looker","origin","orbit","worldPos","lerpWorldPos","update","makeTracker","UserContorls","higherCamera","gl","works","ev","orig","fakeCam","OrbitControls","joystick","document","note","manager","zone","mode","position","left","bottom","forward","up","isUsing","nippleAngle","evt","nipple","cte","cts","keyBoardForward","scaler","MathUtils","Object","fov","near","far","rotation-x","makeDefault","TailCursor","mouse","ref","resBloom","height","EffectComposer","RenderPass","UnrealBloomPass","efComposer","renderPass","unrealPass","dark","darkMat","skinning","baseLayer","bloomLayer","darkLayer","darken","origBG","renderToTexture","resBase","encoding","generateMipmaps","quadMat","bloomDiffuse","baseDiffuse","fsQuad","bloomTex","SimpleBloomer","looer","base","bloom","compositor","baseTex","StarSky","shaders","frustumCulled","userData","enableBloom","scale","args","side","DoubleSide","EnvLightByImage","imageURL","pmremGenerator","loader","envMap","BASE_URL","Content3D","gltf","useGLTF","useMemo","clone","Vector3","traverse","isFloor","getWorldPosition","App","style","width","fallback","PI","PerspectiveCamera","ReactDOM","getElementById"],"mappings":"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","file":"static/js/main.58c3c450.chunk.js","sourcesContent":["export const getID = function () {\n  return (\n    '_' +\n    Math.random().toString(36).substr(2, 9) +\n    Math.random().toString(36).substr(2, 9)\n  )\n}\n","export class Mini {\n  constructor({ parent = false }) {\n    this.parent = parent\n    this.resource = new Map()\n    this.get = (k) => {\n      return new Promise((resolve) => {\n        let ttt = 0\n        ttt = setInterval(() => {\n          if (this.parent) {\n            if (this.resource.has(k) || this.parent.resource.has(k)) {\n              clearInterval(ttt)\n              resolve(this.resource.get(k) || this.parent.resource.get(k))\n            }\n          } else {\n            if (this.resource.has(k)) {\n              clearInterval(ttt)\n              resolve(this.resource.get(k))\n            }\n          }\n        })\n      })\n    }\n    this.set = (k, v) => {\n      this.resource.set(k, v)\n    }\n    this.name = 'ENMini'\n\n    let isAborted = false\n    this.tasks = []\n    this.resizeTasks = []\n    this.cleanTasks = []\n    this.onLoop = (fnc, num = 0) => {\n      if (num >= 0) {\n        this.tasks.push(fnc)\n      } else {\n        this.tasks.unshift(fnc)\n      }\n    }\n\n    this.onResize = (fnc) => {\n      fnc()\n      this.resizeTasks.push(fnc)\n    }\n\n    this.onClean = (func) => {\n      this.cleanTasks.push(func)\n    }\n\n    let intv = 0\n    const internalResize = () => {\n      clearTimeout(intv)\n      intv = setTimeout(() => {\n        this.resizeTasks.forEach((e) => e())\n      }, 16.8888)\n    }\n\n    window.addEventListener('resize', () => {\n      internalResize()\n    })\n\n    let isPaused = false\n    this.toggle = () => {\n      isPaused = !isPaused\n    }\n    this.pause = () => {\n      isPaused = true\n    }\n    this.play = () => {\n      isPaused = false\n    }\n\n    this.clean = () => {\n      isAborted = true\n      try {\n        this.cleanTasks.forEach((e) => e())\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    this.lastTime = window.performance.now()\n    this.work = () => {\n      this.timeNow = window.performance.now()\n      if (isAborted) {\n        return {\n          name: this.name,\n          duration: 0\n        }\n      }\n      if (isPaused) {\n        return {\n          name: this.name,\n          duration: 0\n        }\n      }\n      const start = window.performance.now()\n      try {\n        let t = this.timeNow\n        const lt = this.lastTime\n        let dt = t - lt\n        this.lastTime = t\n        dt = dt / 1000\n        t = t / 1000\n        if (dt >= 100) {\n          dt = 100\n        }\n\n        this.tasks.forEach((e) => e(t, dt))\n      } catch (e) {\n        console.error(e)\n      }\n      const end = window.performance.now()\n      const duration = end - start\n\n      return {\n        name: this.name,\n        duration\n      }\n    }\n\n    this.ready = new Proxy(\n      {},\n      {\n        get: (obj, key) => {\n          return this.get(key)\n        }\n      }\n    )\n    this.now = new Proxy(\n      {},\n      {\n        get: (obj, key) => {\n          if (this.parent) {\n            return this.resource.get(key) || this.parent.resource.get(key)\n          } else {\n            return this.resource.get(key)\n          }\n        }\n      }\n    )\n  }\n}\n\n// let mini = new Mini({ name: \"base\", domElement: ref.current, window });\n//\n\n//\n//\n//\n","import { useFrame, useThree } from '@react-three/fiber'\nimport { useEffect, useState } from 'react'\nimport { Mini } from '../lib/Mini'\n\nexport function useMiniEngine() {\n  const { get } = useThree()\n  const [mini] = useState(() => {\n    return new Mini({})\n  })\n\n  useEffect(() => {\n    return () => {\n      mini.clean()\n    }\n  }, [])\n\n  useFrame(() => {\n    const st = get()\n    for (const kn in st) {\n      mini.set(kn, st[kn])\n    }\n    mini.work()\n  })\n\n  return { mini }\n}\n","import { useEffect } from 'react'\n\nexport const useAutoEvent = function (\n  ev,\n  fnc,\n  settings = { passive: false },\n  dom\n) {\n  useEffect(() => {\n    dom = dom || window\n    dom.addEventListener(ev, fnc, settings)\n    return () => {\n      dom = dom || window\n      dom.removeEventListener(ev, fnc)\n    }\n  }, [])\n}\n\nexport const applyAutoEvent = function (\n  dom,\n  ev,\n  fnc,\n  settings = { passive: false }\n) {\n  dom = dom || window\n  dom.addEventListener(ev, fnc, settings)\n  return () => {\n    dom = dom || window\n    dom.removeEventListener(ev, fnc)\n  }\n}\n","import { Mesh, MeshBasicMaterial, Raycaster, Vector2 } from 'three'\nimport { MeshBVH } from 'three-mesh-bvh'\nexport class Collider {\n  constructor({ floor, scene }) {\n    this.floor = floor\n    this.center = new Vector2(0, 0)\n    this.raycaster = new Raycaster()\n    this.scene = scene\n\n    const collider = this.makeCollider()\n    this.collider = collider\n    this.preview = collider\n  }\n\n  makeCollider() {\n    const { scene, floor } = this\n    const BufferGeometryUtils =\n      require('three/examples/jsm/utils/BufferGeometryUtils').BufferGeometryUtils\n    const SkeletonUtils =\n      require('three/examples/jsm/utils/SkeletonUtils').SkeletonUtils\n\n    const environment = SkeletonUtils.clone(floor)\n\n    const geometries = []\n\n    environment.updateMatrixWorld()\n    environment.traverse((c) => {\n      if (c.geometry && !c.userData.isNotFloor) {\n        const cloned = c.geometry.clone()\n        cloned.applyMatrix4(c.matrixWorld)\n\n        for (const key in cloned.attributes) {\n          if (key === 'position' || key === 'index') {\n          } else {\n            cloned.deleteAttribute(key)\n          }\n        }\n\n        geometries.push(cloned)\n      }\n    })\n\n    scene.traverse((it) => {\n      if (it && it.userData && it.userData.isFloor && it.geometry) {\n        const cloned = it.geometry.clone()\n        it.updateMatrixWorld()\n\n        cloned.applyMatrix4(it.matrixWorld)\n        for (const key in cloned.attributes) {\n          if (key !== 'position') {\n            cloned.deleteAttribute(key)\n          }\n        }\n        geometries.push(cloned)\n      }\n    })\n\n    const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(\n      geometries,\n      false\n    )\n\n    mergedGeometry.boundsTree = new MeshBVH(mergedGeometry)\n\n    const collider = new Mesh(\n      mergedGeometry,\n      new MeshBasicMaterial({ color: 0xffffff })\n    )\n    collider.material.wireframe = true\n    collider.material.opacity = 0.5\n    collider.material.transparent = true\n    collider.updateMatrixWorld()\n\n    return collider\n  }\n\n  //\n  scanCenter({ camera, scene }) {\n    const { raycaster, center, collider } = this\n\n    raycaster.setFromCamera(center, camera)\n    const result = []\n    const source = []\n    scene.traverse((it) => {\n      if (it.geometry && it.userData.isHoverable) {\n        source.push(it)\n      }\n    })\n    raycaster.intersectObjects(source, false, result)\n\n    collider.geometry.boundsTree.raycastFirst(\n      collider,\n      raycaster,\n      raycaster.ray\n    )\n\n    const first = result[0]\n\n    if (first) {\n      return first\n    } else {\n      return false\n    }\n  }\n}\n","import {\n  Box3,\n  Clock,\n  Line3,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  Object3D,\n  Vector3\n} from 'three'\n\nexport class MapPlayer {\n  constructor({ collider, startAt, Now }) {\n    //\n    Now.avatarAt.copy(startAt)\n    Now.goingTo.copy(startAt)\n\n    this.collider = collider\n    const RoundedBoxGeometry =\n      require('three/examples/jsm/geometries/RoundedBoxGeometry.js').RoundedBoxGeometry\n    const scale = 1\n    const radius = 1.3 * scale\n    const width = 1 * scale\n    const height = 2 * scale\n    const depth = 1 * scale\n    const player = new Mesh(\n      new RoundedBoxGeometry(width, height, depth, 8, radius),\n      new MeshLambertMaterial({ transparent: true, opacity: 1 })\n    )\n    player.geometry.translate(0, -radius, 0)\n    player.castShadow = true\n\n    player.capsuleInfo = {\n      radius: radius,\n      segment: new Line3(new Vector3(), new Vector3(0, -1.0, 0.0))\n    }\n    this.player = player\n\n    player.position.copy(startAt)\n    player.position.y += 5\n\n    player.geometry.computeBoundingBox()\n    player.collider = new Box3().copy(player.geometry.boundingBox)\n\n    const avatarDir = new Vector3()\n    const playerVelocity = new Vector3(0, 0, 0)\n    // const upVector = new Vector3(0, 1, 0);\n    const tempVector = new Vector3()\n    const tempVector2 = new Vector3()\n    const tempBox = new Box3()\n    const tempMat = new Matrix4()\n    const tempSegment = new Line3()\n    const rotationCopier = new Object3D()\n    let playerIsOnGround = true\n\n    function updatePlayer({ delta, player }) {\n      // fall down\n      playerVelocity.y += delta * -9.8\n\n      player.position.addScaledVector(playerVelocity, delta)\n\n      if (player.position.y <= -50) {\n        // player.position.y = 0;\n        player.position.copy(startAt)\n        Now.goingTo.copy(startAt)\n        Now.goingTo.z += 1\n        playerVelocity.y = 0.0\n      }\n\n      avatarDir.copy(Now.goingTo).sub(player.position)\n      avatarDir.y = 0\n      const size = avatarDir.length()\n      avatarDir.normalize()\n      avatarDir.y = 0\n\n      avatarDir.multiplyScalar(Now.avatarSpeed)\n\n      if (size >= 0.1) {\n        player.position.addScaledVector(avatarDir, 0.04)\n        Now.avatarMode = 'running'\n      } else {\n        Now.avatarMode = 'standing'\n      }\n\n      player.updateMatrixWorld()\n\n      // adjust player position based on collisions\n      const capsuleInfo = player.capsuleInfo\n      tempBox.makeEmpty()\n      tempMat.copy(collider.matrixWorld).invert()\n      tempSegment.copy(capsuleInfo.segment)\n\n      // get the position of the capsule in the local space of the collider\n      tempSegment.start.applyMatrix4(player.matrixWorld).applyMatrix4(tempMat)\n      tempSegment.end.applyMatrix4(player.matrixWorld).applyMatrix4(tempMat)\n\n      // get the axis aligned bounding box of the capsule\n      tempBox.expandByPoint(tempSegment.start)\n      tempBox.expandByPoint(tempSegment.end)\n\n      tempBox.min.addScalar(-capsuleInfo.radius)\n      tempBox.max.addScalar(capsuleInfo.radius)\n\n      collider.geometry.boundsTree.shapecast(collider, {\n        intersectsBounds: (box) => box.intersectsBox(tempBox),\n\n        intersectsTriangle: (tri) => {\n          // check if the triangle is intersecting the capsule and adjust the\n          // capsule position if it is.\n          const triPoint = tempVector\n          const capsulePoint = tempVector2\n\n          const distance = tri.closestPointToSegment(\n            tempSegment,\n            triPoint,\n            capsulePoint\n          )\n          if (distance < capsuleInfo.radius) {\n            const depth = capsuleInfo.radius - distance\n            const direction = capsulePoint.sub(triPoint).normalize()\n\n            tempSegment.start.addScaledVector(direction, depth)\n            tempSegment.end.addScaledVector(direction, depth)\n          }\n        }\n      })\n\n      // get the adjusted position of the capsule collider in world space after checking\n      // triangle collisions and moving it. capsuleInfo.segment.start is assumed to be\n      // the origin of the player model.\n      const newPosition = tempVector\n      newPosition.copy(tempSegment.start).applyMatrix4(collider.matrixWorld)\n\n      // check how much the collider was moved\n      const deltaVector = tempVector2\n      deltaVector.subVectors(newPosition, player.position)\n\n      // adjust the player model\n      player.position.copy(newPosition)\n\n      //\n      Now.avatarAt.copy(player.position)\n      // Now.avatarAt.y += 0.1;\n\n      rotationCopier.position.copy(player.position)\n      rotationCopier.lookAt(\n        //\n        Now.goingTo.x,\n        player.position.y,\n        Now.goingTo.z\n      )\n\n      Now.avatarRot.x = rotationCopier.rotation.x\n      Now.avatarRot.y = rotationCopier.rotation.y\n      Now.avatarRot.z = rotationCopier.rotation.z\n\n      // if the player was primarily adjusted vertically we assume it's on something we should consider gound\n      playerIsOnGround =\n        deltaVector.y > Math.abs(delta * playerVelocity.y * 0.25)\n\n      if (!playerIsOnGround) {\n        deltaVector.normalize()\n        playerVelocity.addScaledVector(\n          deltaVector,\n          -deltaVector.dot(playerVelocity)\n        )\n        //\n      } else {\n        playerVelocity.set(0, 0, 0)\n      }\n    }\n\n    const steps = 4\n    const clock = new Clock()\n\n    this.onSimulate = () => {\n      let dt = clock.getDelta()\n      if (dt >= 1 / 30) {\n        dt = 1 / 30\n      }\n\n      for (let i = 0; i < steps; i++) {\n        updatePlayer({ delta: dt / steps, player })\n      }\n    }\n  }\n}\n","import { Vector3 } from 'three'\nimport { makeShallowStore } from './make-shallow-store'\n\nexport const makeNow = () => {\n  return makeShallowStore({\n    //\n    moved: 0,\n    goingTo: new Vector3(),\n    camAt: new Vector3(),\n    avatarAt: new Vector3(),\n    avatarHead: new Vector3(),\n    avatarRot: new Vector3(),\n    avatarFaceLook: new Vector3(),\n    avatarLoading: true,\n    avatarMode: 'standing',\n    avatarSpeed: 1.0,\n\n    keyW: false,\n    keyA: false,\n    keyS: false,\n    keyD: false,\n    cursorPos: new Vector3(),\n    cursorNormal: new Vector3(),\n    cursorType: 'hide',\n    hoverData: false,\n    isDown: false,\n\n    // avatarAtPhy: new Vector3(),\n\n    camMode: 'first',\n\n    overlay: '',\n\n    profile: false,\n    user: false,\n\n    reload: [],\n    onlineUID: []\n  })\n}\n","import { useEffect, useState } from 'react'\nimport { getID } from './get-id'\nexport const makeShallowStore = (myObject = {}) => {\n  let ___NameSpaceID = getID()\n  let Utils = {\n    exportJSON: () => {\n      return JSON.parse(JSON.stringify(myObject))\n    },\n    getNameSpcaeID: () => {\n      return ___NameSpaceID\n    },\n    /* */\n    onEvent: (key, func) => {\n      let evName = `${___NameSpaceID}`\n      let hh = () => {\n        func(myObject[key])\n      }\n\n      window.addEventListener(`${evName}-${key}`, hh)\n      return () => {\n        window.removeEventListener(`${evName}-${key}`, hh)\n      }\n    },\n\n    makeKeyReactive: (key) => {\n      let [vv, setSt] = useState(0)\n      useEffect(() => {\n        let evName = `${___NameSpaceID}`\n\n        let hh = () => {\n          setSt((s) => {\n            return s + 1\n          })\n        }\n\n        window.addEventListener(`${evName}-${key}`, hh)\n        return () => {\n          window.removeEventListener(`${evName}-${key}`, hh)\n        }\n      }, [vv])\n    },\n\n    reloadKey: (key) => {\n      window.dispatchEvent(\n        new CustomEvent(`${___NameSpaceID}-${key}`, { detail: {} })\n      )\n    }\n  }\n\n  let proxy = new Proxy(myObject, {\n    get: (o, k) => {\n      //\n      if (Utils[k]) {\n        return Utils[k]\n      }\n\n      return o[k]\n    },\n    set: (o, key, val) => {\n      let currentVal = o[key]\n\n      if (currentVal !== val) {\n        o[key] = val\n\n        if (typeof window !== 'undefined') {\n          window.dispatchEvent(\n            new CustomEvent(`${___NameSpaceID}-${key}`, { detail: {} })\n          )\n        }\n      }\n\n      return true\n    }\n  })\n\n  return proxy\n}\n","import { useThree } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { Collider } from '../lib/Collider'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { makeNow } from '../utils/make-now'\nimport { MapPlayer } from '../lib/MapPlayer'\n\nexport const Map3D = ({ children, floor, startAt }) => {\n  const { get } = useThree()\n  //\n  //\n  const { mini } = useMiniEngine()\n  const colliderRef = useRef()\n  const nowRef = useRef()\n  const mapPlayerRef = useRef()\n  useEffect(() => {\n    //\n    const colliderManager = (colliderRef.current = new Collider({\n      floor,\n      scene: get().scene\n    }))\n\n    const Now = (nowRef.current = makeNow())\n\n    const mapPlayer = (mapPlayerRef.current = new MapPlayer({\n      collider: colliderManager.collider,\n      startAt,\n      Now\n    }))\n\n    mini.onLoop(() => {\n      const { camera, scene } = get()\n      const hit = colliderManager.scanCenter({ camera, scene })\n\n      if (hit) {\n        Now.cursorPos.copy(hit.point)\n        Now.cursorNormal.copy(hit.face.normal)\n      }\n\n      if (hit) {\n        if (Now.hoverData !== hit.object.userData) {\n          Now.hoverData = hit.object.userData || null\n        }\n      } else {\n        if (Now.hoverData !== null) {\n          Now.hoverData = null\n        }\n      }\n\n      mapPlayer.onSimulate()\n    })\n\n    return () => {\n      mini.clean()\n    }\n  }, [])\n\n  //\n\n  //\n  //\n  return (\n    <group>\n      <primitive object={floor}>\n        {/*  */}\n        {/*  */}\n      </primitive>\n      {nowRef.current &&\n        typeof children === 'function' &&\n        children({ Now: nowRef.current })}\n\n      {/*  */}\n      {/*  */}\n      {/*  */}\n    </group>\n  )\n}\n","import {\n  HalfFloatType,\n  Vector3,\n  BufferAttribute,\n  CylinderBufferGeometry,\n  InstancedBufferAttribute,\n  InstancedBufferGeometry,\n  Vector2,\n  RepeatWrapping,\n  ShaderMaterial,\n  Mesh,\n  // DataTexture,\n  // DataUtils,\n  // RGBFormat,\n  AdditiveBlending,\n  Object3D\n} from 'three'\n// import { GPUComputationRenderer } from 'three-stdlib'\nimport { Geometry } from 'three/examples/jsm/deprecated/Geometry.js'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer'\n\nclass LokLokWiggleSimulation {\n  constructor({ node, numberOfScans = 10, trailSize = 32 }) {\n    this.node = node\n    this.WIDTH = trailSize\n    this.HEIGHT = numberOfScans // number of trackers\n    this.COUNT = this.WIDTH * this.HEIGHT\n    this.v3v000 = new Vector3(0, 0, 0)\n    this.wait = this.setup({ node })\n  }\n\n  async setup({ node }) {\n    let renderer = await node.ready.gl\n\n    let gpu = (this.gpu = new GPUComputationRenderer(\n      this.WIDTH,\n      this.HEIGHT,\n      renderer\n    ))\n\n    gpu.setDataType(HalfFloatType)\n\n    const dtPosition = this.gpu.createTexture()\n    const lookUpTexture = this.gpu.createTexture()\n    this.fillPositionTexture(dtPosition)\n    this.fillLookupTexture(lookUpTexture)\n\n    this.positionVariable = this.gpu.addVariable(\n      'texturePosition',\n      this.positionShader(),\n      dtPosition\n    )\n    this.gpu.setVariableDependencies(this.positionVariable, [\n      this.positionVariable\n    ])\n\n    this.positionUniforms = this.positionVariable.material.uniforms\n    this.positionUniforms.lookup = { value: lookUpTexture }\n\n    let h = this.HEIGHT\n    for (let ii = 0; ii < h; ii++) {\n      this.positionUniforms['mouse' + ii] = { value: new Vector3(0, 0, 0) }\n    }\n\n    this.positionUniforms.time = { value: 0 }\n    dtPosition.wrapS = RepeatWrapping\n    dtPosition.wrapT = RepeatWrapping\n\n    //\n    const error = this.gpu.init()\n    if (error !== null) {\n      console.error(error)\n    }\n  }\n\n  positionShader() {\n    let lookupRightLine = () => {\n      let str = `if (false) {}`\n      let h = this.HEIGHT\n      for (let ii = 0; ii < h; ii++) {\n        str += `\n          else if (currentLine == ${ii.toFixed(0)}.0) {\n            gl_FragColor = vec4(mouse${ii.toFixed(0)}, 1.0);\n          }\n        `\n      }\n      return str\n    }\n\n    let mouseUniforms = () => {\n      let str = ``\n      let h = this.HEIGHT\n      for (let ii = 0; ii < h; ii++) {\n        str += `\n          uniform vec3 mouse${ii.toFixed(0)};\n        `\n      }\n\n      return str\n    }\n    return /* glsl */ `\n      ${mouseUniforms()}\n\n      uniform sampler2D lookup;\n      uniform float time;\n\n\t\t\tvoid main()\t{\n        // const float width = resolution.x;\n        // const float height = resolution.y;\n        // float xID = floor(gl_FragCoord.x);\n        // float yID = floor(gl_FragCoord.y);\n\n        vec2 uvCursor = vec2(gl_FragCoord.x, gl_FragCoord.y) / resolution.xy;\n        // vec4 positionHead = texture2D( texturePosition, uvCursor );\n\n        vec4 lookupData = texture2D(lookup, uvCursor);\n        vec2 nextUV = lookupData.xy;\n        float currentIDX = floor(gl_FragCoord.x);\n        float currentLine = floor(gl_FragCoord.y);\n\n        if (floor(currentIDX) == 0.0) {\n          ${lookupRightLine()}\n        } else {\n          vec3 positionChain = texture2D( texturePosition,nextUV ).xyz;\n          gl_FragColor = vec4(positionChain, 1.0);\n        }\n\n\n\t\t\t}\n    `\n  }\n\n  fillPositionTexture(texture) {\n    let i = 0\n    const theArray = texture.image.data\n\n    for (let y = 0; y < this.HEIGHT; y++) {\n      for (let x = 0; x < this.WIDTH; x++) {\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n      }\n    }\n    texture.needsUpdate = true\n  }\n\n  fillLookupTexture(texture) {\n    let i = 0\n    const theArray = texture.image.data\n    let items = []\n\n    for (let y = 0; y < this.HEIGHT; y++) {\n      for (let x = 0; x < this.WIDTH; x++) {\n        let lastOneInArray = items[items.length - 1] || [0, 0]\n        theArray[i++] = lastOneInArray[0]\n        theArray[i++] = lastOneInArray[1]\n        theArray[i++] = this.WIDTH\n        theArray[i++] = this.HEIGHT\n        items.push([x / this.WIDTH, y / this.HEIGHT])\n      }\n    }\n    texture.needsUpdate = true\n  }\n\n  render({ trackers }) {\n    this.positionUniforms.time.value = window.performance.now() / 1000\n\n    trackers.forEach((track, idx) => {\n      let uniform = this.positionUniforms['mouse' + idx]\n      if (uniform && uniform.value) {\n        uniform.value.copy(track)\n        // console.log(idx, track.toArray().join(\"-\"));\n      }\n    })\n\n    this.gpu.compute()\n  }\n\n  getTextureAfterCompute() {\n    return {\n      posTexture: this.gpu.getCurrentRenderTarget(this.positionVariable).texture\n    }\n  }\n}\n\nclass LokLokWiggleDisplay {\n  constructor({ node, sim, mounter }) {\n    this.mounter = mounter\n    this.node = node\n    this.sim = sim\n    this.wait = this.setup({ node })\n  }\n\n  async setup({ node }) {\n    let mounter = this.mounter\n\n    // let camera = await node.ready.camera;\n    // let renderer = await node.ready.gl;\n\n    let { geometry, subdivisions, count } = new NoodleGeo({\n      count: this.sim.HEIGHT,\n      numSides: 4,\n      subdivisions: this.sim.WIDTH * 2,\n      openEnded: false\n    })\n\n    geometry.instanceCount = count\n\n    let getPointAtByT = ({\n      controlPointsResolution = 20,\n      lineIdx = 0,\n      lineCount = this.sim.HEIGHT,\n      textureName = 'CONTROL_POINTS'\n    }) => {\n      controlPointsResolution = Math.floor(controlPointsResolution)\n\n      let floatval = `${Number(controlPointsResolution).toFixed(1)}`\n\n      let res = `\n      vec3 pointIDX_${textureName}_${lineIdx.toFixed(0)} (float index) {\n        vec3 result = vec3(0.0);\n\n        vec4 color = texture2D(${textureName},\n          vec2(\n            index / ${controlPointsResolution.toFixed(1)},\n            ${lineIdx.toFixed(1)} / ${lineCount.toFixed(1)}\n          )\n        );\n\n        result = color.rgb;\n\n        return result;\n      }\n\n      vec3 catmullRom_${textureName}_${lineIdx} (vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n          vec3 v0 = (p2 - p0) * 0.5;\n          vec3 v1 = (p3 - p1) * 0.5;\n          float t2 = t * t;\n          float t3 = t * t * t;\n\n          return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n      }\n\n      vec3 getPointAt_${lineIdx.toFixed(0)} (float t) {\n        bool closed = false;\n        float ll = ${floatval};\n        float minusOne = 1.0;\n        if (closed) {\n          minusOne = 0.0;\n        }\n\n        float p = (ll - minusOne) * t;\n        float intPoint = floor(p);\n        float weight = p - intPoint;\n\n        float idx0 = intPoint + -1.0;\n        float idx1 = intPoint +  0.0;\n        float idx2 = intPoint +  1.0;\n        float idx3 = intPoint +  2.0;\n\n        vec3 pt0 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx0);\n        vec3 pt1 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx1);\n        vec3 pt2 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx2);\n        vec3 pt3 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx3);\n\n        vec3 pointoutput = catmullRom_${textureName}_${lineIdx}(pt0, pt1, pt2, pt3, weight);\n\n        return pointoutput;\n      }\n      `\n\n      // console.log(res);\n      return res\n    }\n\n    let getLinesPointAtT = () => {\n      let str = `\n          if (false) {}`\n      for (let i = 0; i < this.sim.HEIGHT; i++) {\n        str += `\n          else if (lineIDXER == ${i.toFixed(1)}) {\n            pt += getPointAt_${i.toFixed(0)}(t);\n          }\n        `\n      }\n      // console.log(str);\n\n      return str\n    }\n\n    let pointLineMaker = () => {\n      let str = ''\n      for (let i = 0; i < this.sim.HEIGHT; i++) {\n        str +=\n          getPointAtByT({\n            lineIdx: i,\n            lineCount: this.sim.HEIGHT,\n            controlPointsResolution: subdivisions,\n            textureName: 'posTexture'\n          }) + '\\n'\n      }\n      return str\n    }\n\n    let matLine0 = new ShaderMaterial({\n      uniforms: {\n        time: { value: 0 },\n        matcap: {\n          value: null\n          // value: new TextureLoader().load(\"/matcap/golden2.png\"),\n          // value: await node.ready.RainbowTexture,\n        },\n        posTexture: { value: null }\n        // handTexture: { value: null },\n      },\n      vertexShader: /* glsl */ `\n        // #include <common>\n        #define lengthSegments ${subdivisions.toFixed(1)}\n\n        attribute float angle;\n        attribute float newPosition;\n        attribute float tubeInfo;\n\n        // varying vec2 vUv;\n        varying vec3 vNormal;\n        attribute vec4 offset;\n\n        uniform sampler2D posTexture;\n        // uniform sampler2D handTexture;\n\n        uniform float time;\n\n        mat4 rotationX( in float angle ) {\n          return mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n                  0, \tcos(angle),\t-sin(angle),\t\t0,\n                  0, \tsin(angle),\t cos(angle),\t\t0,\n                  0, \t\t\t0,\t\t\t  0, \t\t1);\n        }\n\n        mat4 rotationY( in float angle ) {\n          return mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n                      0,\t\t1.0,\t\t\t 0,\t0,\n                  -sin(angle),\t0,\t\tcos(angle),\t0,\n                      0, \t\t0,\t\t\t\t0,\t1);\n        }\n\n        mat4 rotationZ( in float angle ) {\n          return mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n                  sin(angle),\t\tcos(angle),\t\t0,\t0,\n                      0,\t\t\t\t0,\t\t1,\t0,\n                      0,\t\t\t\t0,\t\t0,\t1);\n        }\n\n        mat4 rotationMatrix (vec3 axis, float angle) {\n            axis = normalize(axis);\n            float s = sin(angle);\n            float c = cos(angle);\n            float oc = 1.0 - c;\n\n            return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                        0.0,                                0.0,                                0.0,                                1.0);\n        }\n\n        ${pointLineMaker()}\n\n        vec3 sampleFnc (float t) {\n          vec3 pt = (offset.xyz + 0.5) * 0.0;\n\n          // pt = vec4(vec4(pt, 1.0) * rotationY(t * 0.1 + time * 0.1)).xyz;\n          // if (lineIDXER == 0.0) {\n          //   pt += getPointAt_0(t);\n          // }\n\n          float lineIDXER = offset.w;\n          // pt += getPointAt_0(t);\n\n          ${getLinesPointAtT()}\n\n          // pt = getPointAt_2(t);\n\n          return pt;\n        }\n\n        void createTube (float t, vec2 volume, out vec3 pos, out vec3 normal) {\n          // find next sample along curve\n          float nextT = t + (1.0 / lengthSegments);\n\n          // sample the curve in two places\n          vec3 cur = sampleFnc(t);\n          vec3 next = sampleFnc(nextT);\n\n          // compute the Frenet-Serret frame\n          vec3 T = normalize(next - cur);\n          vec3 B = normalize(cross(T, next + cur));\n          vec3 N = -normalize(cross(B, T));\n\n          // extrude outward to create a tube\n          float tubeAngle = angle;\n          float circX = cos(tubeAngle);\n          float circY = sin(tubeAngle);\n\n          // compute position and normal\n          normal.xyz = normalize(B * circX + N * circY);\n          pos.xyz = cur + B * volume.x * circX + N * volume.y * circY;\n        }\n\n        varying float vT;\n        varying vec3 vViewPosition;\n\n        void main (void) {\n          vec3 transformed;\n          vec3 objectNormal;\n\n          float t = tubeInfo + 0.5;\n\n          vT = t;\n\n          vec2 volume = vec2(0.0333, 0.0333);\n          createTube(t, volume, transformed, objectNormal);\n\n          vec3 transformedNormal = normalMatrix * objectNormal;\n          vNormal = normalize(transformedNormal);\n\n          // vUv = uv.yx;\n\n          vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n          vViewPosition = -mvPosition.xyz;\n        }\n      `,\n      fragmentShader: /* glsl */ `\n        varying float vT;\n        // varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vViewPosition;\n        uniform sampler2D matcap;\n        void main (void) {\n\n          vec3 viewDir = normalize( vViewPosition );\n          vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n          vec3 y = cross( viewDir, x );\n          vec2 uv = vec2( dot( x, vNormal ), dot( y, vNormal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n          vec4 matcapColor = texture2D( matcap, uv );\n\n          gl_FragColor = vec4(vec3(1.0, 1.0, 1.0), (1.0 - vT));\n        }\n      `,\n      transparent: true,\n      blending: AdditiveBlending,\n      depthTest: false\n    })\n\n    let line0 = new Mesh(geometry, matLine0)\n    line0.frustumCulled = false\n    line0.userData.enableBloom = true\n\n    mounter.add(line0)\n    node.onClean(() => {\n      mounter.remove(line0)\n    })\n\n    this.sim.wait.then(() => {\n      node.onLoop(() => {\n        let result = this.sim.getTextureAfterCompute()\n        matLine0.uniforms.posTexture.value = result.posTexture\n        matLine0.uniforms.time.value = window.performance.now() / 1000\n      })\n    })\n  }\n\n  // async enableMousePlane() {\n  //   let raycaster = await node.ready.raycaster;\n  //   let mouse = await node.ready.mouse;\n  //   let camera = await node.ready.camera;\n  //   let viewport = await node.ready.viewport;\n\n  //   let geoPlane = new PlaneBufferGeometry(\n  //     2.0 * viewport.width,\n  //     2.0 * viewport.height,\n  //     2,\n  //     2\n  //   );\n\n  //   let matPlane = new MeshBasicMaterial({\n  //     transparent: true,\n  //     opacity: 0.25,\n  //     color: 0xff0000,\n  //   });\n\n  //   let planeMesh = new Mesh(geoPlane, matPlane);\n  //   planeMesh.position.z = -camera.position.z / 2;\n\n  //   scene.add(planeMesh);\n  //   node.onClean(() => {\n  //     scene.remove(planeMesh);\n  //   });\n\n  //   let temppos = new Vector3();\n  //   node.onLoop(() => {\n  //     planeMesh.lookAt(camera.position);\n  //     raycaster.setFromCamera(mouse, camera);\n  //     let res = raycaster.intersectObject(planeMesh);\n  //     if (res && res[0]) {\n  //       temppos.copy(res[0].point);\n  //     }\n  //   });\n  // }\n\n  // enableHandTexture() {\n  //   const width = this.sim.WIDTH\n  //   const height = this.sim.HEIGHT\n  //   const size = width * height\n\n  //   let handMovement = []\n  //   let temppos = new Vector3()\n  //   for (let i = 0; i < size; i++) {\n  //     AvatarHead.getWorldPosition(temppos)\n\n  //     let x = temppos.x || 0\n  //     let y = temppos.y || 0\n  //     let z = temppos.z || 0\n  //     //\n  //     handMovement.unshift(x, y, z)\n  //   }\n\n  //   const textureArray = new Uint16Array(3 * size)\n  //   const handTexture = new DataTexture(\n  //     textureArray,\n  //     width,\n  //     height,\n  //     RGBFormat,\n  //     HalfFloatType\n  //   )\n  //   handTexture.needsUpdate = true\n\n  //   node.onLoop(() => {\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.x) || 0)\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.y) || 0)\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.z) || 0)\n\n  //     handMovement.shift()\n  //     handMovement.shift()\n  //     handMovement.shift()\n\n  //     textureArray.set(handMovement, 0)\n  //     handTexture.needsUpdate = true\n  //     mat.uniforms.handTexture.value = handTexture\n  //   })\n  // }\n}\n\nclass NoodleGeo {\n  constructor(props) {\n    let {\n      count = 20,\n      numSides = 4,\n      subdivisions = 50,\n      openEnded = true\n    } = props\n    const radius = 1\n    const length = 1\n\n    const cylinderBufferGeo = new CylinderBufferGeometry(\n      radius,\n      radius,\n      length,\n      numSides,\n      subdivisions,\n      openEnded\n    )\n\n    let baseGeometry = new Geometry()\n    baseGeometry = baseGeometry.fromBufferGeometry(cylinderBufferGeo)\n\n    baseGeometry.rotateZ(Math.PI / 2)\n\n    // compute the radial angle for each position for later extrusion\n    const tmpVec = new Vector2()\n    const xPositions = []\n    const angles = []\n    const uvs = []\n    const vertices = baseGeometry.vertices\n    const faceVertexUvs = baseGeometry.faceVertexUvs[0]\n    const oPositions = []\n\n    // Now go through each face and un-index the geometry.\n    baseGeometry.faces.forEach((face, i) => {\n      const { a, b, c } = face\n      const v0 = vertices[a]\n      const v1 = vertices[b]\n      const v2 = vertices[c]\n      const verts = [v0, v1, v2]\n      const faceUvs = faceVertexUvs[i]\n\n      // For each vertex in this face...\n      verts.forEach((v, j) => {\n        tmpVec.set(v.y, v.z).normalize()\n\n        // the radial angle around the tube\n        const angle = Math.atan2(tmpVec.y, tmpVec.x)\n        angles.push(angle)\n\n        // \"arc length\" in range [-0.5 .. 0.5]\n        xPositions.push(v.x)\n        oPositions.push(v.x, v.y, v.z)\n\n        // copy over the UV for this vertex\n        uvs.push(faceUvs[j].toArray())\n      })\n    })\n\n    // build typed arrays for our attributes\n    const posArray = new Float32Array(xPositions)\n    const angleArray = new Float32Array(angles)\n    const uvArray = new Float32Array(uvs.length * 2)\n\n    const origPosArray = new Float32Array(oPositions)\n\n    // unroll UVs\n    for (let i = 0; i < posArray.length; i++) {\n      const [u, v] = uvs[i]\n      uvArray[i * 2 + 0] = u\n      uvArray[i * 2 + 1] = v\n    }\n\n    const lineGeo = new InstancedBufferGeometry()\n    lineGeo.instanceCount = count\n\n    lineGeo.setAttribute('position', new BufferAttribute(origPosArray, 3))\n    lineGeo.setAttribute('tubeInfo', new BufferAttribute(posArray, 1))\n    lineGeo.setAttribute('angle', new BufferAttribute(angleArray, 1))\n    lineGeo.setAttribute('uv', new BufferAttribute(uvArray, 2))\n\n    let offset = []\n    let ddxyz = Math.floor(Math.pow(count, 1 / 3))\n    let iii = 0\n    for (let z = 0; z < ddxyz; z++) {\n      for (let y = 0; y < ddxyz; y++) {\n        for (let x = 0; x < ddxyz; x++) {\n          offset.push(\n            0.0, //  * (x / ddxyz) * 2.0 - 1.0,\n            0.0, //  * (y / ddxyz) * 2.0 - 1.0,\n            0.0, //  * (z / ddxyz) * 2.0 - 1.0,\n            iii\n          )\n          iii++\n        }\n      }\n    }\n\n    // let ddxyz = Math.floor(Math.pow(count, 1 / 2));\n    // for (let y = 0; y < ddxyz; y++) {\n    //   for (let x = 0; x < ddxyz; x++) {\n    //     offset.push(0.0, (x / ddxyz) * 2.0 - 1.0, (y / ddxyz) * 2.0 - 1.0);\n    //   }\n    // }\n\n    lineGeo.setAttribute(\n      'offset',\n      new InstancedBufferAttribute(new Float32Array(offset), 4)\n    )\n\n    let eachLineIdx = []\n    for (let c = 0; c < count; c++) {\n      eachLineIdx.push(c)\n    }\n\n    // lineGeo.setAttribute(\n    //   \"lineIDXER\",\n    //   new InstancedBufferAttribute(new Float32Array(eachLineIdx), 1)\n    // );\n\n    return {\n      ...props,\n      dataLength: posArray.length,\n      geometry: lineGeo\n    }\n  }\n}\n\nexport class CursorTrackerTail {\n  constructor({ mini, mounter, cursor }) {\n    let node = mini\n    let SCAN_COUNT = 8\n    let TAIL_LENGTH = 64\n\n    //\n    let sim = new LokLokWiggleSimulation({\n      node,\n      mounter,\n      numberOfScans: SCAN_COUNT,\n      trailSize: TAIL_LENGTH\n    })\n\n    let display = new LokLokWiggleDisplay({ node, sim, mounter })\n    this.display = display\n\n    let trackers = []\n\n    let makeTracker = ({ update, setup }) => {\n      let looker = new Object3D()\n      cursor.add(looker)\n      mini.onClean(() => {\n        cursor.remove(looker)\n      })\n\n      let origin = new Object3D()\n      looker.add(origin)\n      let orbit = new Object3D()\n      origin.add(orbit)\n      let worldPos = new Vector3()\n      let lerpWorldPos = new Vector3()\n\n      setup({ origin, orbit })\n\n      node.onLoop(() => {\n        update({ origin, orbit })\n\n        if (mini.now?.camera) {\n          looker.lookAt(mini.now.camera.position)\n        }\n        orbit.getWorldPosition(worldPos)\n\n        lerpWorldPos.lerp(worldPos, 0.3)\n      })\n      trackers.push(lerpWorldPos)\n    }\n\n    let count = 7\n    for (let i = 0; i < count; i++) {\n      makeTracker({\n        setup: ({ origin, orbit }) => {\n          origin.rotation.z += ((Math.PI * 2.0) / count) * i\n        },\n        update: ({ origin, orbit }) => {\n          origin.rotation.z += 0.1\n          // origin.rotation[\"y\"] += 0.1;\n          orbit.position.y = 2 * Math.sin(window.performance.now() / 1000)\n        }\n      })\n    }\n\n    // let makeCross = () => {\n    //   let looker = new Object3D();\n    //   cursor.add(looker);\n    //   mini.onClean(() => {\n    //     cursor.remove(looker);\n    //   });\n\n    //   let cross1 = new Mesh(\n    //     new BoxBufferGeometry(0.02, 1, 0.02),\n    //     new MeshBasicMaterial({ depthTest: false, color: 0xffffff })\n    //   );\n    //   looker.add(cross1);\n\n    //   let cross2 = new Mesh(\n    //     new BoxBufferGeometry(1, 0.02, 0.02),\n    //     new MeshBasicMaterial({ depthTest: false, color: 0xffffff })\n    //   );\n    //   looker.add(cross2);\n\n    //   cross1.userData.enableBloom = true;\n    //   cross2.userData.enableBloom = true;\n\n    //   looker.scale.setScalar(2.0);\n\n    //   node.onLoop(() => {\n    //     if (mini.now?.camera) {\n    //       looker.lookAt(mini.now.camera.position);\n    //     }\n\n    //     let ss = 2 * Math.sin(Math.PI - window.performance.now() / 1000);\n    //     cross1.scale.setScalar(ss);\n    //     cross2.scale.setScalar(ss);\n    //   });\n    // };\n    // makeCross();\n\n    sim.wait.then(() => {\n      node.onLoop(() => {\n        sim.render({\n          trackers\n        })\n      })\n    })\n  }\n}\n","import { useFrame, useThree } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { Camera, MathUtils, Vector3 } from 'three'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\nimport { applyAutoEvent, useAutoEvent } from '../utils/use-auto-event'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { CursorTrackerTail } from '../lib/CursorTrackerTail'\nimport { PerspectiveCamera } from '@react-three/drei'\n\nexport function UserContorls({ Now, avatarSpeed = 2, higherCamera = 1.5 }) {\n  let { get, gl } = useThree()\n  let works = useRef({\n    //\n  })\n\n  useAutoEvent(\n    `touchstart`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useAutoEvent(\n    `touchmove`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useAutoEvent(\n    `touchend`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useEffect(() => {\n    let orig = Now.camMode\n    Now.camMode = 'first'\n    Now.avatarSpeed = avatarSpeed\n    return () => {\n      Now.avatarSpeed = 1\n      Now.camMode = orig\n    }\n  })\n  //\n  useAutoEvent('keydown', (ev) => {\n    // console.log(ev.key);\n\n    if (ev.key === 'w') {\n      Now.keyW = true\n    }\n    if (ev.key === 'a') {\n      Now.keyA = true\n    }\n    if (ev.key === 's') {\n      Now.keyS = true\n    }\n    if (ev.key === 'd') {\n      Now.keyD = true\n    }\n  })\n  useAutoEvent('keyup', (ev) => {\n    // console.log(ev.key);\n\n    if (ev.key === 'w') {\n      Now.keyW = false\n    }\n    if (ev.key === 'a') {\n      Now.keyA = false\n    }\n    if (ev.key === 's') {\n      Now.keyS = false\n    }\n    if (ev.key === 'd') {\n      Now.keyD = false\n    }\n  })\n\n  useEffect(() => {\n    let camera = get().camera\n    camera.near = 0.1\n    camera.far = 10000\n    camera.fov = 45\n    camera.updateProjectionMatrix()\n\n    let fakeCam = new Camera()\n    fakeCam.position.z = 5\n    let orbit = new OrbitControls(fakeCam, gl.domElement)\n    orbit.enableRotate = true\n    orbit.enablePan = false\n    orbit.enableZoom = false\n\n    orbit.enableDamping = true\n    orbit.rotateSpeed = 0.5\n\n    let joystick = document.createElement('div')\n\n    document.body.appendChild(joystick)\n    joystick.style.cssText = `\n      position: absolute;\n      bottom: 30px;\n      left: 30px;\n      width: 80px;\n      height: 80px;\n      color: white;\n      user-select: none;\n      z-index: 20;\n    `\n\n    let note = document.createElement('div')\n    document.body.appendChild(note)\n    note.style.cssText = `\n      position: absolute;\n      bottom: 50px;\n      left: 50px;\n      width: 80px;\n      height: 80px;\n      color: white;\n      user-select: none;\n      z-index: 10;\n      text-align: center;\n      opacity: 0.4;\n    `\n    note.innerHTML = `Walk Around JoyStick`\n\n    let nipplejs = require('nipplejs')\n    var manager = nipplejs.create({\n      zone: joystick,\n      color: 'white',\n      mode: 'static',\n      position: { left: '60px', bottom: '60px' }\n    })\n\n    let forward = new Vector3(0, 0, 0)\n    let up = new Vector3(0, 1, 0)\n\n    let ttt = 0\n    let isUsing = false\n    let nippleAngle = 0\n\n    // window.addEventListener('touchstart', () => {\n    //   isDown = true\n    // })\n    // window.addEventListener('touchend', () => {\n    //   isDown = false\n    // })\n\n    manager.on('start move dir plain', function (evt, nipple) {\n      if (nipple?.angle?.radian) {\n        nippleAngle = nipple?.angle?.radian\n        orbit.enableRotate = false\n\n        isUsing = true\n        // Now.isDown = true;\n\n        clearTimeout(ttt)\n        ttt = setTimeout(() => {\n          isUsing = false\n        }, 100)\n      }\n    })\n\n    manager.on('end', () => {\n      nippleAngle = 0\n      works.current.endForward = () => {\n        forward.multiplyScalar(0.8)\n      }\n      // Now.isDown = false;\n      orbit.enableRotate = true\n      isUsing = false\n    })\n\n    let cte = applyAutoEvent(\n      gl.domElement.parentElement,\n      `touchend`,\n      (ev) => {\n        if (!isUsing) {\n          orbit.enableRotate = true\n        }\n      },\n      { passive: false }\n    )\n    let cts = applyAutoEvent(\n      gl.domElement.parentElement,\n      `touchstart`,\n      (ev) => {\n        if (!isUsing) {\n          orbit.enableRotate = true\n        }\n      },\n      { passive: false }\n    )\n\n    let keyBoardForward = new Vector3(0, 0, 1)\n    let scaler = 0.3\n\n    works.current.ctrl2 = () => {\n      if (isUsing) {\n        forward.set(0, 0, -1)\n        forward.applyAxisAngle(\n          up,\n          orbit.getAzimuthalAngle() + nippleAngle - Math.PI * 0.5 || 0.0\n        )\n      }\n      //\n      if (Now.keyW || Now.keyA || Now.keyS || Now.keyD) {\n        scaler = MathUtils.lerp(scaler, 0.3, 0.1)\n      } else {\n        scaler = MathUtils.lerp(scaler, 0.0, 0.1)\n      }\n\n      // controls.getDirection(dir);\n      if (Now.keyW) {\n        keyBoardForward.set(0, 0, -1 * scaler)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyA) {\n        keyBoardForward.set(-1 * scaler, 0, 0)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyS) {\n        keyBoardForward.set(0, 0, 1 * scaler)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyD) {\n        keyBoardForward.set(1 * scaler, 0, 0)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      }\n\n      Now.goingTo.copy(Now.avatarAt)\n      // if (!(Now.keyW || Now.keyA || Now.keyS || Now.keyD)) {\n      //   Now.avatarAt.copy(Now.avatarAt);\n      // }\n    }\n\n    // grid of raycaster\n\n    works.current.ctrl3 = () => {\n      let newType = 'floor'\n\n      // let upness = Now.cursorNormal.y || 0;\n      if (Now.cursorType !== newType) {\n        Now.cursorType = newType\n      }\n    }\n\n    works.current.ctrl = () => {\n      orbit.update()\n\n      Now.goingTo.add(forward)\n\n      camera.position.x = Now.avatarAt.x\n      camera.position.y = Now.avatarAt.y + higherCamera\n      camera.position.z = Now.avatarAt.z\n\n      camera.rotation.copy(fakeCam.rotation)\n    }\n\n    Now.enableFloorCursor = false\n    return () => {\n      Now.enableFloorCursor = true\n      manager.off('start move end dir plain')\n      manager.destroy()\n      document.body.removeChild(joystick)\n\n      joystick.remove()\n      note.remove()\n      cte()\n      cts()\n    }\n  }, [])\n\n  useFrame(() => {\n    Object.values(works.current).forEach((e) => e())\n  })\n  return (\n    <group>\n      {/*  */}\n      {/*  */}\n      <PerspectiveCamera\n        fov={45}\n        near={0.1}\n        far={10000}\n        position={[0, 20, 20]}\n        rotation-x={Math.PI * -0.25}\n        makeDefault\n      />\n    </group>\n  )\n}\n\nexport function TailCursor({ Now }) {\n  // let { get } = useThree();\n  let { mini } = useMiniEngine()\n  let cursor = useRef()\n\n  useEffect(() => {\n    let mouse = cursor.current\n    console.log(123)\n    if (mouse) {\n      mini.ready.scene.then((scene) => {\n        return new CursorTrackerTail({ mini, cursor: mouse, mounter: scene })\n      })\n    }\n  }, [])\n\n  // let time = 0\n  useFrame((st, dt) => {\n    // time += dt\n    if (cursor.current) {\n      let mouse = cursor.current\n\n      mouse.position.lerp(Now.cursorPos, 0.4)\n\n      // mouse.scale.setScalar(0.15);\n\n      // mouse.lookAt(\n      //   Now.cursorPos.x + Now.cursorNormal.x,\n      //   Now.cursorPos.y + Now.cursorNormal.y,\n      //   Now.cursorPos.z + Now.cursorNormal.z\n      // );\n\n      mouse.lookAt(st.camera.position)\n    }\n  })\n  //\n\n  return <group ref={cursor}>{/*  */}</group>\n}\n/* <HoverDisplay></HoverDisplay> */\n\n// function HoverDisplay({}) {\n//   let { get } = useThree()\n//   Now.makeKeyReactive('hoverData')\n\n//   let ref = useRef()\n\n//   useFrame(({ camera }) => {\n//     if (ref.current) {\n//       ref.current.lookAt(camera.position)\n//     }\n//   })\n\n//   useEffect(() => {\n//     let { scene, camera } = get()\n//     scene.add(camera)\n//     return () => {\n//       scene.remove(camera)\n//     }\n//   })\n\n//   return (\n//     <>\n//       <group position={[0, 0, 10]} ref={ref}></group>\n\n//       {Now.hoverData?.hoverText &&\n//         createPortal(\n//           <group position={[0.1, -0.1, -get().viewport.distance]}>\n//             <Text\n//               outlineWidth={0.00333}\n//               anchorX={'left'}\n//               font={`/font/Cronos-Pro-Light_12448.ttf`}\n//               anchorY={'top'}\n//             >\n//               {`  > ${Now.hoverData?.hoverText || '  '} < `}\n//             </Text>\n//           </group>,\n//           get().camera\n//         )}\n//     </>\n//   )\n// }\n\n// function Floating({ offset = 0, children }) {\n//   let ref = useRef()\n\n//   let time = 0\n//   useFrame((st, dt) => {\n//     time += dt * 2.0\n//     if (ref.current) {\n//       ref.current.position.x = -0.5 + 1.5 * Math.sin(time + offset)\n//     }\n//   })\n\n//   return <group ref={ref}>{children}</group>\n// }\n","import { useFrame } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { CursorTrackerTail } from '../lib/CursorTrackerTail'\n\nexport function TailCursor({ Now }) {\n  let { mini } = useMiniEngine()\n  let cursor = useRef()\n\n  useEffect(() => {\n    let mouse = cursor.current\n    console.log(123)\n    if (mouse) {\n      mini.ready.scene.then((scene) => {\n        return new CursorTrackerTail({ mini, cursor: mouse, mounter: scene })\n      })\n    }\n  }, [])\n\n  // let time = 0\n  useFrame((st, dt) => {\n    // time += dt\n    if (cursor.current) {\n      let mouse = cursor.current\n\n      mouse.position.lerp(Now.cursorPos, 0.4)\n\n      // mouse.scale.setScalar(0.15);\n\n      // mouse.lookAt(\n      //   Now.cursorPos.x + Now.cursorNormal.x,\n      //   Now.cursorPos.y + Now.cursorNormal.y,\n      //   Now.cursorPos.z + Now.cursorNormal.z\n      // );\n\n      mouse.lookAt(st.camera.position)\n    }\n  })\n\n  return <group ref={cursor}>{/*  */}</group>\n}\n/* <HoverDisplay></HoverDisplay> */\n\n// function HoverDisplay({}) {\n//   let { get } = useThree()\n//   Now.makeKeyReactive('hoverData')\n\n//   let ref = useRef()\n\n//   useFrame(({ camera }) => {\n//     if (ref.current) {\n//       ref.current.lookAt(camera.position)\n//     }\n//   })\n\n//   useEffect(() => {\n//     let { scene, camera } = get()\n//     scene.add(camera)\n//     return () => {\n//       scene.remove(camera)\n//     }\n//   })\n\n//   return (\n//     <>\n//       <group position={[0, 0, 10]} ref={ref}></group>\n\n//       {Now.hoverData?.hoverText &&\n//         createPortal(\n//           <group position={[0.1, -0.1, -get().viewport.distance]}>\n//             <Text\n//               outlineWidth={0.00333}\n//               anchorX={'left'}\n//               font={`/font/Cronos-Pro-Light_12448.ttf`}\n//               anchorY={'top'}\n//             >\n//               {`  > ${Now.hoverData?.hoverText || '  '} < `}\n//             </Text>\n//           </group>,\n//           get().camera\n//         )}\n//     </>\n//   )\n// }\n\n// function Floating({ offset = 0, children }) {\n//   let ref = useRef()\n\n//   let time = 0\n//   useFrame((st, dt) => {\n//     time += dt * 2.0\n//     if (ref.current) {\n//       ref.current.position.x = -0.5 + 1.5 * Math.sin(time + offset)\n//     }\n//   })\n\n//   return <group ref={ref}>{children}</group>\n// }\n","import React, { useEffect, useRef } from 'react'\n\nimport { useFrame } from '@react-three/fiber'\nimport {\n  Color,\n  Layers,\n  MeshBasicMaterial,\n  ShaderMaterial,\n  sRGBEncoding,\n  Vector2,\n  WebGLRenderTarget\n} from 'three'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass'\n\nexport const ENTIRE_SCENE = 0\nexport const BLOOM_SCENE = 1\nexport const DARK_SCENE = 2\n\nexport const enableBloom = (item) => {\n  item.layers.enable(BLOOM_SCENE)\n}\n\nexport const enableDarken = (item) => {\n  item.layers.enable(DARK_SCENE)\n}\n\nexport class BloomLayer {\n  constructor({ mini }) {\n    let { get } = mini.now\n\n    let reducedRes = 0.75\n    let resBloom = new Vector2()\n    resBloom.copy({\n      x: get().gl.domElement.width,\n      y: get().gl.domElement.height\n    })\n    resBloom.multiplyScalar(reducedRes)\n\n    let EffectComposer =\n      require('three/examples/jsm/postprocessing/EffectComposer').EffectComposer\n    let RenderPass =\n      require('three/examples/jsm/postprocessing/RenderPass').RenderPass\n    let UnrealBloomPass =\n      require('three/examples/jsm/postprocessing/UnrealBloomPass').UnrealBloomPass\n\n    let efComposer = new EffectComposer(get().gl)\n    mini.onResize(() => {\n      efComposer.setPixelRatio(get().gl.getPixelRatio() * reducedRes)\n    })\n\n    let renderPass = new RenderPass(get().scene, get().camera)\n    mini.onResize(() => {\n      resBloom.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n      resBloom.multiplyScalar(reducedRes)\n      renderPass.setSize(resBloom.x, resBloom.y)\n    })\n    efComposer.addPass(renderPass)\n\n    let unrealPass = new UnrealBloomPass(resBloom, 2, 1, 0.1)\n    mini.onResize(() => {\n      resBloom.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n      resBloom.multiplyScalar(reducedRes)\n      unrealPass.setSize(resBloom.x, resBloom.y)\n    })\n\n    efComposer.addPass(unrealPass)\n    efComposer.renderToScreen = false\n\n    let dark = new Color('#000000')\n    let darkMat = new MeshBasicMaterial({ color: 0x000000, skinning: true })\n    let baseLayer = new Layers()\n    baseLayer.disableAll()\n    baseLayer.enable(ENTIRE_SCENE)\n\n    let bloomLayer = new Layers()\n    bloomLayer.disableAll()\n    bloomLayer.enable(BLOOM_SCENE)\n    let darkLayer = new Layers()\n    darkLayer.disableAll()\n    darkLayer.enable(DARK_SCENE)\n\n    let darken = (it) => {\n      if (!it.text) {\n        it.material = darkMat\n        darkMat.needsUpdate = true\n      }\n      // darkMat.needsUpdate = true;\n    }\n\n    let backup = () => {\n      let { scene } = get()\n\n      scene.traverse((it) => {\n        if (it.material) {\n          it.userData.originalMaterial = it.material\n          it.userData.originalRoughness = it.material.roughness\n          it.userData.originalMetalness = it.material.metalness\n          it.userData.originalColor = it.material.color || new Color('#ffffff')\n          if (it.material?.uniforms?.color?.value) {\n            it.userData.originalUniformColor = it.material.uniforms.color.value\n          }\n        }\n      })\n    }\n\n    let setBloomSceneMat = () => {\n      let { scene } = get()\n\n      scene.traverse((it) => {\n        if (it.isLight) {\n          it.visible = false\n        }\n\n        if (it?.userData?.discard) {\n          it.visible = false\n        }\n\n        if (it.material) {\n          if (it?.userData?.enableDarken) {\n            darken(it)\n          } else if (it?.userData?.enableBloom) {\n            it.material = it.userData.originalMaterial\n          } else if (darkLayer.test(it.layers) || !bloomLayer.test(it.layers)) {\n            darken(it)\n          } else {\n            it.material = it.userData.originalMaterial\n          }\n        }\n      })\n    }\n\n    let renderToTexture = () => {\n      let { scene, clock } = get()\n      let dt = clock.getDelta()\n      let origBG = scene.background\n      scene.background = dark\n      efComposer.render(dt)\n      scene.background = origBG\n    }\n\n    let restore = () => {\n      let { scene } = get()\n      scene.traverse((it) => {\n        if (!it.text && it.material && it.userData.originalMaterial) {\n          it.material = it.userData.originalMaterial\n\n          if (it?.material?.color && it?.userData?.originalColor) {\n            it.material.color = it.userData.originalColor\n          }\n\n          if (it?.userData?.originalRoughness) {\n            it.material.roughness = it.userData.originalRoughness\n            it.material.metalness = it.userData.originalMetalness\n          }\n\n          if (it.material?.uniforms?.color?.value) {\n            it.material.uniforms.color.value = it.userData.originalUniformColor\n          }\n        }\n        if (it.isLight) {\n          it.visible = true\n        }\n\n        if (it?.userData?.discard) {\n          it.visible = true\n        }\n      })\n    }\n\n    this.renderTexture = () => {\n      let { gl } = get()\n      gl.shadowMap.enabled = false\n\n      // bloom with occulsion image\n      backup()\n      setBloomSceneMat()\n      renderToTexture()\n      restore()\n\n      gl.shadowMap.enabled = true\n    }\n    this.getTex = () => {\n      return efComposer.readBuffer.texture\n    }\n  }\n}\n\nexport class BaseLayer {\n  constructor({ mini }) {\n    let { size, gl, get } = mini.now\n\n    let resBase = new Vector2()\n\n    resBase.copy({ x: size.width, y: size.height })\n    resBase.multiplyScalar(gl.getPixelRatio())\n\n    this.rtt = new WebGLRenderTarget(resBase.width, resBase.height, {\n      encoding: sRGBEncoding,\n      generateMipmaps: false\n    })\n    mini.onClean(() => {\n      this.rtt.dispose()\n    })\n    mini.onResize(() => {\n      resBase.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n      resBase.multiplyScalar(gl.getPixelRatio())\n\n      this.rtt = new WebGLRenderTarget(resBase.width, resBase.height, {\n        encoding: sRGBEncoding,\n        generateMipmaps: false\n      })\n    })\n\n    this.renderTexture = () => {\n      let { gl, camera, scene } = get()\n\n      // base image\n      let orig = gl.getRenderTarget()\n      gl.setRenderTarget(this.rtt)\n      gl.render(scene, camera)\n      gl.setRenderTarget(orig)\n    }\n\n    this.getTex = () => {\n      return this.rtt.texture\n    }\n  }\n}\nexport class Compositor {\n  constructor({ mini }) {\n    //\n    let quadMat = new ShaderMaterial({\n      //\n      uniforms: {\n        bloomDiffuse: { value: null },\n        baseDiffuse: { value: null }\n      },\n\n      //\n      vertexShader: `\n        varying vec2 vUv;\n        void main (void) {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vUv = uv;\n        }\n      `,\n\n      fragmentShader: `\n        uniform sampler2D baseDiffuse;\n        uniform sampler2D bloomDiffuse;\n\n        varying vec2 vUv;\n          void main (void) {\n            vec4 baseDiffuseColor = texture2D(baseDiffuse, vUv);\n            vec4 bloomDiffuseColor = texture2D(bloomDiffuse, vUv);\n\n            gl_FragColor = vec4(baseDiffuseColor.rgb * 1.0,  baseDiffuseColor.a);\n\n            gl_FragColor.r += 0.45 * pow(bloomDiffuseColor.r, 0.75);\n            gl_FragColor.g += 0.45 * pow(bloomDiffuseColor.g, 0.75);\n            gl_FragColor.b += 0.45 * pow(bloomDiffuseColor.b, 0.75);\n          }\n        `\n    })\n\n    let fsQuad = new FullScreenQuad(quadMat)\n\n    this.render = ({ baseTex, bloomTex }) => {\n      let { gl } = mini.now\n      if (gl) {\n        quadMat.uniforms.bloomDiffuse.value = bloomTex\n        quadMat.uniforms.baseDiffuse.value = baseTex\n        fsQuad.render(gl)\n      }\n    }\n  }\n}\n\nexport function SimpleBloomer() {\n  let { mini } = useMiniEngine()\n\n  let looer = useRef(() => {})\n\n  useEffect(() => {\n    mini.ready.get.then(() => {\n      //\n      let base = new BaseLayer({ mini })\n      let bloom = new BloomLayer({ mini })\n      let compositor = new Compositor({ mini })\n\n      //\n      looer.current = () => {\n        base.renderTexture()\n        bloom.renderTexture()\n\n        compositor.render({\n          baseTex: base.getTex(),\n          bloomTex: bloom.getTex()\n        })\n      }\n    })\n  }, [])\n\n  // invalidate orignal loop\n  useFrame(() => {\n    looer.current()\n  }, 1000)\n\n  return null\n}\n","import { Sphere } from '@react-three/drei'\nimport { useFrame } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { DoubleSide } from 'three'\n\nexport function StarSky() {\n  let shaders = {\n    vertexShader: /* glsl */ `\n    varying vec3 vPos;\n    varying vec3 vUv3;\n\n    void main() {\n      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n      gl_Position = projectionMatrix * mvPosition;\n      vPos = position;\n      vUv3 = uv.xyx;\n    }\n    `,\n    fragmentShader: `\n      precision highp float;\n\n      vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n      vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n      float cnoise(vec3 P){\n        vec3 Pi0 = floor(P); // Integer part for indexing\n        vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n        Pi0 = mod(Pi0, 289.0);\n        Pi1 = mod(Pi1, 289.0);\n        vec3 Pf0 = fract(P); // Fractional part for interpolation\n        vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n        vec4 iy = vec4(Pi0.yy, Pi1.yy);\n        vec4 iz0 = Pi0.zzzz;\n        vec4 iz1 = Pi1.zzzz;\n\n        vec4 ixy = permute(permute(ix) + iy);\n        vec4 ixy0 = permute(ixy + iz0);\n        vec4 ixy1 = permute(ixy + iz1);\n\n        vec4 gx0 = ixy0 / 7.0;\n        vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n        gx0 = fract(gx0);\n        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n        vec4 sz0 = step(gz0, vec4(0.0));\n        gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n        gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n        vec4 gx1 = ixy1 / 7.0;\n        vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n        gx1 = fract(gx1);\n        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n        vec4 sz1 = step(gz1, vec4(0.0));\n        gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n        gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n        g000 *= norm0.x;\n        g010 *= norm0.y;\n        g100 *= norm0.z;\n        g110 *= norm0.w;\n        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n        g001 *= norm1.x;\n        g011 *= norm1.y;\n        g101 *= norm1.z;\n        g111 *= norm1.w;\n\n        float n000 = dot(g000, Pf0);\n        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n        float n111 = dot(g111, Pf1);\n\n        vec3 fade_xyz = fade(Pf0);\n        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n        return 2.2 * n_xyz;\n      }\n\n      varying vec3 vPos;\n      uniform float time;\n      varying vec3 vUv3;\n\n      void main() {\n        float speed = time / 3.5;\n        vec3 pp = vUv3.xyx * 600.0;\n        // pp = vPos * 0.25 + speed;\n        float noise = clamp(cnoise(speed + pp / 250.0 + 0.0 ), 0.0, 1.0);\n\n        vec3 colorA = vec3(81.0, 135.0, 228.0) * 0.2 / 255.0;\n        vec3 colorB = vec3(0.0, 150.0, 136.0) * 0.2 / 255.0;\n\n        vec4 backgroundColor = vec4(mix(colorA, colorB, noise), 1.0);\n\n        gl_FragColor = backgroundColor;\n\n        float starNoise = (noise) * pow(cnoise(speed + pp * 2.0) * 0.5 + 0.5, 15.5) * 30.0;\n\n        gl_FragColor.rgb += vec3(pow(starNoise, 1.3)) * 1.5;\n      }\n      `\n  }\n\n  let ref = useRef()\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.needsUpdate = true\n    }\n  }, [shaders, shaders.fragmentShader, shaders.vertexShader])\n\n  let uniforms = useRef({\n    time: { value: 0 }\n  })\n\n  useFrame(() => {\n    uniforms.current.time.value += 1 / 60\n  })\n\n  return (\n    <Sphere\n      frustumCulled={false}\n      userData={{\n        enableBloom: true\n      }}\n      scale={1}\n      args={[800, 20, 20]}\n    >\n      <shaderMaterial\n        ref={ref}\n        uniforms={uniforms.current}\n        fragmentShader={shaders.fragmentShader}\n        vertexShader={shaders.vertexShader}\n        side={DoubleSide}\n      >\n        {/*  */}\n        {/*  */}\n      </shaderMaterial>\n    </Sphere>\n  )\n}\n","import { useThree } from '@react-three/fiber'\nimport { useEffect } from 'react'\n\nimport { PMREMGenerator, sRGBEncoding, TextureLoader } from 'three'\n\nexport function EnvLightByImage({ imageURL }) {\n  //\n  let { scene, gl } = useThree()\n  useEffect(() => {\n    const pmremGenerator = new PMREMGenerator(gl)\n    pmremGenerator.compileEquirectangularShader()\n\n    let loader = new TextureLoader()\n    // loader.setDataType(UnsignedByteType);\n    loader.load(imageURL, (texture) => {\n      const envMap = pmremGenerator.fromEquirectangular(texture).texture\n      envMap.encoding = sRGBEncoding\n      // scene.background = envMap;\n      scene.environment = envMap\n    })\n\n    return () => {\n      scene.environment = null\n      scene.background = null\n    }\n  }, [imageURL])\n\n  return null\n}\n","import React, { Suspense, useMemo } from 'react'\nimport { Canvas } from '@react-three/fiber'\nimport { useGLTF, PerspectiveCamera } from '@react-three/drei'\n\nimport {\n  Map3D,\n  UserContorls,\n  TailCursor,\n  SimpleBloomer,\n  StarSky,\n  EnvLightByImage\n} from 'effectnode-3dworld'\nimport { SkeletonUtils } from 'three/examples/jsm/utils/SkeletonUtils'\nimport { Vector3 } from 'three'\n\n// needs trailing slash\nexport const BASE_URL =\n  process.env.NODE_ENV === 'production'\n    ? `https://wonglok.github.io/effectnode-3dworld/`\n    : `/`\n\nconst App = () => {\n  return (\n    <Canvas style={{ width: '100%', height: '100%' }}>\n      <Suspense\n        fallback={\n          // Loading screen\n          <group>\n            <group rotation-x={Math.PI * 0}>\n              <gridHelper args={[150, 50, 0x232323, 0xaaaaaa]}></gridHelper>\n            </group>\n            <PerspectiveCamera\n              position={[0, 20, 20]}\n              rotation-x={Math.PI * -0.25}\n              makeDefault={true}\n            ></PerspectiveCamera>\n          </group>\n        }\n      >\n        <Content3D></Content3D>\n      </Suspense>\n    </Canvas>\n  )\n}\n\nfunction Content3D() {\n  let gltf = useGLTF(`${BASE_URL}map/demo-map-000.glb`)\n\n  let { floor, startAt } = useMemo(() => {\n    let floor = SkeletonUtils.clone(gltf.scene)\n    let startAt = new Vector3(0, 0, 0)\n\n    floor.traverse((it) => {\n      if (it) {\n        if (it.material) {\n          it.material = it.material.clone()\n        }\n        if (it.geometry) {\n          it.userData.isFloor = true\n        }\n        if (it?.userData?.startAt) {\n          it.getWorldPosition(startAt)\n        }\n      }\n    })\n\n    return { floor, startAt }\n  }, [gltf])\n\n  return (\n    <group>\n      {floor && (\n        <Map3D floor={floor} startAt={startAt}>\n          {({ Now }) => {\n            return (\n              <group>\n                <UserContorls\n                  higherCamera={1.5}\n                  avatarSpeed={2}\n                  Now={Now}\n                ></UserContorls>\n                <TailCursor Now={Now}></TailCursor>\n              </group>\n            )\n          }}\n        </Map3D>\n      )}\n\n      <primitive object={floor}></primitive>\n      <directionalLight position={[10, 10, 10]}></directionalLight>\n      <EnvLightByImage imageURL={`${BASE_URL}image/sky.png`}></EnvLightByImage>\n\n      {/* extras */}\n      <StarSky></StarSky>\n      <SimpleBloomer></SimpleBloomer>\n    </group>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}