{"version":3,"sources":["../../src/utils/make-shallow-store.js","../../src/utils/get-id.js","../../src/lib/Mini.js","../../src/utils/use-mini-engine.js","../../src/utils/use-auto-event.js","../../src/lib/Collider.js","../../src/lib/MapPlayer.js","../../src/use/useComputeEnvMap.js","../../src/utils/make-now.js","../../src/compos/Map3D.js","../../src/compos/UserContorls.js","../../src/lib/CursorTrackerTail.js","../../src/compos/TailCursor.js","../../src/compos/SimpleBloomer.js","../../src/compos/StarSky.js","../../src/compos/Tooltip.js","../../src/compos/TheHelper.js","App.js","index.js"],"names":["makeShallowStore","myObject","___NameSpaceID","Math","Utils","exportJSON","JSON","getNameSpcaeID","onEvent","evName","hh","func","window","makeKeyReactive","useState","vv","setSt","useEffect","s","reloadKey","CustomEvent","detail","Proxy","get","o","set","Mini","parent","this","Promise","ttt","setInterval","clearInterval","resolve","isAborted","num","fnc","intv","clearTimeout","setTimeout","e","isPaused","console","name","duration","start","t","lt","dt","useMiniEngine","useThree","mini","useFrame","st","useAutoEvent","settings","passive","dom","applyAutoEvent","Collider","floor","scene","collider","makeCollider","BufferGeometryUtils","require","environment","SkeletonUtils","geometries","c","cloned","key","it","mergedGeometry","MeshBVH","color","scanCenter","camera","raycaster","center","result","source","first","MapPlayer","startAt","Now","RoundedBoxGeometry","player","transparent","opacity","radius","segment","avatarDir","playerVelocity","tempVector","tempVector2","tempBox","tempMat","tempSegment","rotationCopier","delta","size","capsuleInfo","intersectsBounds","box","intersectsTriangle","triPoint","capsulePoint","distance","tri","depth","direction","newPosition","deltaVector","playerIsOnGround","clock","i","updatePlayer","DefaultCode","Map3D","children","object","nowRef","useRef","colliderRef","mapPlayerRef","setFloor","gl","startLookAt","moved","goingTo","camAt","avatarAt","avatarHead","avatarRot","avatarFaceLook","avatarLoading","avatarMode","avatarSpeed","tooltip","keyW","keyA","keyS","keyD","cursorPos","cursorNormal","cursorType","hoverData","isDown","camMode","overlay","profile","user","reload","onlineUID","cleanPhysical","sub","handleLights","colliderManager","mapPlayer","changeTailColor","lastScan","hit","current","UserContorls","higherCamera","works","ev","orig","fakeCam","orbit","OrbitControls","joystick","document","note","manager","zone","mode","position","left","bottom","forward","up","isUsing","nippleAngle","evt","nipple","cte","cts","keyBoardForward","scaler","MathUtils","Object","fov","near","far","rotation-x","makeDefault","LokLokWiggleSimulation","node","numberOfScans","trailSize","WIDTH","setup","GPUComputationRenderer","gpu","dtPosition","lookUpTexture","value","h","ii","error","positionShader","str","mouseUniforms","lookupRightLine","fillPositionTexture","theArray","texture","y","x","fillLookupTexture","items","lastOneInArray","render","trackers","uniform","getTextureAfterCompute","posTexture","getCurrentRenderTarget","LokLokWiggleDisplay","sim","mounter","count","numSides","subdivisions","openEnded","geometry","getPointAtByT","controlPointsResolution","lineIdx","lineCount","HEIGHT","textureName","floatval","Number","latestColor","matLine0","uniforms","tailColor","time","matcap","vertexShader","pointLineMaker","getLinesPointAtT","fragmentShader","depthTest","line0","NoodleGeo","props","cylinderBufferGeo","baseGeometry","tmpVec","xPositions","angles","uvs","vertices","faceVertexUvs","oPositions","a","face","b","verts","faceUvs","v","angle","posArray","Float32Array","angleArray","uvArray","origPosArray","u","lineGeo","offset","ddxyz","iii","z","dataLength","CursorTrackerTail","cursor","display","update","looker","origin","worldPos","lerpWorldPos","makeTracker","TailCursor","colorObj","mouse","ref","BloomLayer","resBloom","height","EffectComposer","RenderPass","UnrealBloomPass","efComposer","renderPass","unrealPass","dark","baseLayer","bloomLayer","darkLayer","onBeforeCompileForStdMat","globalDarkening","shader","uniqueMaterialMap","enableDarkenMap","darken","origBG","renderToTexture","BaseLayer","resBase","encoding","generateMipmaps","Compositor","quadMat","bloomDiffuse","baseDiffuse","fsQuad","baseTex","bloomTex","SimpleBloomer","looer","base","bloom","compositor","StarSky","shaders","frustumCulled","userData","enableBloom","scale","args","side","DoubleSide","Tooltip","createPortal","anchorX","anchorY","disableBloom","outlineWidth","fontSize","TheHelper","TheCursor","core","rotation","Floating","target","ClickToOpen","move","href","HideCursor","BASE_URL","Content3D","gltf","useGLTF","ShaderEnvLight","imageURL","tex","useTexture","envMap","code","res","frames","Infinity","useMemo","material","type","blending","NoBlending","mesh","cubeRtt","format","magFilter","minFilter","LinearMipmapLinearFilter","compute","useComputeEnvMap","trim","textureBG","LoadingScreen","PI","PerspectiveCamera","App","dpr","style","width","fallback","ReactDOM","getElementById"],"mappings":"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","file":"static/js/main.bab37ef9.chunk.js","sourcesContent":["import { useEffect, useState } from 'react'\nimport { getID } from './get-id'\nexport const makeShallowStore = (myObject = {}) => {\n  let ___NameSpaceID = getID()\n  let Utils = {\n    exportJSON: () => {\n      return JSON.parse(JSON.stringify(myObject))\n    },\n    getNameSpcaeID: () => {\n      return ___NameSpaceID\n    },\n    /* */\n    onEvent: (key, func) => {\n      let evName = `${___NameSpaceID}`\n      let hh = () => {\n        func(myObject[key])\n      }\n\n      window.addEventListener(`${evName}-${key}`, hh)\n      return () => {\n        window.removeEventListener(`${evName}-${key}`, hh)\n      }\n    },\n\n    makeKeyReactive: (key) => {\n      let [vv, setSt] = useState(0)\n      useEffect(() => {\n        let evName = `${___NameSpaceID}`\n\n        let hh = () => {\n          setSt((s) => {\n            return s + 1\n          })\n        }\n\n        window.addEventListener(`${evName}-${key}`, hh)\n        return () => {\n          window.removeEventListener(`${evName}-${key}`, hh)\n        }\n      }, [vv])\n    },\n\n    reloadKey: (key) => {\n      window.dispatchEvent(\n        new CustomEvent(`${___NameSpaceID}-${key}`, { detail: {} })\n      )\n    }\n  }\n\n  let proxy = new Proxy(myObject, {\n    get: (o, k) => {\n      //\n      if (Utils[k]) {\n        return Utils[k]\n      }\n\n      return o[k]\n    },\n    set: (o, key, val) => {\n      let currentVal = o[key]\n\n      if (currentVal !== val) {\n        o[key] = val\n\n        if (typeof window !== 'undefined') {\n          window.dispatchEvent(\n            new CustomEvent(`${___NameSpaceID}-${key}`, { detail: {} })\n          )\n        }\n      }\n\n      return true\n    }\n  })\n\n  return proxy\n}\n","export const getID = function () {\n  return (\n    '_' +\n    Math.random().toString(36).substr(2, 9) +\n    Math.random().toString(36).substr(2, 9)\n  )\n}\n","export class Mini {\n  constructor({ parent = false }) {\n    this.parent = parent\n    this.resource = new Map()\n    this.get = (k) => {\n      return new Promise((resolve) => {\n        let ttt = 0\n        ttt = setInterval(() => {\n          if (this.parent) {\n            if (this.resource.has(k) || this.parent.resource.has(k)) {\n              clearInterval(ttt)\n              resolve(this.resource.get(k) || this.parent.resource.get(k))\n            }\n          } else {\n            if (this.resource.has(k)) {\n              clearInterval(ttt)\n              resolve(this.resource.get(k))\n            }\n          }\n        })\n      })\n    }\n    this.set = (k, v) => {\n      this.resource.set(k, v)\n    }\n    this.name = 'ENMini'\n\n    let isAborted = false\n    this.tasks = []\n    this.resizeTasks = []\n    this.cleanTasks = []\n    this.onLoop = (fnc, num = 0) => {\n      if (num >= 0) {\n        this.tasks.push(fnc)\n      } else {\n        this.tasks.unshift(fnc)\n      }\n    }\n\n    this.onResize = (fnc) => {\n      fnc()\n      this.resizeTasks.push(fnc)\n    }\n\n    this.onClean = (func) => {\n      this.cleanTasks.push(func)\n    }\n\n    let intv = 0\n    const internalResize = () => {\n      clearTimeout(intv)\n      intv = setTimeout(() => {\n        this.resizeTasks.forEach((e) => e())\n      }, 16.8888)\n    }\n\n    window.addEventListener('resize', () => {\n      internalResize()\n    })\n\n    let isPaused = false\n    this.toggle = () => {\n      isPaused = !isPaused\n    }\n    this.pause = () => {\n      isPaused = true\n    }\n    this.play = () => {\n      isPaused = false\n    }\n\n    this.clean = () => {\n      isAborted = true\n      try {\n        this.cleanTasks.forEach((e) => e())\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    this.lastTime = window.performance.now()\n    this.work = () => {\n      this.timeNow = window.performance.now()\n      if (isAborted) {\n        return {\n          name: this.name,\n          duration: 0\n        }\n      }\n      if (isPaused) {\n        return {\n          name: this.name,\n          duration: 0\n        }\n      }\n      const start = window.performance.now()\n      try {\n        let t = this.timeNow\n        const lt = this.lastTime\n        let dt = t - lt\n        this.lastTime = t\n        dt = dt / 1000\n        t = t / 1000\n        if (dt >= 100) {\n          dt = 100\n        }\n\n        this.tasks.forEach((e) => e(t, dt))\n      } catch (e) {\n        console.error(e)\n      }\n      const end = window.performance.now()\n      const duration = end - start\n\n      return {\n        name: this.name,\n        duration\n      }\n    }\n\n    this.ready = new Proxy(\n      {},\n      {\n        get: (obj, key) => {\n          return this.get(key)\n        }\n      }\n    )\n    this.now = new Proxy(\n      {},\n      {\n        get: (obj, key) => {\n          if (this.parent) {\n            return this.resource.get(key) || this.parent.resource.get(key)\n          } else {\n            return this.resource.get(key)\n          }\n        }\n      }\n    )\n  }\n}\n\n// let mini = new Mini({ name: \"base\", domElement: ref.current, window });\n//\n\n//\n//\n//\n","import { useFrame, useThree } from '@react-three/fiber'\nimport { useEffect, useState } from 'react'\nimport { Mini } from '../lib/Mini'\n\nexport function useMiniEngine() {\n  const { get } = useThree()\n  const [mini] = useState(() => {\n    return new Mini({})\n  })\n\n  useEffect(() => {\n    return () => {\n      mini.clean()\n    }\n  }, [])\n\n  useFrame(() => {\n    const st = get()\n    for (const kn in st) {\n      mini.set(kn, st[kn])\n    }\n    mini.work()\n  })\n\n  return { mini }\n}\n","import { useEffect } from 'react'\n\nexport const useAutoEvent = function (\n  ev,\n  fnc,\n  settings = { passive: false },\n  dom\n) {\n  useEffect(() => {\n    dom = dom || window\n    dom.addEventListener(ev, fnc, settings)\n    return () => {\n      dom = dom || window\n      dom.removeEventListener(ev, fnc)\n    }\n  }, [])\n}\n\nexport const applyAutoEvent = function (\n  dom,\n  ev,\n  fnc,\n  settings = { passive: false }\n) {\n  dom = dom || window\n  dom.addEventListener(ev, fnc, settings)\n  return () => {\n    dom = dom || window\n    dom.removeEventListener(ev, fnc)\n  }\n}\n","import { Mesh, MeshBasicMaterial, Raycaster, Vector2 } from 'three'\nimport { MeshBVH } from 'three-mesh-bvh'\nexport class Collider {\n  constructor({ floor, scene }) {\n    this.floor = floor\n    this.center = new Vector2(0, 0)\n    this.raycaster = new Raycaster()\n    this.scene = scene\n\n    const collider = this.makeCollider()\n    this.collider = collider\n    this.preview = collider\n  }\n\n  makeCollider() {\n    const { scene, floor } = this\n    const BufferGeometryUtils =\n      require('three/examples/jsm/utils/BufferGeometryUtils').BufferGeometryUtils\n    const SkeletonUtils =\n      require('three/examples/jsm/utils/SkeletonUtils').SkeletonUtils\n\n    const environment = SkeletonUtils.clone(floor)\n\n    const geometries = []\n\n    environment.updateMatrixWorld()\n    environment.traverse((c) => {\n      if (c.geometry && !c.userData.isNotFloor) {\n        const cloned = c.geometry.clone()\n        cloned.applyMatrix4(c.matrixWorld)\n\n        for (const key in cloned.attributes) {\n          if (key === 'position' || key === 'index') {\n          } else {\n            cloned.deleteAttribute(key)\n          }\n        }\n\n        geometries.push(cloned)\n      }\n    })\n\n    scene.traverse((it) => {\n      if (it && it.userData && it.userData.isFloor && it.geometry) {\n        const cloned = it.geometry.clone()\n        it.updateMatrixWorld()\n\n        cloned.applyMatrix4(it.matrixWorld)\n        for (const key in cloned.attributes) {\n          if (key !== 'position') {\n            cloned.deleteAttribute(key)\n          }\n        }\n        geometries.push(cloned)\n      }\n    })\n\n    const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(\n      geometries,\n      false\n    )\n\n    mergedGeometry.boundsTree = new MeshBVH(mergedGeometry)\n\n    const collider = new Mesh(\n      mergedGeometry,\n      new MeshBasicMaterial({ color: 0xffffff })\n    )\n    collider.material.wireframe = true\n    collider.material.opacity = 0.5\n    collider.material.transparent = true\n    collider.updateMatrixWorld()\n\n    return collider\n  }\n\n  //\n  scanCenter({ camera, scene }) {\n    const { raycaster, center, collider } = this\n\n    raycaster.setFromCamera(center, camera)\n    const result = []\n    const source = []\n    scene.traverse((it) => {\n      if (\n        it.geometry &&\n        (it?.userData?.isHoverable ||\n          it?.userData?.isFloor ||\n          it?.userData?.tooltip ||\n          it?.userData?.website)\n      ) {\n        source.push(it)\n      }\n    })\n    raycaster.intersectObjects(source, false, result)\n\n    collider.geometry.boundsTree.raycastFirst(\n      collider,\n      raycaster,\n      raycaster.ray\n    )\n\n    const first = result[0]\n\n    if (first) {\n      return first\n    } else {\n      return false\n    }\n  }\n}\n","import {\n  Box3,\n  Clock,\n  Line3,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  Object3D,\n  Vector3\n} from 'three'\n\nexport class MapPlayer {\n  constructor({ collider, startAt, Now }) {\n    this.collider = collider\n    const RoundedBoxGeometry =\n      require('three/examples/jsm/geometries/RoundedBoxGeometry.js').RoundedBoxGeometry\n    const scale = 1\n    const radius = 1.3 * scale\n    const width = 1 * scale\n    const height = 2 * scale\n    const depth = 1 * scale\n    const player = new Mesh(\n      new RoundedBoxGeometry(width, height, depth, 8, radius),\n      new MeshLambertMaterial({ transparent: true, opacity: 1 })\n    )\n    player.geometry.translate(0, -radius, 0)\n    player.castShadow = true\n\n    player.capsuleInfo = {\n      radius: radius,\n      segment: new Line3(new Vector3(), new Vector3(0, -1.0, 0.0))\n    }\n    this.player = player\n\n    player.position.copy(startAt)\n    player.position.y += 5\n\n    player.geometry.computeBoundingBox()\n    player.collider = new Box3().copy(player.geometry.boundingBox)\n\n    const avatarDir = new Vector3()\n    const playerVelocity = new Vector3(0, 0, 0)\n    // const upVector = new Vector3(0, 1, 0);\n    const tempVector = new Vector3()\n    const tempVector2 = new Vector3()\n    const tempBox = new Box3()\n    const tempMat = new Matrix4()\n    const tempSegment = new Line3()\n    const rotationCopier = new Object3D()\n    let playerIsOnGround = true\n\n    function updatePlayer({ delta, player }) {\n      // fall down\n      playerVelocity.y += delta * -9.8\n\n      player.position.addScaledVector(playerVelocity, delta)\n\n      if (player.position.y <= -50) {\n        // player.position.y = 0;\n        player.position.copy(startAt)\n        Now.goingTo.copy(startAt)\n        Now.goingTo.z += 1\n        playerVelocity.y = 0.0\n      }\n\n      avatarDir.copy(Now.goingTo).sub(player.position)\n      avatarDir.y = 0\n      const size = avatarDir.length()\n      avatarDir.normalize()\n      avatarDir.y = 0\n\n      avatarDir.multiplyScalar(Now.avatarSpeed)\n\n      if (size >= 0.1) {\n        player.position.addScaledVector(avatarDir, 0.04)\n        Now.avatarMode = 'running'\n      } else {\n        Now.avatarMode = 'standing'\n      }\n\n      player.updateMatrixWorld()\n\n      // adjust player position based on collisions\n      const capsuleInfo = player.capsuleInfo\n      tempBox.makeEmpty()\n      tempMat.copy(collider.matrixWorld).invert()\n      tempSegment.copy(capsuleInfo.segment)\n\n      // get the position of the capsule in the local space of the collider\n      tempSegment.start.applyMatrix4(player.matrixWorld).applyMatrix4(tempMat)\n      tempSegment.end.applyMatrix4(player.matrixWorld).applyMatrix4(tempMat)\n\n      // get the axis aligned bounding box of the capsule\n      tempBox.expandByPoint(tempSegment.start)\n      tempBox.expandByPoint(tempSegment.end)\n\n      tempBox.min.addScalar(-capsuleInfo.radius)\n      tempBox.max.addScalar(capsuleInfo.radius)\n\n      collider.geometry.boundsTree.shapecast(collider, {\n        intersectsBounds: (box) => box.intersectsBox(tempBox),\n\n        intersectsTriangle: (tri) => {\n          // check if the triangle is intersecting the capsule and adjust the\n          // capsule position if it is.\n          const triPoint = tempVector\n          const capsulePoint = tempVector2\n\n          const distance = tri.closestPointToSegment(\n            tempSegment,\n            triPoint,\n            capsulePoint\n          )\n          if (distance < capsuleInfo.radius) {\n            const depth = capsuleInfo.radius - distance\n            const direction = capsulePoint.sub(triPoint).normalize()\n\n            tempSegment.start.addScaledVector(direction, depth)\n            tempSegment.end.addScaledVector(direction, depth)\n          }\n        }\n      })\n\n      // get the adjusted position of the capsule collider in world space after checking\n      // triangle collisions and moving it. capsuleInfo.segment.start is assumed to be\n      // the origin of the player model.\n      const newPosition = tempVector\n      newPosition.copy(tempSegment.start).applyMatrix4(collider.matrixWorld)\n\n      // check how much the collider was moved\n      const deltaVector = tempVector2\n      deltaVector.subVectors(newPosition, player.position)\n\n      // adjust the player model\n      player.position.copy(newPosition)\n\n      //\n      Now.avatarAt.copy(player.position)\n      // Now.avatarAt.y += 0.1;\n\n      rotationCopier.position.copy(player.position)\n      rotationCopier.lookAt(\n        //\n        Now.goingTo.x,\n        player.position.y,\n        Now.goingTo.z\n      )\n\n      Now.avatarRot.x = rotationCopier.rotation.x\n      Now.avatarRot.y = rotationCopier.rotation.y\n      Now.avatarRot.z = rotationCopier.rotation.z\n\n      // if the player was primarily adjusted vertically we assume it's on something we should consider gound\n      playerIsOnGround =\n        deltaVector.y > Math.abs(delta * playerVelocity.y * 0.25)\n\n      if (!playerIsOnGround) {\n        deltaVector.normalize()\n        playerVelocity.addScaledVector(\n          deltaVector,\n          -deltaVector.dot(playerVelocity)\n        )\n        //\n      } else {\n        playerVelocity.set(0, 0, 0)\n      }\n    }\n\n    const steps = 4\n    const clock = new Clock()\n\n    this.onSimulate = () => {\n      let dt = clock.getDelta()\n      if (dt >= 1 / 30) {\n        dt = 1 / 30\n      }\n\n      for (let i = 0; i < steps; i++) {\n        updatePlayer({ delta: dt / steps, player })\n      }\n    }\n  }\n}\n","import { useFrame, useThree } from '@react-three/fiber'\nimport { useEffect, useMemo, useRef } from 'react'\n\nimport {\n  WebGLCubeRenderTarget,\n  Scene,\n  Mesh,\n  ShaderMaterial,\n  CubeRefractionMapping,\n  BackSide,\n  NoBlending,\n  BoxBufferGeometry,\n  CubeCamera,\n  LinearMipmapLinearFilter,\n  RGBFormat,\n  LinearFilter,\n  CubeReflectionMapping,\n  sRGBEncoding\n} from 'three'\n\n// import { cloneUniforms } from \"three/src/renderers/shaders/UniformsUtils.js\";\n// import * as dat from '';\n\nlet DefaultCode = `\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p ) {\n  return sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = m * p * 2.02;\n    f += 0.2500 * noise( p ); p = m * p * 2.03;\n    f += 0.1250 * noise( p ); p = m * p * 2.01;\n    f += 0.0625 * noise( p );\n    return f / 0.9375;\n}\n\nfloat fbm6( vec2 p ) {\n    float f = 0.0;\n    f += 0.500000*(0.5 + 0.5 * noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5 + 0.5 * noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5 + 0.5 * noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5 + 0.5 * noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5 + 0.5 * noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5 + 0.5 * noise( p ));\n    return f/0.96875;\n}\n\nfloat pattern (vec2 p) {\n  float vout = fbm4( p + time + fbm6(  p + fbm4( p + time )) );\n  return abs(vout);\n}\n\nvec4 mainImage (vec2 uv) {\n  return vec4(vec3(\n    0.35 + pattern(uv * 1.70123 + -0.17 * cos(time * 0.05)),\n    0.35 + pattern(uv * 1.70123 +  0.0 * cos(time * 0.05)),\n    0.35 + pattern(uv * 1.70123 +  0.17 * cos(time * 0.05))\n  ), 1.0);\n}\n`\n\nexport function useComputeEnvMap(\n  code = DefaultCode,\n  uniforms = {},\n  res = 128,\n  frames = Infinity\n) {\n  let { get } = useThree()\n\n  let { envMap, compute } = useMemo(() => {\n    let { gl } = get()\n\n    var scene = new Scene()\n\n    var shader = {\n      uniforms: {\n        ...uniforms,\n        time: { value: 0.5 }\n      },\n\n      vertexShader: `\n        varying vec3 vWorldDirection;\n        vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n          return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n        }\n        void main() {\n          vWorldDirection = transformDirection( position, modelMatrix );\n          #include <begin_vertex>\n          #include <project_vertex>\n        }\n      `,\n\n      fragmentShader: `\n      varying vec3 vWorldDirection;\n\n\n        #define RECIPROCAL_PI 0.31830988618\n        #define RECIPROCAL_PI2 0.15915494\n\n        uniform float time;\n        ${code || DefaultCode}\n\n        void main() {\n          vec3 direction = normalize( vWorldDirection );\n          vec2 sampleUV;\n          sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n          sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\n          gl_FragColor = mainImage(sampleUV);\n\n        }\n      `\n    }\n\n    var material = new ShaderMaterial({\n      type: 'CubemapFromEquirect',\n      uniforms: shader.uniforms,\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      side: BackSide,\n      blending: NoBlending\n    })\n\n    var mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material)\n    scene.add(mesh)\n\n    var cubeRtt = new WebGLCubeRenderTarget(res, {\n      format: RGBFormat,\n      generateMipmaps: true,\n      magFilter: LinearFilter,\n      minFilter: LinearMipmapLinearFilter\n    })\n\n    var camera = new CubeCamera(1, 100000, cubeRtt)\n\n    shader.uniforms.time.value = 0.4\n    camera.update(gl, scene)\n\n    let compute = () => {\n      shader.uniforms.time.value += 1 / 60\n      camera.update(gl, scene)\n    }\n\n    cubeRtt.texture.mapping = CubeRefractionMapping\n    cubeRtt.texture.mapping = CubeReflectionMapping\n    cubeRtt.texture.encoding = sRGBEncoding\n\n    return {\n      envMap: cubeRtt.texture,\n      compute\n    }\n  }, [code])\n\n  let i = 0\n  useFrame(() => {\n    if (i <= frames) {\n      i++\n      compute()\n    }\n  })\n\n  return envMap\n}\n","import { Vector3 } from 'three'\nimport { makeShallowStore } from './make-shallow-store'\n\nexport const makeNow = () => {\n  return makeShallowStore({\n    //\n    startLookAt: new Vector3(),\n    startAt: new Vector3(),\n    //\n    moved: 0,\n    goingTo: new Vector3(),\n    camAt: new Vector3(),\n    avatarAt: new Vector3(),\n    avatarHead: new Vector3(),\n    avatarRot: new Vector3(),\n    avatarFaceLook: new Vector3(),\n    avatarLoading: true,\n    avatarMode: 'standing',\n    avatarSpeed: 1.0,\n\n    tooltip: '',\n    keyW: false,\n    keyA: false,\n    keyS: false,\n    keyD: false,\n    cursorPos: new Vector3(),\n    cursorNormal: new Vector3(),\n    cursorType: 'hide',\n    hoverData: false,\n    isDown: false,\n\n    // avatarAtPhy: new Vector3(),\n\n    camMode: 'first',\n\n    overlay: '',\n\n    profile: false,\n    user: false,\n\n    reload: [],\n    onlineUID: []\n  })\n}\n","import { useFrame, useThree } from '@react-three/fiber'\nimport React, { useMemo, useEffect, useRef, useState } from 'react'\nimport { Collider } from '../lib/Collider'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { makeNow } from '../utils/make-now'\nimport { MapPlayer } from '../lib/MapPlayer'\nimport { SkeletonUtils } from 'three/examples/jsm/utils/SkeletonUtils'\nimport { PCFSoftShadowMap, PointLight } from 'three'\n\nexport const Map3D = ({ children, object }) => {\n  const { get } = useThree()\n  const nowRef = useRef()\n\n  const { mini } = useMiniEngine()\n  const colliderRef = useRef()\n  const mapPlayerRef = useRef()\n\n  const [floor, setFloor] = useState(false)\n\n  useEffect(() => {\n    let { gl } = get()\n\n    gl.shadowMap.enabled = true\n    gl.shadowMap.type = PCFSoftShadowMap\n    //\n    return () => {}\n  }, [])\n\n  let handleLights = (floor) => {\n    let { gl } = get()\n\n    gl.physicallyCorrectLights = true\n\n    floor.traverse((it) => {\n      //\n      if (it?.userData?.castShadow) {\n        it.castShadow = true\n        it.traverse((sub) => {\n          sub.castShadow = true\n        })\n      }\n      //\n      if (it?.userData?.receiveShadow) {\n        it.receiveShadow = true\n        it.traverse((sub) => {\n          sub.receiveShadow = true\n        })\n      }\n    })\n\n    floor.traverse((it) => {\n      if (it instanceof PointLight && it.castShadow) {\n        it.shadow.mapSize.width = 512\n        it.shadow.mapSize.height = 512\n        it.shadow.camera.near = 0.5\n        it.shadow.camera.far = 500\n      }\n    })\n\n    return () => {\n      gl.physicallyCorrectLights = false\n    }\n  }\n\n  useEffect(() => {\n    //\n    const Now = (nowRef.current = makeNow())\n\n    let floor = SkeletonUtils.clone(object)\n    floor.traverse((it) => {\n      if (it) {\n        if (it.userData.startAt) {\n          it.getWorldPosition(Now.startAt)\n        }\n\n        if (it.userData.startLookAt) {\n          it.getWorldPosition(Now.startLookAt)\n        }\n\n        if (it.geometry) {\n          it.userData.isFloor = true\n          it.material.writeDepth = true\n        }\n      }\n    })\n\n    let cleanPhysical = handleLights(floor)\n    setFloor(floor)\n\n    const colliderManager = (colliderRef.current = new Collider({\n      floor,\n      scene: get().scene\n    }))\n\n    const mapPlayer = (mapPlayerRef.current = new MapPlayer({\n      collider: colliderManager.collider,\n      startAt: Now.startAt,\n      Now\n    }))\n\n    let changeTailColor = (color = '#ffffff') => {\n      window.dispatchEvent(\n        new window.CustomEvent('set-tail-color', { detail: color })\n      )\n    }\n\n    let lastScan = false\n    mini.onLoop(() => {\n      //\n      const { camera, scene } = get()\n      const hit = colliderManager.scanCenter({ camera, scene })\n\n      if (hit) {\n        Now.cursorPos.copy(hit.point)\n        Now.cursorNormal.copy(hit.face.normal)\n      }\n\n      // hit\n      if (hit) {\n        if (hit.object.userData.website || hit.object.userData.tooltip) {\n          changeTailColor(hit.object.userData.hoverColor || '#00ffff')\n        } else {\n          changeTailColor('#ffffff')\n        }\n      } else {\n        changeTailColor('#ffffff')\n      }\n\n      // lighup\n      if (hit) {\n        if (lastScan) {\n          lastScan.userData.enableBloom = false\n        }\n        if (hit.object.userData.website || hit.object.userData.tooltip) {\n          hit.object.userData.enableBloom = true\n          lastScan = hit.object\n        }\n      } else {\n        if (lastScan) {\n          lastScan.userData.enableBloom = false\n        }\n      }\n\n      if (hit) {\n        if (Now.hoverData !== hit.object.userData) {\n          Now.hoverData = hit.object.userData || null\n        }\n        if (Now.tooltip !== hit.object.userData?.tooltip) {\n          Now.tooltip = hit.object.userData.tooltip\n        }\n      } else {\n        if (Now.hoverData !== null) {\n          Now.hoverData = null\n        }\n        if (Now.tooltip !== '') {\n          Now.tooltip = ''\n        }\n      }\n\n      mapPlayer.onSimulate()\n    })\n\n    return () => {\n      cleanPhysical()\n      mini.clean()\n    }\n  }, [])\n\n  return (\n    <group>\n      {floor && <primitive object={floor}></primitive>}\n\n      {nowRef.current &&\n        typeof children === 'function' &&\n        children({ Now: nowRef.current })}\n    </group>\n  )\n}\n\n//\n\n//\n","import { useFrame, useThree } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { Camera, MathUtils, Vector3 } from 'three'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\nimport { applyAutoEvent, useAutoEvent } from '../utils/use-auto-event'\n// import { useMiniEngine } from '../utils/use-mini-engine'\n// import { CursorTrackerTail } from '../lib/CursorTrackerTail'\nimport { PerspectiveCamera } from '@react-three/drei'\n\nexport function UserContorls({\n  Now,\n  //\n  avatarSpeed = 2,\n  higherCamera = 1.5\n}) {\n  let { get, gl } = useThree()\n  let works = useRef({\n    //\n  })\n\n  useEffect(() => {\n    //\n    Now.avatarAt.copy(Now.startAt)\n    Now.goingTo.copy(Now.startAt)\n  })\n\n  useAutoEvent(\n    `touchstart`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useAutoEvent(\n    `touchmove`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useAutoEvent(\n    `touchend`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useEffect(() => {\n    let orig = Now.camMode\n    Now.camMode = 'first'\n    Now.avatarSpeed = avatarSpeed\n    return () => {\n      Now.avatarSpeed = 1\n      Now.camMode = orig\n    }\n  })\n  //\n  useAutoEvent('keydown', (ev) => {\n    // console.log(ev.key);\n\n    if (ev.key === 'w') {\n      Now.keyW = true\n    }\n    if (ev.key === 'a') {\n      Now.keyA = true\n    }\n    if (ev.key === 's') {\n      Now.keyS = true\n    }\n    if (ev.key === 'd') {\n      Now.keyD = true\n    }\n  })\n  useAutoEvent('keyup', (ev) => {\n    // console.log(ev.key);\n\n    if (ev.key === 'w') {\n      Now.keyW = false\n    }\n    if (ev.key === 'a') {\n      Now.keyA = false\n    }\n    if (ev.key === 's') {\n      Now.keyS = false\n    }\n    if (ev.key === 'd') {\n      Now.keyD = false\n    }\n  })\n\n  useEffect(() => {\n    let camera = get().camera\n    camera.near = 0.1\n    camera.far = 10000\n    camera.fov = 45\n    camera.updateProjectionMatrix()\n\n    let fakeCam = new Camera()\n    let orbit = new OrbitControls(fakeCam, gl.domElement)\n    orbit.enableRotate = true\n    orbit.enablePan = false\n    orbit.enableZoom = false\n    orbit.enableDamping = true\n    orbit.rotateSpeed = 0.5\n\n    fakeCam.position.copy(Now.startAt)\n    orbit.target.copy(Now.startLookAt)\n\n    let joystick = document.createElement('div')\n\n    document.body.appendChild(joystick)\n    joystick.style.cssText = `\n      position: absolute;\n      bottom: 30px;\n      left: 30px;\n      width: 80px;\n      height: 80px;\n      color: white;\n      user-select: none;\n      z-index: 20;\n    `\n\n    let note = document.createElement('div')\n    document.body.appendChild(note)\n    note.style.cssText = `\n      position: absolute;\n      bottom: 50px;\n      left: 50px;\n      width: 80px;\n      height: 80px;\n      color: white;\n      user-select: none;\n      z-index: 10;\n      text-align: center;\n      opacity: 0.4;\n    `\n    note.innerHTML = `Walk Around JoyStick`\n\n    let nipplejs = require('nipplejs')\n    var manager = nipplejs.create({\n      zone: joystick,\n      color: 'white',\n      mode: 'static',\n      position: { left: '60px', bottom: '60px' }\n    })\n\n    let forward = new Vector3(0, 0, 0)\n    let up = new Vector3(0, 1, 0)\n\n    let ttt = 0\n    let isUsing = false\n    let nippleAngle = 0\n\n    // window.addEventListener('touchstart', () => {\n    //   isDown = true\n    // })\n    // window.addEventListener('touchend', () => {\n    //   isDown = false\n    // })\n\n    manager.on('start move dir plain', function (evt, nipple) {\n      if (nipple?.angle?.radian) {\n        nippleAngle = nipple?.angle?.radian\n        orbit.enableRotate = false\n\n        isUsing = true\n        // Now.isDown = true;\n\n        clearTimeout(ttt)\n        ttt = setTimeout(() => {\n          isUsing = false\n        }, 100)\n      }\n    })\n\n    manager.on('end', () => {\n      nippleAngle = 0\n      works.current.endForward = () => {\n        forward.multiplyScalar(0.8)\n      }\n      // Now.isDown = false;\n      orbit.enableRotate = true\n      isUsing = false\n    })\n\n    let cte = applyAutoEvent(\n      gl.domElement.parentElement,\n      `touchend`,\n      (ev) => {\n        if (!isUsing) {\n          orbit.enableRotate = true\n        }\n      },\n      { passive: false }\n    )\n    let cts = applyAutoEvent(\n      gl.domElement.parentElement,\n      `touchstart`,\n      (ev) => {\n        if (!isUsing) {\n          orbit.enableRotate = true\n        }\n      },\n      { passive: false }\n    )\n\n    let keyBoardForward = new Vector3(0, 0, 1)\n    let scaler = 0.3\n\n    works.current.ctrl2 = () => {\n      if (isUsing) {\n        forward.set(0, 0, -1)\n        forward.applyAxisAngle(\n          up,\n          orbit.getAzimuthalAngle() + nippleAngle - Math.PI * 0.5 || 0.0\n        )\n      }\n      //\n      if (Now.keyW || Now.keyA || Now.keyS || Now.keyD) {\n        scaler = MathUtils.lerp(scaler, 0.3, 0.1)\n      } else {\n        scaler = MathUtils.lerp(scaler, 0.0, 0.1)\n      }\n\n      // controls.getDirection(dir);\n      if (Now.keyW) {\n        keyBoardForward.set(0, 0, -1 * scaler)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyA) {\n        keyBoardForward.set(-1 * scaler, 0, 0)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyS) {\n        keyBoardForward.set(0, 0, 1 * scaler)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyD) {\n        keyBoardForward.set(1 * scaler, 0, 0)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      }\n\n      Now.goingTo.copy(Now.avatarAt)\n      // if (!(Now.keyW || Now.keyA || Now.keyS || Now.keyD)) {\n      //   Now.avatarAt.copy(Now.avatarAt);\n      // }\n    }\n\n    // grid of raycaster\n\n    works.current.ctrl3 = () => {\n      let newType = 'floor'\n\n      // let upness = Now.cursorNormal.y || 0;\n      if (Now.cursorType !== newType) {\n        Now.cursorType = newType\n      }\n    }\n\n    works.current.ctrl = () => {\n      orbit.update()\n\n      Now.goingTo.add(forward)\n\n      camera.position.x = Now.avatarAt.x\n      camera.position.y = Now.avatarAt.y + higherCamera\n      camera.position.z = Now.avatarAt.z\n\n      camera.rotation.copy(fakeCam.rotation)\n    }\n\n    Now.enableFloorCursor = false\n    return () => {\n      Now.enableFloorCursor = true\n      manager.off('start move end dir plain')\n      manager.destroy()\n      document.body.removeChild(joystick)\n\n      joystick.remove()\n      note.remove()\n      cte()\n      cts()\n    }\n  }, [])\n\n  useFrame(() => {\n    Object.values(works.current).forEach((e) => e())\n  })\n  return (\n    <group>\n      {/*  */}\n      {/*  */}\n      <PerspectiveCamera\n        fov={45}\n        near={0.1}\n        far={10000}\n        position={[0, 20, 20]}\n        rotation-x={Math.PI * -0.25}\n        makeDefault\n      />\n    </group>\n  )\n}\n","import {\n  HalfFloatType,\n  Vector3,\n  BufferAttribute,\n  CylinderBufferGeometry,\n  InstancedBufferAttribute,\n  InstancedBufferGeometry,\n  Vector2,\n  RepeatWrapping,\n  ShaderMaterial,\n  Mesh,\n  // DataTexture,\n  // DataUtils,\n  // RGBFormat,\n  // AdditiveBlending,\n  Object3D,\n  Color,\n  SphereBufferGeometry,\n  MeshBasicMaterial,\n  AdditiveBlending,\n  MeshLambertMaterial\n} from 'three'\n// import { GPUComputationRenderer } from 'three-stdlib'\nimport { Geometry } from 'three/examples/jsm/deprecated/Geometry.js'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer'\n\nclass LokLokWiggleSimulation {\n  constructor({ node, numberOfScans = 10, trailSize = 32 }) {\n    this.node = node\n    this.WIDTH = trailSize\n    this.HEIGHT = numberOfScans // number of trackers\n    this.COUNT = this.WIDTH * this.HEIGHT\n    this.v3v000 = new Vector3(0, 0, 0)\n    this.wait = this.setup({ node })\n  }\n\n  async setup({ node }) {\n    let renderer = await node.ready.gl\n\n    let gpu = (this.gpu = new GPUComputationRenderer(\n      this.WIDTH,\n      this.HEIGHT,\n      renderer\n    ))\n\n    gpu.setDataType(HalfFloatType)\n\n    const dtPosition = this.gpu.createTexture()\n    const lookUpTexture = this.gpu.createTexture()\n    this.fillPositionTexture(dtPosition)\n    this.fillLookupTexture(lookUpTexture)\n\n    this.positionVariable = this.gpu.addVariable(\n      'texturePosition',\n      this.positionShader(),\n      dtPosition\n    )\n    this.gpu.setVariableDependencies(this.positionVariable, [\n      this.positionVariable\n    ])\n\n    this.positionUniforms = this.positionVariable.material.uniforms\n    this.positionUniforms.lookup = { value: lookUpTexture }\n\n    let h = this.HEIGHT\n    for (let ii = 0; ii < h; ii++) {\n      this.positionUniforms['mouse' + ii] = { value: new Vector3(0, 0, 0) }\n    }\n\n    this.positionUniforms.time = { value: 0 }\n    dtPosition.wrapS = RepeatWrapping\n    dtPosition.wrapT = RepeatWrapping\n\n    //\n    const error = this.gpu.init()\n    if (error !== null) {\n      console.error(error)\n    }\n  }\n\n  positionShader() {\n    let lookupRightLine = () => {\n      let str = `if (false) {}`\n      let h = this.HEIGHT\n      for (let ii = 0; ii < h; ii++) {\n        str += `\n          else if (currentLine == ${ii.toFixed(0)}.0) {\n            gl_FragColor = vec4(mouse${ii.toFixed(0)}, 1.0);\n          }\n        `\n      }\n      return str\n    }\n\n    let mouseUniforms = () => {\n      let str = ``\n      let h = this.HEIGHT\n      for (let ii = 0; ii < h; ii++) {\n        str += `\n          uniform vec3 mouse${ii.toFixed(0)};\n        `\n      }\n\n      return str\n    }\n    return /* glsl */ `\n      ${mouseUniforms()}\n\n      uniform sampler2D lookup;\n      uniform float time;\n\n\t\t\tvoid main()\t{\n        // const float width = resolution.x;\n        // const float height = resolution.y;\n        // float xID = floor(gl_FragCoord.x);\n        // float yID = floor(gl_FragCoord.y);\n\n        vec2 uvCursor = vec2(gl_FragCoord.x, gl_FragCoord.y) / resolution.xy;\n        // vec4 positionHead = texture2D( texturePosition, uvCursor );\n\n        vec4 lookupData = texture2D(lookup, uvCursor);\n        vec2 nextUV = lookupData.xy;\n        float currentIDX = floor(gl_FragCoord.x);\n        float currentLine = floor(gl_FragCoord.y);\n\n        if (floor(currentIDX) == 0.0) {\n          ${lookupRightLine()}\n        } else {\n          vec3 positionChain = texture2D( texturePosition,nextUV ).xyz;\n          gl_FragColor = vec4(positionChain, 1.0);\n        }\n\n\n\t\t\t}\n    `\n  }\n\n  fillPositionTexture(texture) {\n    let i = 0\n    const theArray = texture.image.data\n\n    for (let y = 0; y < this.HEIGHT; y++) {\n      for (let x = 0; x < this.WIDTH; x++) {\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n      }\n    }\n    texture.needsUpdate = true\n  }\n\n  fillLookupTexture(texture) {\n    let i = 0\n    const theArray = texture.image.data\n    let items = []\n\n    for (let y = 0; y < this.HEIGHT; y++) {\n      for (let x = 0; x < this.WIDTH; x++) {\n        let lastOneInArray = items[items.length - 1] || [0, 0]\n        theArray[i++] = lastOneInArray[0]\n        theArray[i++] = lastOneInArray[1]\n        theArray[i++] = this.WIDTH\n        theArray[i++] = this.HEIGHT\n        items.push([x / this.WIDTH, y / this.HEIGHT])\n      }\n    }\n    texture.needsUpdate = true\n  }\n\n  render({ trackers }) {\n    this.positionUniforms.time.value = window.performance.now() / 1000\n\n    trackers.forEach((track, idx) => {\n      let uniform = this.positionUniforms['mouse' + idx]\n      if (uniform && uniform.value) {\n        uniform.value.copy(track)\n        // console.log(idx, track.toArray().join(\"-\"));\n      }\n    })\n\n    this.gpu.compute()\n  }\n\n  getTextureAfterCompute() {\n    return {\n      posTexture: this.gpu.getCurrentRenderTarget(this.positionVariable).texture\n    }\n  }\n}\n\nclass LokLokWiggleDisplay {\n  constructor({ node, sim, mounter, color }) {\n    this.mounter = mounter\n    this.node = node\n    this.sim = sim\n    this.color = color\n    this.wait = this.setup({ node })\n  }\n\n  async setup({ node }) {\n    let mounter = this.mounter\n\n    // let camera = await node.ready.camera;\n    // let renderer = await node.ready.gl;\n\n    let { geometry, subdivisions, count } = new NoodleGeo({\n      count: this.sim.HEIGHT,\n      numSides: 4,\n      subdivisions: this.sim.WIDTH * 2,\n      openEnded: false\n    })\n\n    geometry.instanceCount = count\n\n    let getPointAtByT = ({\n      controlPointsResolution = 20,\n      lineIdx = 0,\n      lineCount = this.sim.HEIGHT,\n      textureName = 'CONTROL_POINTS'\n    }) => {\n      controlPointsResolution = Math.floor(controlPointsResolution)\n\n      let floatval = `${Number(controlPointsResolution).toFixed(1)}`\n\n      let res = `\n      vec3 pointIDX_${textureName}_${lineIdx.toFixed(0)} (float index) {\n        vec3 result = vec3(0.0);\n\n        vec4 color = texture2D(${textureName},\n          vec2(\n            index / ${controlPointsResolution.toFixed(1)},\n            ${lineIdx.toFixed(1)} / ${lineCount.toFixed(1)}\n          )\n        );\n\n        result = color.rgb;\n\n        return result;\n      }\n\n      vec3 catmullRom_${textureName}_${lineIdx} (vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n          vec3 v0 = (p2 - p0) * 0.5;\n          vec3 v1 = (p3 - p1) * 0.5;\n          float t2 = t * t;\n          float t3 = t * t * t;\n\n          return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n      }\n\n      vec3 getPointAt_${lineIdx.toFixed(0)} (float t) {\n        bool closed = false;\n        float ll = ${floatval};\n        float minusOne = 1.0;\n        if (closed) {\n          minusOne = 0.0;\n        }\n\n        float p = (ll - minusOne) * t;\n        float intPoint = floor(p);\n        float weight = p - intPoint;\n\n        float idx0 = intPoint + -1.0;\n        float idx1 = intPoint +  0.0;\n        float idx2 = intPoint +  1.0;\n        float idx3 = intPoint +  2.0;\n\n        vec3 pt0 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx0);\n        vec3 pt1 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx1);\n        vec3 pt2 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx2);\n        vec3 pt3 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx3);\n\n        vec3 pointoutput = catmullRom_${textureName}_${lineIdx}(pt0, pt1, pt2, pt3, weight);\n\n        return pointoutput;\n      }\n      `\n\n      // console.log(res);\n      return res\n    }\n\n    let getLinesPointAtT = () => {\n      let str = `\n          if (false) {}`\n      for (let i = 0; i < this.sim.HEIGHT; i++) {\n        str += `\n          else if (lineIDXER == ${i.toFixed(1)}) {\n            pt += getPointAt_${i.toFixed(0)}(t);\n          }\n        `\n      }\n      // console.log(str);\n\n      return str\n    }\n\n    let pointLineMaker = () => {\n      let str = ''\n      for (let i = 0; i < this.sim.HEIGHT; i++) {\n        str +=\n          getPointAtByT({\n            lineIdx: i,\n            lineCount: this.sim.HEIGHT,\n            controlPointsResolution: subdivisions,\n            textureName: 'posTexture'\n          }) + '\\n'\n      }\n      return str\n    }\n\n    let latestColor = new Color().copy(this.color)\n    window.addEventListener('set-tail-color', ({ detail: color }) => {\n      latestColor.set(color)\n    })\n\n    this.node.onLoop(() => {\n      this.color.lerp(latestColor, 0.03)\n    })\n\n    let matLine0 = new ShaderMaterial({\n      uniforms: {\n        tailColor: { value: this.color },\n        time: { value: 0 },\n        matcap: {\n          value: null\n          // value: new TextureLoader().load(\"/matcap/golden2.png\"),\n          // value: await node.ready.RainbowTexture,\n        },\n        posTexture: { value: null }\n        // handTexture: { value: null },\n      },\n      vertexShader: /* glsl */ `\n        // #include <common>\n        #define lengthSegments ${subdivisions.toFixed(1)}\n\n        attribute float angle;\n        attribute float newPosition;\n        attribute float tubeInfo;\n\n        // varying vec2 vUv;\n        varying vec3 vNormal;\n        attribute vec4 offset;\n\n        uniform sampler2D posTexture;\n        // uniform sampler2D handTexture;\n\n        uniform float time;\n\n        mat4 rotationX( in float angle ) {\n          return mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n                  0, \tcos(angle),\t-sin(angle),\t\t0,\n                  0, \tsin(angle),\t cos(angle),\t\t0,\n                  0, \t\t\t0,\t\t\t  0, \t\t1);\n        }\n\n        mat4 rotationY( in float angle ) {\n          return mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n                      0,\t\t1.0,\t\t\t 0,\t0,\n                  -sin(angle),\t0,\t\tcos(angle),\t0,\n                      0, \t\t0,\t\t\t\t0,\t1);\n        }\n\n        mat4 rotationZ( in float angle ) {\n          return mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n                  sin(angle),\t\tcos(angle),\t\t0,\t0,\n                      0,\t\t\t\t0,\t\t1,\t0,\n                      0,\t\t\t\t0,\t\t0,\t1);\n        }\n\n        mat4 rotationMatrix (vec3 axis, float angle) {\n            axis = normalize(axis);\n            float s = sin(angle);\n            float c = cos(angle);\n            float oc = 1.0 - c;\n\n            return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                        0.0,                                0.0,                                0.0,                                1.0);\n        }\n\n        ${pointLineMaker()}\n\n        vec3 sampleFnc (float t) {\n          vec3 pt = (offset.xyz + 0.5) * 0.0;\n\n          // pt = vec4(vec4(pt, 1.0) * rotationY(t * 0.1 + time * 0.1)).xyz;\n          // if (lineIDXER == 0.0) {\n          //   pt += getPointAt_0(t);\n          // }\n\n          float lineIDXER = offset.w;\n          // pt += getPointAt_0(t);\n\n          ${getLinesPointAtT()}\n\n          // pt = getPointAt_2(t);\n\n          return pt;\n        }\n\n        void createTube (float t, vec2 volume, out vec3 pos, out vec3 normal) {\n          // find next sample along curve\n          float nextT = t + (1.0 / lengthSegments);\n\n          // sample the curve in two places\n          vec3 cur = sampleFnc(t);\n          vec3 next = sampleFnc(nextT);\n\n          // compute the Frenet-Serret frame\n          vec3 T = normalize(next - cur);\n          vec3 B = normalize(cross(T, next + cur));\n          vec3 N = -normalize(cross(B, T));\n\n          // extrude outward to create a tube\n          float tubeAngle = angle;\n          float circX = cos(tubeAngle);\n          float circY = sin(tubeAngle);\n\n          // compute position and normal\n          normal.xyz = normalize(B * circX + N * circY);\n          pos.xyz = cur + B * volume.x * circX + N * volume.y * circY;\n        }\n\n        varying float vT;\n        varying vec3 vViewPosition;\n\n        void main (void) {\n          vec3 transformed;\n          vec3 objectNormal;\n\n          float t = tubeInfo + 0.5;\n\n          vT = t;\n\n          vec2 volume = vec2(0.0333, 0.0333) * (1.0 - t) * 2.0;\n          createTube(t, volume, transformed, objectNormal);\n\n          vec3 transformedNormal = normalMatrix * objectNormal;\n          vNormal = normalize(transformedNormal);\n\n          // vUv = uv.yx;\n\n          vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n          vViewPosition = -mvPosition.xyz;\n        }\n      `,\n      fragmentShader: /* glsl */ `\n        varying float vT;\n        // varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vViewPosition;\n        // uniform sampler2D matcap;\n        uniform vec3 tailColor;\n        void main (void) {\n\n          // vec3 viewDir = normalize( vViewPosition );\n          // vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n          // vec3 y = cross( viewDir, x );\n          // vec2 uv = vec2( dot( x, vNormal ), dot( y, vNormal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n          // vec4 matcapColor = texture2D( matcap, uv );\n\n          vec4 color = vec4((vNormal * vViewPosition), 1.0);\n          gl_FragColor = vec4(tailColor, (1.0 - vT));\n        }\n      `,\n      transparent: true,\n      // blending: AdditiveBlending,\n      depthTest: false\n    })\n\n    let line0 = new Mesh(geometry, matLine0)\n    line0.frustumCulled = false\n    line0.userData.enableBloom = true\n\n    mounter.add(line0)\n    node.onClean(() => {\n      mounter.remove(line0)\n    })\n\n    this.sim.wait.then(() => {\n      node.onLoop(() => {\n        let result = this.sim.getTextureAfterCompute()\n        matLine0.uniforms.posTexture.value = result.posTexture\n        matLine0.uniforms.time.value = window.performance.now() / 1000\n      })\n    })\n  }\n\n  // async enableMousePlane() {\n  //   let raycaster = await node.ready.raycaster;\n  //   let mouse = await node.ready.mouse;\n  //   let camera = await node.ready.camera;\n  //   let viewport = await node.ready.viewport;\n\n  //   let geoPlane = new PlaneBufferGeometry(\n  //     2.0 * viewport.width,\n  //     2.0 * viewport.height,\n  //     2,\n  //     2\n  //   );\n\n  //   let matPlane = new MeshBasicMaterial({\n  //     transparent: true,\n  //     opacity: 0.25,\n  //     color: 0xff0000,\n  //   });\n\n  //   let planeMesh = new Mesh(geoPlane, matPlane);\n  //   planeMesh.position.z = -camera.position.z / 2;\n\n  //   scene.add(planeMesh);\n  //   node.onClean(() => {\n  //     scene.remove(planeMesh);\n  //   });\n\n  //   let temppos = new Vector3();\n  //   node.onLoop(() => {\n  //     planeMesh.lookAt(camera.position);\n  //     raycaster.setFromCamera(mouse, camera);\n  //     let res = raycaster.intersectObject(planeMesh);\n  //     if (res && res[0]) {\n  //       temppos.copy(res[0].point);\n  //     }\n  //   });\n  // }\n\n  // enableHandTexture() {\n  //   const width = this.sim.WIDTH\n  //   const height = this.sim.HEIGHT\n  //   const size = width * height\n\n  //   let handMovement = []\n  //   let temppos = new Vector3()\n  //   for (let i = 0; i < size; i++) {\n  //     AvatarHead.getWorldPosition(temppos)\n\n  //     let x = temppos.x || 0\n  //     let y = temppos.y || 0\n  //     let z = temppos.z || 0\n  //     //\n  //     handMovement.unshift(x, y, z)\n  //   }\n\n  //   const textureArray = new Uint16Array(3 * size)\n  //   const handTexture = new DataTexture(\n  //     textureArray,\n  //     width,\n  //     height,\n  //     RGBFormat,\n  //     HalfFloatType\n  //   )\n  //   handTexture.needsUpdate = true\n\n  //   node.onLoop(() => {\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.x) || 0)\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.y) || 0)\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.z) || 0)\n\n  //     handMovement.shift()\n  //     handMovement.shift()\n  //     handMovement.shift()\n\n  //     textureArray.set(handMovement, 0)\n  //     handTexture.needsUpdate = true\n  //     mat.uniforms.handTexture.value = handTexture\n  //   })\n  // }\n}\n\nclass NoodleGeo {\n  constructor(props) {\n    let {\n      count = 20,\n      numSides = 4,\n      subdivisions = 50,\n      openEnded = true\n    } = props\n    const radius = 1\n    const length = 1\n\n    const cylinderBufferGeo = new CylinderBufferGeometry(\n      radius,\n      radius,\n      length,\n      numSides,\n      subdivisions,\n      openEnded\n    )\n\n    let baseGeometry = new Geometry()\n    baseGeometry = baseGeometry.fromBufferGeometry(cylinderBufferGeo)\n\n    baseGeometry.rotateZ(Math.PI / 2)\n\n    // compute the radial angle for each position for later extrusion\n    const tmpVec = new Vector2()\n    const xPositions = []\n    const angles = []\n    const uvs = []\n    const vertices = baseGeometry.vertices\n    const faceVertexUvs = baseGeometry.faceVertexUvs[0]\n    const oPositions = []\n\n    // Now go through each face and un-index the geometry.\n    baseGeometry.faces.forEach((face, i) => {\n      const { a, b, c } = face\n      const v0 = vertices[a]\n      const v1 = vertices[b]\n      const v2 = vertices[c]\n      const verts = [v0, v1, v2]\n      const faceUvs = faceVertexUvs[i]\n\n      // For each vertex in this face...\n      verts.forEach((v, j) => {\n        tmpVec.set(v.y, v.z).normalize()\n\n        // the radial angle around the tube\n        const angle = Math.atan2(tmpVec.y, tmpVec.x)\n        angles.push(angle)\n\n        // \"arc length\" in range [-0.5 .. 0.5]\n        xPositions.push(v.x)\n        oPositions.push(v.x, v.y, v.z)\n\n        // copy over the UV for this vertex\n        uvs.push(faceUvs[j].toArray())\n      })\n    })\n\n    // build typed arrays for our attributes\n    const posArray = new Float32Array(xPositions)\n    const angleArray = new Float32Array(angles)\n    const uvArray = new Float32Array(uvs.length * 2)\n\n    const origPosArray = new Float32Array(oPositions)\n\n    // unroll UVs\n    for (let i = 0; i < posArray.length; i++) {\n      const [u, v] = uvs[i]\n      uvArray[i * 2 + 0] = u\n      uvArray[i * 2 + 1] = v\n    }\n\n    const lineGeo = new InstancedBufferGeometry()\n    lineGeo.instanceCount = count\n\n    lineGeo.setAttribute('position', new BufferAttribute(origPosArray, 3))\n    lineGeo.setAttribute('tubeInfo', new BufferAttribute(posArray, 1))\n    lineGeo.setAttribute('angle', new BufferAttribute(angleArray, 1))\n    lineGeo.setAttribute('uv', new BufferAttribute(uvArray, 2))\n\n    let offset = []\n    let ddxyz = Math.floor(Math.pow(count, 1 / 3))\n    let iii = 0\n    for (let z = 0; z < ddxyz; z++) {\n      for (let y = 0; y < ddxyz; y++) {\n        for (let x = 0; x < ddxyz; x++) {\n          offset.push(\n            0.0, //  * (x / ddxyz) * 2.0 - 1.0,\n            0.0, //  * (y / ddxyz) * 2.0 - 1.0,\n            0.0, //  * (z / ddxyz) * 2.0 - 1.0,\n            iii\n          )\n          iii++\n        }\n      }\n    }\n\n    // let ddxyz = Math.floor(Math.pow(count, 1 / 2));\n    // for (let y = 0; y < ddxyz; y++) {\n    //   for (let x = 0; x < ddxyz; x++) {\n    //     offset.push(0.0, (x / ddxyz) * 2.0 - 1.0, (y / ddxyz) * 2.0 - 1.0);\n    //   }\n    // }\n\n    lineGeo.setAttribute(\n      'offset',\n      new InstancedBufferAttribute(new Float32Array(offset), 4)\n    )\n\n    let eachLineIdx = []\n    for (let c = 0; c < count; c++) {\n      eachLineIdx.push(c)\n    }\n\n    // lineGeo.setAttribute(\n    //   \"lineIDXER\",\n    //   new InstancedBufferAttribute(new Float32Array(eachLineIdx), 1)\n    // );\n\n    return {\n      ...props,\n      dataLength: posArray.length,\n      geometry: lineGeo\n    }\n  }\n}\n\nexport class CursorTrackerTail {\n  constructor({ mini, mounter, cursor, color = new Color('#ffffff') }) {\n    let node = mini\n    let SCAN_COUNT = 8\n    let TAIL_LENGTH = 64\n\n    //\n    let sim = new LokLokWiggleSimulation({\n      node,\n      mounter,\n      numberOfScans: SCAN_COUNT,\n      trailSize: TAIL_LENGTH\n    })\n\n    let display = new LokLokWiggleDisplay({ node, sim, mounter, color })\n    this.display = display\n\n    let trackers = []\n\n    let makeTracker = ({ update, setup }) => {\n      let looker = new Object3D()\n      cursor.add(looker)\n      mini.onClean(() => {\n        cursor.remove(looker)\n      })\n\n      let origin = new Object3D()\n      looker.add(origin)\n      let orbit = new Object3D()\n      origin.add(orbit)\n      let worldPos = new Vector3()\n      let lerpWorldPos = new Vector3()\n\n      setup({ origin, orbit })\n\n      node.onLoop(() => {\n        update({ origin, orbit })\n\n        if (mini.now?.camera) {\n          looker.lookAt(mini.now.camera.position)\n        }\n        orbit.getWorldPosition(worldPos)\n\n        lerpWorldPos.lerp(worldPos, 0.3)\n      })\n\n      trackers.push(lerpWorldPos)\n    }\n\n    let count = 3\n    for (let i = 0; i < count; i++) {\n      makeTracker({\n        setup: ({ origin, orbit }) => {\n          origin.rotation.z += ((Math.PI * 2.0) / count) * i\n        },\n        update: ({ origin, orbit }) => {\n          origin.rotation.z += 0.1\n          orbit.position.x =\n            0.85 + 0.85 * Math.sin((window.performance.now() / 1000) * 1)\n        }\n      })\n    }\n\n    // let makeCross = () => {\n    //   let looker = new Object3D();\n    //   cursor.add(looker);\n    //   mini.onClean(() => {\n    //     cursor.remove(looker);\n    //   });\n\n    //   let cross1 = new Mesh(\n    //     new BoxBufferGeometry(0.02, 1, 0.02),\n    //     new MeshBasicMaterial({ depthTest: false, color: 0xffffff })\n    //   );\n    //   looker.add(cross1);\n\n    //   let cross2 = new Mesh(\n    //     new BoxBufferGeometry(1, 0.02, 0.02),\n    //     new MeshBasicMaterial({ depthTest: false, color: 0xffffff })\n    //   );\n    //   looker.add(cross2);\n\n    //   cross1.userData.enableBloom = true;\n    //   cross2.userData.enableBloom = true;\n\n    //   looker.scale.setScalar(2.0);\n\n    //   node.onLoop(() => {\n    //     if (mini.now?.camera) {\n    //       looker.lookAt(mini.now.camera.position);\n    //     }\n\n    //     let ss = 2 * Math.sin(Math.PI - window.performance.now() / 1000);\n    //     cross1.scale.setScalar(ss);\n    //     cross2.scale.setScalar(ss);\n    //   });\n    // };\n    // makeCross();\n\n    sim.wait.then(() => {\n      node.onLoop(() => {\n        sim.render({\n          trackers\n        })\n      })\n    })\n  }\n}\n","import { useFrame } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { CursorTrackerTail } from '../lib/CursorTrackerTail'\nimport { Color } from 'three'\n\nexport function TailCursor({ Now, color }) {\n  let { mini } = useMiniEngine()\n  let cursor = useRef()\n\n  let colorObj = useRef(new Color(color))\n\n  useEffect(() => {\n    colorObj.current.set(color)\n  }, [color])\n\n  useEffect(() => {\n    let mouse = cursor.current\n    if (mouse) {\n      mini.ready.scene.then((scene) => {\n        return new CursorTrackerTail({\n          mini,\n          cursor: mouse,\n          mounter: scene,\n          color: colorObj.current\n        })\n      })\n    }\n  }, [])\n\n  // let time = 0\n  useFrame((st, dt) => {\n    // time += dt\n    if (cursor.current) {\n      let mouse = cursor.current\n\n      mouse.position.lerp(Now.cursorPos, 0.2)\n\n      // mouse.scale.setScalar(0.15);\n\n      // mouse.lookAt(\n      //   Now.cursorPos.x + Now.cursorNormal.x,\n      //   Now.cursorPos.y + Now.cursorNormal.y,\n      //   Now.cursorPos.z + Now.cursorNormal.z\n      // );\n\n      mouse.lookAt(st.camera.position)\n    }\n  })\n\n  return <group ref={cursor}>{/*  */}</group>\n}\n","import { useEffect, useRef } from 'react'\n\nimport { useFrame } from '@react-three/fiber'\nimport {\n  Color,\n  Layers,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  MeshMatcapMaterial,\n  MeshPhongMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MeshToonMaterial,\n  ShaderMaterial,\n  sRGBEncoding,\n  Vector2,\n  WebGLRenderTarget\n} from 'three'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass'\n\nexport const ENTIRE_SCENE = 0\nexport const BLOOM_SCENE = 1\nexport const DARK_SCENE = 2\n\nexport const enableBloom = (item) => {\n  item.layers.enable(BLOOM_SCENE)\n}\n\nexport const enableDarken = (item) => {\n  item.layers.enable(DARK_SCENE)\n}\n\nexport class BloomLayer {\n  constructor({ mini }) {\n    let { get } = mini.now\n\n    let reducedRes = 0.75\n    let resBloom = new Vector2()\n    resBloom.copy({\n      x: get().gl.domElement.width,\n      y: get().gl.domElement.height\n    })\n    resBloom.multiplyScalar(reducedRes)\n\n    let EffectComposer =\n      require('three/examples/jsm/postprocessing/EffectComposer').EffectComposer\n    let RenderPass =\n      require('three/examples/jsm/postprocessing/RenderPass').RenderPass\n    let UnrealBloomPass =\n      require('three/examples/jsm/postprocessing/UnrealBloomPass').UnrealBloomPass\n\n    let efComposer = new EffectComposer(get().gl)\n    mini.onResize(() => {\n      efComposer.setPixelRatio(get().gl.getPixelRatio() * reducedRes)\n    })\n\n    let renderPass = new RenderPass(get().scene, get().camera)\n    mini.onResize(() => {\n      resBloom.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n      resBloom.multiplyScalar(reducedRes)\n      renderPass.setSize(resBloom.x, resBloom.y)\n    })\n    efComposer.addPass(renderPass)\n\n    let unrealPass = new UnrealBloomPass(resBloom, 1.5, 1, 0.1)\n    mini.onResize(() => {\n      resBloom.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n      resBloom.multiplyScalar(reducedRes)\n      unrealPass.setSize(resBloom.x, resBloom.y)\n    })\n\n    efComposer.addPass(unrealPass)\n    efComposer.renderToScreen = false\n\n    let dark = new Color('#000000')\n    // let darkMat = new MeshBasicMaterial({ color: 0x000000, skinning: true })\n    let baseLayer = new Layers()\n    baseLayer.disableAll()\n    baseLayer.enable(ENTIRE_SCENE)\n\n    let bloomLayer = new Layers()\n    bloomLayer.disableAll()\n    bloomLayer.enable(BLOOM_SCENE)\n    let darkLayer = new Layers()\n    darkLayer.disableAll()\n    darkLayer.enable(DARK_SCENE)\n\n    let onBeforeCompileForStdMat = (globalDarkening) => (shader) => {\n      shader.uniforms.globalDarkening = globalDarkening\n      let atBegin = `\n        uniform bool globalDarkening;\n\n      `\n      let atEnd = `\n        if (globalDarkening) {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n      `\n\n      shader.fragmentShader = `${atBegin.trim()}\\n${shader.fragmentShader}`\n      shader.fragmentShader = shader.fragmentShader.replace(\n        `#include <dithering_fragment>`,\n        `#include <dithering_fragment>\\n${atEnd.trim()}`\n      )\n    }\n\n    let uniqueMaterialMap = new Map()\n    let setup = () => {\n      let { scene } = get()\n      scene.traverse((it) => {\n        if (\n          it.material &&\n          (it.material instanceof MeshStandardMaterial ||\n            it.material instanceof MeshPhongMaterial ||\n            it.material instanceof MeshBasicMaterial ||\n            it.material instanceof MeshLambertMaterial ||\n            it.material instanceof MeshMatcapMaterial ||\n            it.material instanceof MeshPhysicalMaterial ||\n            it.material instanceof MeshToonMaterial)\n        ) {\n          if (!uniqueMaterialMap.has(it.uuid + it.material.uuid)) {\n            if (it.material?.clone) {\n              it.material = it.material.clone()\n              uniqueMaterialMap.set(it.uuid + it.material.uuid, true)\n            }\n          }\n        }\n      })\n    }\n\n    let enableDarkenMap = new Map()\n\n    let darken = (it) => {\n      // if (!it.text) {\n      //   it.material = darkMat\n      //   darkMat.needsUpdate = true\n      // }\n      // darkMat.needsUpdate = true;\n\n      if (!enableDarkenMap.has(it.uuid)) {\n        if (\n          it.material &&\n          (it.material instanceof MeshStandardMaterial ||\n            it.material instanceof MeshPhongMaterial ||\n            it.material instanceof MeshBasicMaterial ||\n            it.material instanceof MeshLambertMaterial ||\n            it.material instanceof MeshMatcapMaterial ||\n            it.material instanceof MeshPhysicalMaterial ||\n            it.material instanceof MeshToonMaterial)\n        ) {\n          let str = it.material.onBeforeCompile.toString()\n          if (str !== onBeforeCompileForStdMat.toString()) {\n            let globalDarkening = { value: false }\n            it.userData.globalDarkening = globalDarkening\n\n            enableDarkenMap.set(it.uuid, globalDarkening)\n\n            it.material.onBeforeCompile =\n              onBeforeCompileForStdMat(globalDarkening)\n            it.material.needsUpdate = true\n          }\n        }\n      }\n\n      if (enableDarkenMap.has(it.uuid)) {\n        enableDarkenMap.get(it.uuid).value = true\n      }\n    }\n\n    let setBloomSceneMat = () => {\n      let { scene } = get()\n      scene.traverse((it) => {\n        if (it?.userData?.discard) {\n          it.visible = false\n        }\n\n        if (it?.userData?.disableBloom) {\n          it.visible = false\n        }\n\n        if (it.material) {\n          if (it?.userData?.enableDarken) {\n            darken(it)\n          } else if (it?.userData?.enableBloom) {\n          } else if (darkLayer.test(it.layers) || !bloomLayer.test(it.layers)) {\n            darken(it)\n          } else {\n          }\n        }\n      })\n    }\n\n    let renderToTexture = () => {\n      let { scene, clock } = get()\n      let dt = clock.getDelta()\n      let origBG = scene.background\n      scene.background = dark\n      efComposer.render(dt)\n      scene.background = origBG\n    }\n\n    let restore = () => {\n      let { scene } = get()\n\n      scene.traverse((it) => {\n        if (enableDarkenMap.has(it.uuid)) {\n          enableDarkenMap.get(it.uuid).value = false\n        }\n\n        if (it?.userData?.discard) {\n          it.visible = true\n        }\n        if (it?.userData?.disableBloom) {\n          it.visible = true\n        }\n      })\n    }\n\n    this.renderTexture = () => {\n      let { gl } = get()\n      gl.shadowMap.enabled = false\n\n      // bloom with occulsion image\n      setup()\n      setBloomSceneMat()\n      renderToTexture()\n      restore()\n\n      gl.shadowMap.enabled = true\n    }\n    this.getTex = () => {\n      return efComposer.readBuffer.texture\n    }\n  }\n}\n\nexport class BaseLayer {\n  constructor({ mini }) {\n    let { size, gl, get } = mini.now\n\n    let resBase = new Vector2()\n\n    resBase.copy({ x: size.width, y: size.height })\n    resBase.multiplyScalar(gl.getPixelRatio())\n\n    this.rtt = new WebGLRenderTarget(resBase.width, resBase.height, {\n      encoding: sRGBEncoding,\n      generateMipmaps: false\n    })\n    mini.onClean(() => {\n      this.rtt.dispose()\n    })\n    mini.onResize(() => {\n      resBase.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n\n      resBase.multiplyScalar(gl.getPixelRatio())\n\n      this.rtt = new WebGLRenderTarget(resBase.width, resBase.height, {\n        encoding: sRGBEncoding,\n        generateMipmaps: false\n      })\n    })\n\n    this.renderTexture = () => {\n      let { gl, camera, scene } = get()\n\n      // base image\n      let orig = gl.getRenderTarget()\n      gl.setRenderTarget(this.rtt)\n      gl.render(scene, camera)\n      gl.setRenderTarget(orig)\n    }\n\n    this.getTex = () => {\n      return this.rtt.texture\n    }\n  }\n}\n\nexport class Compositor {\n  constructor({ mini }) {\n    //\n    let quadMat = new ShaderMaterial({\n      //\n      uniforms: {\n        bloomDiffuse: { value: null },\n        baseDiffuse: { value: null }\n      },\n\n      //\n      vertexShader: `\n        varying vec2 vUv;\n        void main (void) {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vUv = uv;\n        }\n      `,\n\n      fragmentShader: `\n        uniform sampler2D baseDiffuse;\n        uniform sampler2D bloomDiffuse;\n\n        varying vec2 vUv;\n          void main (void) {\n            vec4 baseDiffuseColor = texture2D(baseDiffuse, vUv);\n            vec4 bloomDiffuseColor = texture2D(bloomDiffuse, vUv);\n\n            gl_FragColor = vec4(baseDiffuseColor.rgb * 1.0,  baseDiffuseColor.a);\n\n            gl_FragColor.r += 0.45 * pow(bloomDiffuseColor.r, 0.75);\n            gl_FragColor.g += 0.45 * pow(bloomDiffuseColor.g, 0.75);\n            gl_FragColor.b += 0.45 * pow(bloomDiffuseColor.b, 0.75);\n          }\n        `\n    })\n\n    let fsQuad = new FullScreenQuad(quadMat)\n\n    this.render = ({ baseTex, bloomTex }) => {\n      let { gl } = mini.now\n      if (gl) {\n        quadMat.uniforms.bloomDiffuse.value = bloomTex\n        quadMat.uniforms.baseDiffuse.value = baseTex\n        fsQuad.render(gl)\n      }\n    }\n  }\n}\n\nexport function SimpleBloomer() {\n  let { mini } = useMiniEngine()\n\n  let looer = useRef(() => {})\n\n  useEffect(() => {\n    mini.ready.get.then(() => {\n      //\n      let base = new BaseLayer({ mini })\n      let bloom = new BloomLayer({ mini })\n      let compositor = new Compositor({ mini })\n\n      //\n      looer.current = () => {\n        base.renderTexture()\n        bloom.renderTexture()\n\n        compositor.render({\n          baseTex: base.getTex(),\n          bloomTex: bloom.getTex()\n        })\n      }\n    })\n  }, [])\n\n  // invalidate orignal loop\n  useFrame(() => {\n    looer.current()\n  }, 1000)\n\n  return null\n}\n","import { Sphere } from '@react-three/drei'\nimport { useFrame } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { DoubleSide } from 'three'\n\nexport function StarSky() {\n  let shaders = {\n    vertexShader: /* glsl */ `\n    varying vec3 vPos;\n    varying vec3 vUv3;\n\n    void main() {\n      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n      gl_Position = projectionMatrix * mvPosition;\n      vPos = position;\n      vUv3 = uv.xyx;\n    }\n    `,\n    fragmentShader: `\n      precision highp float;\n\n      vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n      vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n      float cnoise(vec3 P){\n        vec3 Pi0 = floor(P); // Integer part for indexing\n        vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n        Pi0 = mod(Pi0, 289.0);\n        Pi1 = mod(Pi1, 289.0);\n        vec3 Pf0 = fract(P); // Fractional part for interpolation\n        vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n        vec4 iy = vec4(Pi0.yy, Pi1.yy);\n        vec4 iz0 = Pi0.zzzz;\n        vec4 iz1 = Pi1.zzzz;\n\n        vec4 ixy = permute(permute(ix) + iy);\n        vec4 ixy0 = permute(ixy + iz0);\n        vec4 ixy1 = permute(ixy + iz1);\n\n        vec4 gx0 = ixy0 / 7.0;\n        vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n        gx0 = fract(gx0);\n        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n        vec4 sz0 = step(gz0, vec4(0.0));\n        gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n        gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n        vec4 gx1 = ixy1 / 7.0;\n        vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n        gx1 = fract(gx1);\n        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n        vec4 sz1 = step(gz1, vec4(0.0));\n        gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n        gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n        g000 *= norm0.x;\n        g010 *= norm0.y;\n        g100 *= norm0.z;\n        g110 *= norm0.w;\n        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n        g001 *= norm1.x;\n        g011 *= norm1.y;\n        g101 *= norm1.z;\n        g111 *= norm1.w;\n\n        float n000 = dot(g000, Pf0);\n        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n        float n111 = dot(g111, Pf1);\n\n        vec3 fade_xyz = fade(Pf0);\n        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n        return 2.2 * n_xyz;\n      }\n\n      varying vec3 vPos;\n      uniform float time;\n      varying vec3 vUv3;\n\n      void main() {\n        float speed = time / 3.5;\n        vec3 pp;\n        pp = vUv3.xyx * 600.0 + speed;\n        // pp += vPos * 0.25 + speed;\n        float noise = clamp(cnoise(speed + pp / 250.0 + 0.0 ), 0.0, 1.0);\n\n        vec3 colorA = vec3(81.0, 135.0, 228.0) * 0.2 / 255.0;\n        vec3 colorB = vec3(0.0, 150.0, 136.0) * 0.2 / 255.0;\n\n        vec4 backgroundColor = vec4(mix(colorA, colorB, noise), 1.0);\n\n        gl_FragColor = backgroundColor;\n\n        float starNoise = (noise) * pow(cnoise(speed + pp * 2.0) * 0.5 + 0.5, 15.5) * 30.0;\n\n        gl_FragColor.rgb += vec3(pow(starNoise, 1.3)) * 1.5;\n      }\n      `\n  }\n\n  let ref = useRef()\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.needsUpdate = true\n    }\n  }, [shaders, shaders.fragmentShader, shaders.vertexShader])\n\n  let uniforms = useRef({\n    time: { value: 0 }\n  })\n\n  useFrame(() => {\n    uniforms.current.time.value += 1 / 60\n  })\n\n  return (\n    <Sphere\n      frustumCulled={false}\n      userData={{\n        enableBloom: true\n      }}\n      scale={1}\n      args={[800, 20, 20]}\n    >\n      <shaderMaterial\n        ref={ref}\n        uniforms={uniforms.current}\n        fragmentShader={shaders.fragmentShader}\n        vertexShader={shaders.vertexShader}\n        side={DoubleSide}\n      >\n        {/*  */}\n        {/*  */}\n      </shaderMaterial>\n    </Sphere>\n  )\n}\n","import React from 'react'\nimport { createPortal, useThree } from '@react-three/fiber'\nimport { Text } from '@react-three/drei'\n\nexport function Tooltip({ Now }) {\n  Now.makeKeyReactive('tooltip')\n  let { camera } = useThree()\n  return createPortal(\n    <group position={[0.03, -0.03, -3]}>\n      <Text\n        anchorX='left'\n        anchorY='top'\n        userData={{ disableBloom: true }}\n        outlineWidth={0.003}\n        fontSize={0.06}\n      >\n        {Now.hoverData?.website ? 'Click to Open:\\n' : ''}\n        {Now.tooltip || ''}\n      </Text>\n    </group>,\n    camera\n  )\n}\n","import { useFrame, useThree } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { MathUtils } from 'three'\nimport { useAutoEvent } from '../utils/use-auto-event'\nimport { Tooltip } from './Tooltip'\n\nexport function TheHelper({ Now }) {\n  return (\n    <group>\n      <TheCursor Now={Now}></TheCursor>\n      <ClickToOpen Now={Now}></ClickToOpen>\n      <Tooltip Now={Now}></Tooltip>\n      <HideCursor></HideCursor>\n    </group>\n  )\n}\n\nfunction TheCursor({ Now }) {\n  let core = useRef()\n  let orbit = useRef()\n\n  useFrame(({ camera }) => {\n    if (core.current) {\n      core.current.position.copy(camera.position)\n      core.current.rotation.copy(camera.rotation)\n    }\n  })\n\n  return (\n    <group>\n      <group ref={core}>\n        <group ref={orbit} scale={[1, 1, 1]} position={[0, 0, -1]}>\n          {/* <Text\n            fontSize={0.01}\n            outlineColor='black'\n            outlineWidth={0.001}\n            color='white'\n          >\n            +\n          </Text> */}\n          <group scale={0.001} rotation={[0, 0, Math.PI * 0.25]}>\n            <Floating Now={Now}>\n              {/*  */}\n              <mesh position={[0, -9 / 2, 0]}>\n                <coneBufferGeometry args={[4, 9, 3, 1]}></coneBufferGeometry>\n                <meshBasicMaterial color='#000000'></meshBasicMaterial>\n              </mesh>\n              {/*  */}\n              <mesh position={[0, -11, 0]}>\n                <boxBufferGeometry args={[2, 5, 2]}></boxBufferGeometry>\n                <meshBasicMaterial color='#000000'></meshBasicMaterial>\n              </mesh>\n            </Floating>\n          </group>\n        </group>\n      </group>\n    </group>\n  )\n}\n\nfunction Floating({ Now, children }) {\n  const ref = useRef()\n  useFrame(({ clock }) => {\n    let time = clock.getElapsedTime()\n    if (ref.current) {\n      //\n      let target = 0\n      if (Now?.hoverData?.website) {\n        target = -3 + Math.cos(time * 5.0) * 3\n      }\n      ref.current.position.y = MathUtils.lerp(\n        ref.current.position.y,\n        target,\n        0.5\n      )\n    }\n  })\n  //\n  return <group ref={ref}>{children}</group>\n}\n\nfunction ClickToOpen({ Now }) {\n  let { gl } = useThree()\n\n  let move = 0\n  let isDown = false\n  useAutoEvent(\n    'pointerdown',\n    () => {\n      isDown = true\n      move = 0\n    },\n    { passive: false },\n    gl.domElement\n  )\n  useAutoEvent(\n    'pointerup',\n    () => {\n      isDown = false\n    },\n    { passive: false },\n    gl.domElement\n  )\n\n  useAutoEvent(\n    'pointermove',\n    () => {\n      if (isDown) {\n        move++\n      }\n    },\n    { passive: false },\n    gl.domElement\n  )\n\n  useAutoEvent(\n    'pointerup',\n    () => {\n      //\n      if (Now && move <= 10) {\n        if (Now?.hoverData?.website) {\n          let href = document.createElement('a')\n          href.href = Now.hoverData.website\n          href.target = '_blank'\n          href.click()\n        }\n      }\n    },\n    { passive: false },\n    gl.domElement\n  )\n\n  return null\n}\n\nfunction HideCursor() {\n  useAutoEvent(\n    'pointerdown',\n    () => {\n      document.body.style.cursor = 'none'\n    },\n    { passive: false },\n    document.body\n  )\n  useAutoEvent(\n    'pointerup',\n    () => {\n      document.body.style.cursor = 'grabbing'\n    },\n    { passive: false },\n    document.body\n  )\n\n  useEffect(() => {\n    document.body.style.cursor = 'grabbing'\n    return () => {\n      document.body.style.cursor = ''\n    }\n  }, [])\n  return null\n}\n","import React, { Suspense, useEffect } from 'react'\nimport { Canvas, useThree } from '@react-three/fiber'\nimport { useGLTF, PerspectiveCamera, useTexture } from '@react-three/drei'\nimport {\n  Map3D,\n  UserContorls,\n  TailCursor,\n  SimpleBloomer,\n  StarSky,\n  TheHelper,\n  useComputeEnvMap\n} from 'effectnode-3dworld'\n\n//\n// needs trailing slash\nexport const BASE_URL =\n  process.env.NODE_ENV === 'production'\n    ? `https://wonglok.github.io/effectnode-3dworld/`\n    : `/`\n\nconst App = () => {\n  return (\n    <Canvas dpr={[0, 1.5]} style={{ width: '100%', height: '100%' }}>\n      <Suspense fallback={<LoadingScreen></LoadingScreen>}>\n        <Content3D></Content3D>\n      </Suspense>\n    </Canvas>\n  )\n}\n\nfunction Content3D() {\n  let gltf = useGLTF(`${BASE_URL}map/demo-map-000.glb`)\n\n  return (\n    <group>\n      {gltf.scene && (\n        <Map3D object={gltf.scene}>\n          {({ Now }) => {\n            return (\n              <group>\n                <UserContorls\n                  higherCamera={1.5}\n                  avatarSpeed={2}\n                  Now={Now}\n                ></UserContorls>\n                <TailCursor Now={Now} color={'#bababa'}></TailCursor>\n                <TheHelper Now={Now}></TheHelper>\n              </group>\n            )\n          }}\n        </Map3D>\n      )}\n\n      <SimpleBloomer></SimpleBloomer>\n\n      {/* Optional */}\n      <ShaderEnvLight imageURL={`${BASE_URL}image/sky.png`}></ShaderEnvLight>\n\n      {/* StarSky */}\n      <StarSky></StarSky>\n    </group>\n  )\n}\n\nfunction ShaderEnvLight({ imageURL }) {\n  let tex = useTexture(imageURL)\n  let { get } = useThree()\n  let envMap = useComputeEnvMap(\n    /* glsl */ `\n      const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n      float noise( in vec2 p ) {\n        return sin(p.x)*sin(p.y);\n      }\n\n      float fbm4( vec2 p ) {\n          float f = 0.0;\n          f += 0.5000 * noise( p ); p = m * p * 2.02;\n          f += 0.2500 * noise( p ); p = m * p * 2.03;\n          f += 0.1250 * noise( p ); p = m * p * 2.01;\n          f += 0.0625 * noise( p );\n          return f / 0.9375;\n      }\n\n      float fbm6( vec2 p ) {\n          float f = 0.0;\n          f += 0.500000*(0.5 + 0.5 * noise( p )); p = m*p*2.02;\n          f += 0.250000*(0.5 + 0.5 * noise( p )); p = m*p*2.03;\n          f += 0.125000*(0.5 + 0.5 * noise( p )); p = m*p*2.01;\n          f += 0.062500*(0.5 + 0.5 * noise( p )); p = m*p*2.04;\n          f += 0.031250*(0.5 + 0.5 * noise( p )); p = m*p*2.01;\n          f += 0.015625*(0.5 + 0.5 * noise( p ));\n          return f/0.96875;\n      }\n\n      float pattern (vec2 p) {\n        float vout = fbm4( p + time + fbm6(  p + fbm4( p + time )) );\n        return abs(vout);\n      }\n\n      uniform sampler2D textureBG;\n\n      vec4 mainImage (vec2 uv) {\n        vec4 bg = texture2D(textureBG, uv);\n\n        vec3 rainbow = vec3(\n          0.35 + pattern(uv * 1.70123 + -0.17 * cos(time * 0.05)),\n          0.35 + pattern(uv * 1.70123 +  0.0 * cos(time * 0.05)),\n          0.35 + pattern(uv * 1.70123 +  0.17 * cos(time * 0.05))\n        );\n\n        return vec4(rainbow.xyz, 1.0);\n      }\n  `.trim(),\n    {\n      textureBG: { value: tex }\n    },\n    128\n  )\n\n  useEffect(() => {\n    let { scene } = get()\n    scene.environment = envMap\n    return () => {\n      scene.environment = null\n    }\n  }, [envMap, get])\n\n  return null\n}\n\nfunction LoadingScreen() {\n  return (\n    <group>\n      <group rotation-x={Math.PI * 0}>\n        <gridHelper args={[150, 50, 0x232323, 0xbababa]}></gridHelper>\n      </group>\n\n      <PerspectiveCamera\n        position={[0, 30, 30]}\n        rotation-x={Math.PI * -0.25}\n        makeDefault={true}\n      ></PerspectiveCamera>\n    </group>\n  )\n}\n\nexport default App\n\n//\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}