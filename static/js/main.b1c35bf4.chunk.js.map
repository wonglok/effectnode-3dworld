{"version":3,"sources":["../../src/utils/get-id.js","../../src/lib/Mini.js","../../src/utils/use-mini-engine.js","../../src/utils/use-auto-event.js","../../src/lib/Collider.js","../../src/lib/MapPlayer.js","../../src/utils/make-now.js","../../src/utils/make-shallow-store.js","../../src/compos/Map3D.js","../../src/compos/UserContorls.js","../../src/lib/CursorTrackerTail.js","../../src/compos/TailCursor.js","../../src/compos/SimpleBloomer.js","../../src/compos/StarSky.js","../../src/compos/EnvLightByImage.js","../../src/compos/Tooltip.js","../../src/compos/TheHelper.js","App.js","index.js"],"names":["getID","Math","constructor","parent","this","k","Promise","resolve","ttt","setInterval","clearInterval","isAborted","num","fnc","func","intv","window","clearTimeout","setTimeout","e","isPaused","console","name","duration","start","t","lt","dt","Proxy","get","useMiniEngine","useThree","useState","useEffect","mini","useFrame","st","useAutoEvent","settings","passive","dom","applyAutoEvent","scene","collider","makeCollider","floor","BufferGeometryUtils","require","environment","SkeletonUtils","geometries","c","cloned","key","it","mergedGeometry","MeshBVH","color","scanCenter","raycaster","result","source","first","Now","RoundedBoxGeometry","player","transparent","opacity","radius","segment","avatarDir","playerVelocity","tempVector","tempVector2","tempBox","tempMat","tempSegment","rotationCopier","delta","size","capsuleInfo","intersectsBounds","box","intersectsTriangle","tri","triPoint","capsulePoint","distance","depth","direction","newPosition","deltaVector","playerIsOnGround","clock","i","updatePlayer","makeNow","myObject","___NameSpaceID","Utils","exportJSON","JSON","getNameSpcaeID","onEvent","evName","hh","makeKeyReactive","setSt","s","reloadKey","CustomEvent","detail","proxy","o","set","makeShallowStore","moved","goingTo","camAt","avatarAt","avatarHead","avatarRot","avatarFaceLook","avatarLoading","avatarMode","avatarSpeed","tooltip","keyW","keyA","keyS","keyD","cursorPos","cursorNormal","cursorType","hoverData","isDown","camMode","overlay","profile","user","reload","onlineUID","Map3D","startAt","colliderRef","useRef","nowRef","mapPlayerRef","colliderManager","mapPlayer","lastScan","hit","camera","object","children","current","UserContorls","higherCamera","gl","works","ev","orig","fakeCam","orbit","OrbitControls","joystick","document","note","manager","zone","mode","position","left","bottom","forward","up","isUsing","nippleAngle","evt","nipple","cte","cts","keyBoardForward","scaler","MathUtils","Object","fov","near","far","rotation-x","makeDefault","numberOfScans","trailSize","WIDTH","setup","node","renderer","gpu","GPUComputationRenderer","dtPosition","lookUpTexture","addVariable","positionVariable","material","value","h","ii","error","positionShader","str","mouseUniforms","lookupRightLine","fillPositionTexture","theArray","texture","y","x","fillLookupTexture","items","lastOneInArray","render","trackers","uniform","getTextureAfterCompute","posTexture","getCurrentRenderTarget","mounter","count","sim","numSides","subdivisions","openEnded","geometry","getPointAtByT","controlPointsResolution","lineIdx","lineCount","textureName","floatval","Number","getLinesPointAtT","pointLineMaker","matLine0","uniforms","tailColor","time","matcap","vertexShader","fragmentShader","depthTest","line0","cylinderBufferGeo","baseGeometry","tmpVec","xPositions","angles","uvs","vertices","faceVertexUvs","oPositions","verts","faceUvs","v","angle","posArray","Float32Array","angleArray","uvArray","origPosArray","lineGeo","offset","ddxyz","iii","z","dataLength","display","looker","cursor","origin","worldPos","lerpWorldPos","update","makeTracker","TailCursor","colorObj","mouse","ref","resBloom","height","EffectComposer","RenderPass","UnrealBloomPass","efComposer","renderPass","unrealPass","dark","baseLayer","bloomLayer","darkLayer","onBeforeCompileForStdMat","globalDarkening","shader","atBegin","uniqueMaterialMap","enableDarkenMap","darken","origBG","renderToTexture","resBase","encoding","generateMipmaps","quadMat","bloomDiffuse","baseDiffuse","fsQuad","bloomTex","SimpleBloomer","looer","base","bloom","compositor","baseTex","StarSky","shaders","frustumCulled","userData","enableBloom","scale","args","side","DoubleSide","EnvLightByImage","imageURL","useTexture","pmremGenerator","envMap","Tooltip","props","createPortal","disableBloom","TheHelper","TheCursor","core","rotation","Floating","target","ClickToOpen","move","href","HideCursor","BASE_URL","Content3D","gltf","useGLTF","useMemo","clone","Vector3","startLookAt","traverse","getWorldPosition","LoadingScreen","PI","PerspectiveCamera","App","dpr","style","width","fallback","ReactDOM","getElementById"],"mappings":"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","file":"static/js/main.b1c35bf4.chunk.js","sourcesContent":["export const getID = function () {\n  return (\n    '_' +\n    Math.random().toString(36).substr(2, 9) +\n    Math.random().toString(36).substr(2, 9)\n  )\n}\n","export class Mini {\n  constructor({ parent = false }) {\n    this.parent = parent\n    this.resource = new Map()\n    this.get = (k) => {\n      return new Promise((resolve) => {\n        let ttt = 0\n        ttt = setInterval(() => {\n          if (this.parent) {\n            if (this.resource.has(k) || this.parent.resource.has(k)) {\n              clearInterval(ttt)\n              resolve(this.resource.get(k) || this.parent.resource.get(k))\n            }\n          } else {\n            if (this.resource.has(k)) {\n              clearInterval(ttt)\n              resolve(this.resource.get(k))\n            }\n          }\n        })\n      })\n    }\n    this.set = (k, v) => {\n      this.resource.set(k, v)\n    }\n    this.name = 'ENMini'\n\n    let isAborted = false\n    this.tasks = []\n    this.resizeTasks = []\n    this.cleanTasks = []\n    this.onLoop = (fnc, num = 0) => {\n      if (num >= 0) {\n        this.tasks.push(fnc)\n      } else {\n        this.tasks.unshift(fnc)\n      }\n    }\n\n    this.onResize = (fnc) => {\n      fnc()\n      this.resizeTasks.push(fnc)\n    }\n\n    this.onClean = (func) => {\n      this.cleanTasks.push(func)\n    }\n\n    let intv = 0\n    const internalResize = () => {\n      clearTimeout(intv)\n      intv = setTimeout(() => {\n        this.resizeTasks.forEach((e) => e())\n      }, 16.8888)\n    }\n\n    window.addEventListener('resize', () => {\n      internalResize()\n    })\n\n    let isPaused = false\n    this.toggle = () => {\n      isPaused = !isPaused\n    }\n    this.pause = () => {\n      isPaused = true\n    }\n    this.play = () => {\n      isPaused = false\n    }\n\n    this.clean = () => {\n      isAborted = true\n      try {\n        this.cleanTasks.forEach((e) => e())\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    this.lastTime = window.performance.now()\n    this.work = () => {\n      this.timeNow = window.performance.now()\n      if (isAborted) {\n        return {\n          name: this.name,\n          duration: 0\n        }\n      }\n      if (isPaused) {\n        return {\n          name: this.name,\n          duration: 0\n        }\n      }\n      const start = window.performance.now()\n      try {\n        let t = this.timeNow\n        const lt = this.lastTime\n        let dt = t - lt\n        this.lastTime = t\n        dt = dt / 1000\n        t = t / 1000\n        if (dt >= 100) {\n          dt = 100\n        }\n\n        this.tasks.forEach((e) => e(t, dt))\n      } catch (e) {\n        console.error(e)\n      }\n      const end = window.performance.now()\n      const duration = end - start\n\n      return {\n        name: this.name,\n        duration\n      }\n    }\n\n    this.ready = new Proxy(\n      {},\n      {\n        get: (obj, key) => {\n          return this.get(key)\n        }\n      }\n    )\n    this.now = new Proxy(\n      {},\n      {\n        get: (obj, key) => {\n          if (this.parent) {\n            return this.resource.get(key) || this.parent.resource.get(key)\n          } else {\n            return this.resource.get(key)\n          }\n        }\n      }\n    )\n  }\n}\n\n// let mini = new Mini({ name: \"base\", domElement: ref.current, window });\n//\n\n//\n//\n//\n","import { useFrame, useThree } from '@react-three/fiber'\nimport { useEffect, useState } from 'react'\nimport { Mini } from '../lib/Mini'\n\nexport function useMiniEngine() {\n  const { get } = useThree()\n  const [mini] = useState(() => {\n    return new Mini({})\n  })\n\n  useEffect(() => {\n    return () => {\n      mini.clean()\n    }\n  }, [])\n\n  useFrame(() => {\n    const st = get()\n    for (const kn in st) {\n      mini.set(kn, st[kn])\n    }\n    mini.work()\n  })\n\n  return { mini }\n}\n","import { useEffect } from 'react'\n\nexport const useAutoEvent = function (\n  ev,\n  fnc,\n  settings = { passive: false },\n  dom\n) {\n  useEffect(() => {\n    dom = dom || window\n    dom.addEventListener(ev, fnc, settings)\n    return () => {\n      dom = dom || window\n      dom.removeEventListener(ev, fnc)\n    }\n  }, [])\n}\n\nexport const applyAutoEvent = function (\n  dom,\n  ev,\n  fnc,\n  settings = { passive: false }\n) {\n  dom = dom || window\n  dom.addEventListener(ev, fnc, settings)\n  return () => {\n    dom = dom || window\n    dom.removeEventListener(ev, fnc)\n  }\n}\n","import { Mesh, MeshBasicMaterial, Raycaster, Vector2 } from 'three'\nimport { MeshBVH } from 'three-mesh-bvh'\nexport class Collider {\n  constructor({ floor, scene }) {\n    this.floor = floor\n    this.center = new Vector2(0, 0)\n    this.raycaster = new Raycaster()\n    this.scene = scene\n\n    const collider = this.makeCollider()\n    this.collider = collider\n    this.preview = collider\n  }\n\n  makeCollider() {\n    const { scene, floor } = this\n    const BufferGeometryUtils =\n      require('three/examples/jsm/utils/BufferGeometryUtils').BufferGeometryUtils\n    const SkeletonUtils =\n      require('three/examples/jsm/utils/SkeletonUtils').SkeletonUtils\n\n    const environment = SkeletonUtils.clone(floor)\n\n    const geometries = []\n\n    environment.updateMatrixWorld()\n    environment.traverse((c) => {\n      if (c.geometry && !c.userData.isNotFloor) {\n        const cloned = c.geometry.clone()\n        cloned.applyMatrix4(c.matrixWorld)\n\n        for (const key in cloned.attributes) {\n          if (key === 'position' || key === 'index') {\n          } else {\n            cloned.deleteAttribute(key)\n          }\n        }\n\n        geometries.push(cloned)\n      }\n    })\n\n    scene.traverse((it) => {\n      if (it && it.userData && it.userData.isFloor && it.geometry) {\n        const cloned = it.geometry.clone()\n        it.updateMatrixWorld()\n\n        cloned.applyMatrix4(it.matrixWorld)\n        for (const key in cloned.attributes) {\n          if (key !== 'position') {\n            cloned.deleteAttribute(key)\n          }\n        }\n        geometries.push(cloned)\n      }\n    })\n\n    const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(\n      geometries,\n      false\n    )\n\n    mergedGeometry.boundsTree = new MeshBVH(mergedGeometry)\n\n    const collider = new Mesh(\n      mergedGeometry,\n      new MeshBasicMaterial({ color: 0xffffff })\n    )\n    collider.material.wireframe = true\n    collider.material.opacity = 0.5\n    collider.material.transparent = true\n    collider.updateMatrixWorld()\n\n    return collider\n  }\n\n  //\n  scanCenter({ camera, scene }) {\n    const { raycaster, center, collider } = this\n\n    raycaster.setFromCamera(center, camera)\n    const result = []\n    const source = []\n    scene.traverse((it) => {\n      if (\n        it.geometry &&\n        (it?.userData?.isHoverable ||\n          it?.userData?.isFloor ||\n          it?.userData?.tooltip ||\n          it?.userData?.website)\n      ) {\n        source.push(it)\n      }\n    })\n    raycaster.intersectObjects(source, false, result)\n\n    collider.geometry.boundsTree.raycastFirst(\n      collider,\n      raycaster,\n      raycaster.ray\n    )\n\n    const first = result[0]\n\n    if (first) {\n      return first\n    } else {\n      return false\n    }\n  }\n}\n","import {\n  Box3,\n  Clock,\n  Line3,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  Object3D,\n  Vector3\n} from 'three'\n\nexport class MapPlayer {\n  constructor({ collider, startAt, Now }) {\n    this.collider = collider\n    const RoundedBoxGeometry =\n      require('three/examples/jsm/geometries/RoundedBoxGeometry.js').RoundedBoxGeometry\n    const scale = 1\n    const radius = 1.3 * scale\n    const width = 1 * scale\n    const height = 2 * scale\n    const depth = 1 * scale\n    const player = new Mesh(\n      new RoundedBoxGeometry(width, height, depth, 8, radius),\n      new MeshLambertMaterial({ transparent: true, opacity: 1 })\n    )\n    player.geometry.translate(0, -radius, 0)\n    player.castShadow = true\n\n    player.capsuleInfo = {\n      radius: radius,\n      segment: new Line3(new Vector3(), new Vector3(0, -1.0, 0.0))\n    }\n    this.player = player\n\n    player.position.copy(startAt)\n    player.position.y += 5\n\n    player.geometry.computeBoundingBox()\n    player.collider = new Box3().copy(player.geometry.boundingBox)\n\n    const avatarDir = new Vector3()\n    const playerVelocity = new Vector3(0, 0, 0)\n    // const upVector = new Vector3(0, 1, 0);\n    const tempVector = new Vector3()\n    const tempVector2 = new Vector3()\n    const tempBox = new Box3()\n    const tempMat = new Matrix4()\n    const tempSegment = new Line3()\n    const rotationCopier = new Object3D()\n    let playerIsOnGround = true\n\n    function updatePlayer({ delta, player }) {\n      // fall down\n      playerVelocity.y += delta * -9.8\n\n      player.position.addScaledVector(playerVelocity, delta)\n\n      if (player.position.y <= -50) {\n        // player.position.y = 0;\n        player.position.copy(startAt)\n        Now.goingTo.copy(startAt)\n        Now.goingTo.z += 1\n        playerVelocity.y = 0.0\n      }\n\n      avatarDir.copy(Now.goingTo).sub(player.position)\n      avatarDir.y = 0\n      const size = avatarDir.length()\n      avatarDir.normalize()\n      avatarDir.y = 0\n\n      avatarDir.multiplyScalar(Now.avatarSpeed)\n\n      if (size >= 0.1) {\n        player.position.addScaledVector(avatarDir, 0.04)\n        Now.avatarMode = 'running'\n      } else {\n        Now.avatarMode = 'standing'\n      }\n\n      player.updateMatrixWorld()\n\n      // adjust player position based on collisions\n      const capsuleInfo = player.capsuleInfo\n      tempBox.makeEmpty()\n      tempMat.copy(collider.matrixWorld).invert()\n      tempSegment.copy(capsuleInfo.segment)\n\n      // get the position of the capsule in the local space of the collider\n      tempSegment.start.applyMatrix4(player.matrixWorld).applyMatrix4(tempMat)\n      tempSegment.end.applyMatrix4(player.matrixWorld).applyMatrix4(tempMat)\n\n      // get the axis aligned bounding box of the capsule\n      tempBox.expandByPoint(tempSegment.start)\n      tempBox.expandByPoint(tempSegment.end)\n\n      tempBox.min.addScalar(-capsuleInfo.radius)\n      tempBox.max.addScalar(capsuleInfo.radius)\n\n      collider.geometry.boundsTree.shapecast(collider, {\n        intersectsBounds: (box) => box.intersectsBox(tempBox),\n\n        intersectsTriangle: (tri) => {\n          // check if the triangle is intersecting the capsule and adjust the\n          // capsule position if it is.\n          const triPoint = tempVector\n          const capsulePoint = tempVector2\n\n          const distance = tri.closestPointToSegment(\n            tempSegment,\n            triPoint,\n            capsulePoint\n          )\n          if (distance < capsuleInfo.radius) {\n            const depth = capsuleInfo.radius - distance\n            const direction = capsulePoint.sub(triPoint).normalize()\n\n            tempSegment.start.addScaledVector(direction, depth)\n            tempSegment.end.addScaledVector(direction, depth)\n          }\n        }\n      })\n\n      // get the adjusted position of the capsule collider in world space after checking\n      // triangle collisions and moving it. capsuleInfo.segment.start is assumed to be\n      // the origin of the player model.\n      const newPosition = tempVector\n      newPosition.copy(tempSegment.start).applyMatrix4(collider.matrixWorld)\n\n      // check how much the collider was moved\n      const deltaVector = tempVector2\n      deltaVector.subVectors(newPosition, player.position)\n\n      // adjust the player model\n      player.position.copy(newPosition)\n\n      //\n      Now.avatarAt.copy(player.position)\n      // Now.avatarAt.y += 0.1;\n\n      rotationCopier.position.copy(player.position)\n      rotationCopier.lookAt(\n        //\n        Now.goingTo.x,\n        player.position.y,\n        Now.goingTo.z\n      )\n\n      Now.avatarRot.x = rotationCopier.rotation.x\n      Now.avatarRot.y = rotationCopier.rotation.y\n      Now.avatarRot.z = rotationCopier.rotation.z\n\n      // if the player was primarily adjusted vertically we assume it's on something we should consider gound\n      playerIsOnGround =\n        deltaVector.y > Math.abs(delta * playerVelocity.y * 0.25)\n\n      if (!playerIsOnGround) {\n        deltaVector.normalize()\n        playerVelocity.addScaledVector(\n          deltaVector,\n          -deltaVector.dot(playerVelocity)\n        )\n        //\n      } else {\n        playerVelocity.set(0, 0, 0)\n      }\n    }\n\n    const steps = 4\n    const clock = new Clock()\n\n    this.onSimulate = () => {\n      let dt = clock.getDelta()\n      if (dt >= 1 / 30) {\n        dt = 1 / 30\n      }\n\n      for (let i = 0; i < steps; i++) {\n        updatePlayer({ delta: dt / steps, player })\n      }\n    }\n  }\n}\n","import { Vector3 } from 'three'\nimport { makeShallowStore } from './make-shallow-store'\n\nexport const makeNow = () => {\n  return makeShallowStore({\n    //\n    moved: 0,\n    goingTo: new Vector3(),\n    camAt: new Vector3(),\n    avatarAt: new Vector3(),\n    avatarHead: new Vector3(),\n    avatarRot: new Vector3(),\n    avatarFaceLook: new Vector3(),\n    avatarLoading: true,\n    avatarMode: 'standing',\n    avatarSpeed: 1.0,\n\n    tooltip: '',\n    keyW: false,\n    keyA: false,\n    keyS: false,\n    keyD: false,\n    cursorPos: new Vector3(),\n    cursorNormal: new Vector3(),\n    cursorType: 'hide',\n    hoverData: false,\n    isDown: false,\n\n    // avatarAtPhy: new Vector3(),\n\n    camMode: 'first',\n\n    overlay: '',\n\n    profile: false,\n    user: false,\n\n    reload: [],\n    onlineUID: []\n  })\n}\n","import { useEffect, useState } from 'react'\nimport { getID } from './get-id'\nexport const makeShallowStore = (myObject = {}) => {\n  let ___NameSpaceID = getID()\n  let Utils = {\n    exportJSON: () => {\n      return JSON.parse(JSON.stringify(myObject))\n    },\n    getNameSpcaeID: () => {\n      return ___NameSpaceID\n    },\n    /* */\n    onEvent: (key, func) => {\n      let evName = `${___NameSpaceID}`\n      let hh = () => {\n        func(myObject[key])\n      }\n\n      window.addEventListener(`${evName}-${key}`, hh)\n      return () => {\n        window.removeEventListener(`${evName}-${key}`, hh)\n      }\n    },\n\n    makeKeyReactive: (key) => {\n      let [vv, setSt] = useState(0)\n      useEffect(() => {\n        let evName = `${___NameSpaceID}`\n\n        let hh = () => {\n          setSt((s) => {\n            return s + 1\n          })\n        }\n\n        window.addEventListener(`${evName}-${key}`, hh)\n        return () => {\n          window.removeEventListener(`${evName}-${key}`, hh)\n        }\n      }, [vv])\n    },\n\n    reloadKey: (key) => {\n      window.dispatchEvent(\n        new CustomEvent(`${___NameSpaceID}-${key}`, { detail: {} })\n      )\n    }\n  }\n\n  let proxy = new Proxy(myObject, {\n    get: (o, k) => {\n      //\n      if (Utils[k]) {\n        return Utils[k]\n      }\n\n      return o[k]\n    },\n    set: (o, key, val) => {\n      let currentVal = o[key]\n\n      if (currentVal !== val) {\n        o[key] = val\n\n        if (typeof window !== 'undefined') {\n          window.dispatchEvent(\n            new CustomEvent(`${___NameSpaceID}-${key}`, { detail: {} })\n          )\n        }\n      }\n\n      return true\n    }\n  })\n\n  return proxy\n}\n","import { useThree } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { Collider } from '../lib/Collider'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { makeNow } from '../utils/make-now'\nimport { MapPlayer } from '../lib/MapPlayer'\n\nexport const Map3D = ({ children, floor, startAt }) => {\n  const { get } = useThree()\n  //\n  //\n  const { mini } = useMiniEngine()\n  const colliderRef = useRef()\n  const nowRef = useRef()\n  const mapPlayerRef = useRef()\n  useEffect(() => {\n    floor.traverse((it) => {\n      if (it.geometry) {\n        it.userData.isFloor = true\n      }\n    })\n\n    //\n    const colliderManager = (colliderRef.current = new Collider({\n      floor,\n      scene: get().scene\n    }))\n\n    const Now = (nowRef.current = makeNow())\n\n    const mapPlayer = (mapPlayerRef.current = new MapPlayer({\n      collider: colliderManager.collider,\n      startAt,\n      Now\n    }))\n\n    let lastScan = false\n    mini.onLoop(() => {\n      //\n      const { camera, scene } = get()\n      const hit = colliderManager.scanCenter({ camera, scene })\n\n      if (hit) {\n        Now.cursorPos.copy(hit.point)\n        Now.cursorNormal.copy(hit.face.normal)\n      }\n\n      // lighup\n      if (hit) {\n        if (hit.object.userData.website || hit.object.userData.tooltip) {\n          if (lastScan) {\n            lastScan.userData.enableBloom = false\n          }\n          hit.object.userData.enableBloom = true\n          lastScan = hit.object\n        }\n      } else {\n        if (lastScan) {\n          lastScan.userData.enableBloom = false\n        }\n      }\n\n      if (hit) {\n        if (Now.hoverData !== hit.object.userData) {\n          Now.hoverData = hit.object.userData || null\n        }\n        if (Now.tooltip !== hit.object.userData?.tooltip) {\n          Now.tooltip = hit.object.userData.tooltip\n        }\n      } else {\n        if (Now.hoverData !== null) {\n          Now.hoverData = null\n        }\n        if (Now.tooltip !== '') {\n          Now.tooltip = ''\n        }\n      }\n\n      mapPlayer.onSimulate()\n    })\n\n    return () => {\n      mini.clean()\n    }\n  }, [])\n\n  //\n\n  //\n  //\n  return (\n    <group>\n      <primitive object={floor}>\n        {/*  */}\n        {/*  */}\n      </primitive>\n      {nowRef.current &&\n        typeof children === 'function' &&\n        children({ Now: nowRef.current })}\n\n      {/*  */}\n      {/*  */}\n    </group>\n  )\n}\n","import { useFrame, useThree } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { Camera, MathUtils, Vector3 } from 'three'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\nimport { applyAutoEvent, useAutoEvent } from '../utils/use-auto-event'\n// import { useMiniEngine } from '../utils/use-mini-engine'\n// import { CursorTrackerTail } from '../lib/CursorTrackerTail'\nimport { PerspectiveCamera } from '@react-three/drei'\n\nexport function UserContorls({\n  Now,\n  startAt,\n  startLookAt,\n  avatarSpeed = 2,\n  higherCamera = 1.5\n}) {\n  let { get, gl } = useThree()\n  let works = useRef({\n    //\n  })\n\n  useEffect(() => {\n    //\n    Now.avatarAt.copy(startAt)\n    Now.goingTo.copy(startAt)\n  })\n\n  useAutoEvent(\n    `touchstart`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useAutoEvent(\n    `touchmove`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useAutoEvent(\n    `touchend`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useEffect(() => {\n    let orig = Now.camMode\n    Now.camMode = 'first'\n    Now.avatarSpeed = avatarSpeed\n    return () => {\n      Now.avatarSpeed = 1\n      Now.camMode = orig\n    }\n  })\n  //\n  useAutoEvent('keydown', (ev) => {\n    // console.log(ev.key);\n\n    if (ev.key === 'w') {\n      Now.keyW = true\n    }\n    if (ev.key === 'a') {\n      Now.keyA = true\n    }\n    if (ev.key === 's') {\n      Now.keyS = true\n    }\n    if (ev.key === 'd') {\n      Now.keyD = true\n    }\n  })\n  useAutoEvent('keyup', (ev) => {\n    // console.log(ev.key);\n\n    if (ev.key === 'w') {\n      Now.keyW = false\n    }\n    if (ev.key === 'a') {\n      Now.keyA = false\n    }\n    if (ev.key === 's') {\n      Now.keyS = false\n    }\n    if (ev.key === 'd') {\n      Now.keyD = false\n    }\n  })\n\n  useEffect(() => {\n    let camera = get().camera\n    camera.near = 0.1\n    camera.far = 10000\n    camera.fov = 45\n    camera.updateProjectionMatrix()\n\n    let fakeCam = new Camera()\n    let orbit = new OrbitControls(fakeCam, gl.domElement)\n    orbit.enableRotate = true\n    orbit.enablePan = false\n    orbit.enableZoom = false\n    orbit.enableDamping = true\n    orbit.rotateSpeed = 0.5\n\n    fakeCam.position.copy(startAt)\n    orbit.target.copy(startLookAt)\n\n    let joystick = document.createElement('div')\n\n    document.body.appendChild(joystick)\n    joystick.style.cssText = `\n      position: absolute;\n      bottom: 30px;\n      left: 30px;\n      width: 80px;\n      height: 80px;\n      color: white;\n      user-select: none;\n      z-index: 20;\n    `\n\n    let note = document.createElement('div')\n    document.body.appendChild(note)\n    note.style.cssText = `\n      position: absolute;\n      bottom: 50px;\n      left: 50px;\n      width: 80px;\n      height: 80px;\n      color: white;\n      user-select: none;\n      z-index: 10;\n      text-align: center;\n      opacity: 0.4;\n    `\n    note.innerHTML = `Walk Around JoyStick`\n\n    let nipplejs = require('nipplejs')\n    var manager = nipplejs.create({\n      zone: joystick,\n      color: 'white',\n      mode: 'static',\n      position: { left: '60px', bottom: '60px' }\n    })\n\n    let forward = new Vector3(0, 0, 0)\n    let up = new Vector3(0, 1, 0)\n\n    let ttt = 0\n    let isUsing = false\n    let nippleAngle = 0\n\n    // window.addEventListener('touchstart', () => {\n    //   isDown = true\n    // })\n    // window.addEventListener('touchend', () => {\n    //   isDown = false\n    // })\n\n    manager.on('start move dir plain', function (evt, nipple) {\n      if (nipple?.angle?.radian) {\n        nippleAngle = nipple?.angle?.radian\n        orbit.enableRotate = false\n\n        isUsing = true\n        // Now.isDown = true;\n\n        clearTimeout(ttt)\n        ttt = setTimeout(() => {\n          isUsing = false\n        }, 100)\n      }\n    })\n\n    manager.on('end', () => {\n      nippleAngle = 0\n      works.current.endForward = () => {\n        forward.multiplyScalar(0.8)\n      }\n      // Now.isDown = false;\n      orbit.enableRotate = true\n      isUsing = false\n    })\n\n    let cte = applyAutoEvent(\n      gl.domElement.parentElement,\n      `touchend`,\n      (ev) => {\n        if (!isUsing) {\n          orbit.enableRotate = true\n        }\n      },\n      { passive: false }\n    )\n    let cts = applyAutoEvent(\n      gl.domElement.parentElement,\n      `touchstart`,\n      (ev) => {\n        if (!isUsing) {\n          orbit.enableRotate = true\n        }\n      },\n      { passive: false }\n    )\n\n    let keyBoardForward = new Vector3(0, 0, 1)\n    let scaler = 0.3\n\n    works.current.ctrl2 = () => {\n      if (isUsing) {\n        forward.set(0, 0, -1)\n        forward.applyAxisAngle(\n          up,\n          orbit.getAzimuthalAngle() + nippleAngle - Math.PI * 0.5 || 0.0\n        )\n      }\n      //\n      if (Now.keyW || Now.keyA || Now.keyS || Now.keyD) {\n        scaler = MathUtils.lerp(scaler, 0.3, 0.1)\n      } else {\n        scaler = MathUtils.lerp(scaler, 0.0, 0.1)\n      }\n\n      // controls.getDirection(dir);\n      if (Now.keyW) {\n        keyBoardForward.set(0, 0, -1 * scaler)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyA) {\n        keyBoardForward.set(-1 * scaler, 0, 0)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyS) {\n        keyBoardForward.set(0, 0, 1 * scaler)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyD) {\n        keyBoardForward.set(1 * scaler, 0, 0)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      }\n\n      Now.goingTo.copy(Now.avatarAt)\n      // if (!(Now.keyW || Now.keyA || Now.keyS || Now.keyD)) {\n      //   Now.avatarAt.copy(Now.avatarAt);\n      // }\n    }\n\n    // grid of raycaster\n\n    works.current.ctrl3 = () => {\n      let newType = 'floor'\n\n      // let upness = Now.cursorNormal.y || 0;\n      if (Now.cursorType !== newType) {\n        Now.cursorType = newType\n      }\n    }\n\n    works.current.ctrl = () => {\n      orbit.update()\n\n      Now.goingTo.add(forward)\n\n      camera.position.x = Now.avatarAt.x\n      camera.position.y = Now.avatarAt.y + higherCamera\n      camera.position.z = Now.avatarAt.z\n\n      camera.rotation.copy(fakeCam.rotation)\n    }\n\n    Now.enableFloorCursor = false\n    return () => {\n      Now.enableFloorCursor = true\n      manager.off('start move end dir plain')\n      manager.destroy()\n      document.body.removeChild(joystick)\n\n      joystick.remove()\n      note.remove()\n      cte()\n      cts()\n    }\n  }, [])\n\n  useFrame(() => {\n    Object.values(works.current).forEach((e) => e())\n  })\n  return (\n    <group>\n      {/*  */}\n      {/*  */}\n      <PerspectiveCamera\n        fov={45}\n        near={0.1}\n        far={10000}\n        position={[0, 20, 20]}\n        rotation-x={Math.PI * -0.25}\n        makeDefault\n      />\n    </group>\n  )\n}\n","import {\n  HalfFloatType,\n  Vector3,\n  BufferAttribute,\n  CylinderBufferGeometry,\n  InstancedBufferAttribute,\n  InstancedBufferGeometry,\n  Vector2,\n  RepeatWrapping,\n  ShaderMaterial,\n  Mesh,\n  // DataTexture,\n  // DataUtils,\n  // RGBFormat,\n  // AdditiveBlending,\n  Object3D,\n  Color\n} from 'three'\n// import { GPUComputationRenderer } from 'three-stdlib'\nimport { Geometry } from 'three/examples/jsm/deprecated/Geometry.js'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer'\n\nclass LokLokWiggleSimulation {\n  constructor({ node, numberOfScans = 10, trailSize = 32 }) {\n    this.node = node\n    this.WIDTH = trailSize\n    this.HEIGHT = numberOfScans // number of trackers\n    this.COUNT = this.WIDTH * this.HEIGHT\n    this.v3v000 = new Vector3(0, 0, 0)\n    this.wait = this.setup({ node })\n  }\n\n  async setup({ node }) {\n    let renderer = await node.ready.gl\n\n    let gpu = (this.gpu = new GPUComputationRenderer(\n      this.WIDTH,\n      this.HEIGHT,\n      renderer\n    ))\n\n    gpu.setDataType(HalfFloatType)\n\n    const dtPosition = this.gpu.createTexture()\n    const lookUpTexture = this.gpu.createTexture()\n    this.fillPositionTexture(dtPosition)\n    this.fillLookupTexture(lookUpTexture)\n\n    this.positionVariable = this.gpu.addVariable(\n      'texturePosition',\n      this.positionShader(),\n      dtPosition\n    )\n    this.gpu.setVariableDependencies(this.positionVariable, [\n      this.positionVariable\n    ])\n\n    this.positionUniforms = this.positionVariable.material.uniforms\n    this.positionUniforms.lookup = { value: lookUpTexture }\n\n    let h = this.HEIGHT\n    for (let ii = 0; ii < h; ii++) {\n      this.positionUniforms['mouse' + ii] = { value: new Vector3(0, 0, 0) }\n    }\n\n    this.positionUniforms.time = { value: 0 }\n    dtPosition.wrapS = RepeatWrapping\n    dtPosition.wrapT = RepeatWrapping\n\n    //\n    const error = this.gpu.init()\n    if (error !== null) {\n      console.error(error)\n    }\n  }\n\n  positionShader() {\n    let lookupRightLine = () => {\n      let str = `if (false) {}`\n      let h = this.HEIGHT\n      for (let ii = 0; ii < h; ii++) {\n        str += `\n          else if (currentLine == ${ii.toFixed(0)}.0) {\n            gl_FragColor = vec4(mouse${ii.toFixed(0)}, 1.0);\n          }\n        `\n      }\n      return str\n    }\n\n    let mouseUniforms = () => {\n      let str = ``\n      let h = this.HEIGHT\n      for (let ii = 0; ii < h; ii++) {\n        str += `\n          uniform vec3 mouse${ii.toFixed(0)};\n        `\n      }\n\n      return str\n    }\n    return /* glsl */ `\n      ${mouseUniforms()}\n\n      uniform sampler2D lookup;\n      uniform float time;\n\n\t\t\tvoid main()\t{\n        // const float width = resolution.x;\n        // const float height = resolution.y;\n        // float xID = floor(gl_FragCoord.x);\n        // float yID = floor(gl_FragCoord.y);\n\n        vec2 uvCursor = vec2(gl_FragCoord.x, gl_FragCoord.y) / resolution.xy;\n        // vec4 positionHead = texture2D( texturePosition, uvCursor );\n\n        vec4 lookupData = texture2D(lookup, uvCursor);\n        vec2 nextUV = lookupData.xy;\n        float currentIDX = floor(gl_FragCoord.x);\n        float currentLine = floor(gl_FragCoord.y);\n\n        if (floor(currentIDX) == 0.0) {\n          ${lookupRightLine()}\n        } else {\n          vec3 positionChain = texture2D( texturePosition,nextUV ).xyz;\n          gl_FragColor = vec4(positionChain, 1.0);\n        }\n\n\n\t\t\t}\n    `\n  }\n\n  fillPositionTexture(texture) {\n    let i = 0\n    const theArray = texture.image.data\n\n    for (let y = 0; y < this.HEIGHT; y++) {\n      for (let x = 0; x < this.WIDTH; x++) {\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n      }\n    }\n    texture.needsUpdate = true\n  }\n\n  fillLookupTexture(texture) {\n    let i = 0\n    const theArray = texture.image.data\n    let items = []\n\n    for (let y = 0; y < this.HEIGHT; y++) {\n      for (let x = 0; x < this.WIDTH; x++) {\n        let lastOneInArray = items[items.length - 1] || [0, 0]\n        theArray[i++] = lastOneInArray[0]\n        theArray[i++] = lastOneInArray[1]\n        theArray[i++] = this.WIDTH\n        theArray[i++] = this.HEIGHT\n        items.push([x / this.WIDTH, y / this.HEIGHT])\n      }\n    }\n    texture.needsUpdate = true\n  }\n\n  render({ trackers }) {\n    this.positionUniforms.time.value = window.performance.now() / 1000\n\n    trackers.forEach((track, idx) => {\n      let uniform = this.positionUniforms['mouse' + idx]\n      if (uniform && uniform.value) {\n        uniform.value.copy(track)\n        // console.log(idx, track.toArray().join(\"-\"));\n      }\n    })\n\n    this.gpu.compute()\n  }\n\n  getTextureAfterCompute() {\n    return {\n      posTexture: this.gpu.getCurrentRenderTarget(this.positionVariable).texture\n    }\n  }\n}\n\nclass LokLokWiggleDisplay {\n  constructor({ node, sim, mounter, color }) {\n    this.mounter = mounter\n    this.node = node\n    this.sim = sim\n    this.color = color\n    this.wait = this.setup({ node })\n  }\n\n  async setup({ node }) {\n    let mounter = this.mounter\n\n    // let camera = await node.ready.camera;\n    // let renderer = await node.ready.gl;\n\n    let { geometry, subdivisions, count } = new NoodleGeo({\n      count: this.sim.HEIGHT,\n      numSides: 4,\n      subdivisions: this.sim.WIDTH * 2,\n      openEnded: false\n    })\n\n    geometry.instanceCount = count\n\n    let getPointAtByT = ({\n      controlPointsResolution = 20,\n      lineIdx = 0,\n      lineCount = this.sim.HEIGHT,\n      textureName = 'CONTROL_POINTS'\n    }) => {\n      controlPointsResolution = Math.floor(controlPointsResolution)\n\n      let floatval = `${Number(controlPointsResolution).toFixed(1)}`\n\n      let res = `\n      vec3 pointIDX_${textureName}_${lineIdx.toFixed(0)} (float index) {\n        vec3 result = vec3(0.0);\n\n        vec4 color = texture2D(${textureName},\n          vec2(\n            index / ${controlPointsResolution.toFixed(1)},\n            ${lineIdx.toFixed(1)} / ${lineCount.toFixed(1)}\n          )\n        );\n\n        result = color.rgb;\n\n        return result;\n      }\n\n      vec3 catmullRom_${textureName}_${lineIdx} (vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n          vec3 v0 = (p2 - p0) * 0.5;\n          vec3 v1 = (p3 - p1) * 0.5;\n          float t2 = t * t;\n          float t3 = t * t * t;\n\n          return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n      }\n\n      vec3 getPointAt_${lineIdx.toFixed(0)} (float t) {\n        bool closed = false;\n        float ll = ${floatval};\n        float minusOne = 1.0;\n        if (closed) {\n          minusOne = 0.0;\n        }\n\n        float p = (ll - minusOne) * t;\n        float intPoint = floor(p);\n        float weight = p - intPoint;\n\n        float idx0 = intPoint + -1.0;\n        float idx1 = intPoint +  0.0;\n        float idx2 = intPoint +  1.0;\n        float idx3 = intPoint +  2.0;\n\n        vec3 pt0 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx0);\n        vec3 pt1 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx1);\n        vec3 pt2 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx2);\n        vec3 pt3 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx3);\n\n        vec3 pointoutput = catmullRom_${textureName}_${lineIdx}(pt0, pt1, pt2, pt3, weight);\n\n        return pointoutput;\n      }\n      `\n\n      // console.log(res);\n      return res\n    }\n\n    let getLinesPointAtT = () => {\n      let str = `\n          if (false) {}`\n      for (let i = 0; i < this.sim.HEIGHT; i++) {\n        str += `\n          else if (lineIDXER == ${i.toFixed(1)}) {\n            pt += getPointAt_${i.toFixed(0)}(t);\n          }\n        `\n      }\n      // console.log(str);\n\n      return str\n    }\n\n    let pointLineMaker = () => {\n      let str = ''\n      for (let i = 0; i < this.sim.HEIGHT; i++) {\n        str +=\n          getPointAtByT({\n            lineIdx: i,\n            lineCount: this.sim.HEIGHT,\n            controlPointsResolution: subdivisions,\n            textureName: 'posTexture'\n          }) + '\\n'\n      }\n      return str\n    }\n\n    let matLine0 = new ShaderMaterial({\n      uniforms: {\n        tailColor: { value: this.color },\n        time: { value: 0 },\n        matcap: {\n          value: null\n          // value: new TextureLoader().load(\"/matcap/golden2.png\"),\n          // value: await node.ready.RainbowTexture,\n        },\n        posTexture: { value: null }\n        // handTexture: { value: null },\n      },\n      vertexShader: /* glsl */ `\n        // #include <common>\n        #define lengthSegments ${subdivisions.toFixed(1)}\n\n        attribute float angle;\n        attribute float newPosition;\n        attribute float tubeInfo;\n\n        // varying vec2 vUv;\n        varying vec3 vNormal;\n        attribute vec4 offset;\n\n        uniform sampler2D posTexture;\n        // uniform sampler2D handTexture;\n\n        uniform float time;\n\n        mat4 rotationX( in float angle ) {\n          return mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n                  0, \tcos(angle),\t-sin(angle),\t\t0,\n                  0, \tsin(angle),\t cos(angle),\t\t0,\n                  0, \t\t\t0,\t\t\t  0, \t\t1);\n        }\n\n        mat4 rotationY( in float angle ) {\n          return mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n                      0,\t\t1.0,\t\t\t 0,\t0,\n                  -sin(angle),\t0,\t\tcos(angle),\t0,\n                      0, \t\t0,\t\t\t\t0,\t1);\n        }\n\n        mat4 rotationZ( in float angle ) {\n          return mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n                  sin(angle),\t\tcos(angle),\t\t0,\t0,\n                      0,\t\t\t\t0,\t\t1,\t0,\n                      0,\t\t\t\t0,\t\t0,\t1);\n        }\n\n        mat4 rotationMatrix (vec3 axis, float angle) {\n            axis = normalize(axis);\n            float s = sin(angle);\n            float c = cos(angle);\n            float oc = 1.0 - c;\n\n            return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                        0.0,                                0.0,                                0.0,                                1.0);\n        }\n\n        ${pointLineMaker()}\n\n        vec3 sampleFnc (float t) {\n          vec3 pt = (offset.xyz + 0.5) * 0.0;\n\n          // pt = vec4(vec4(pt, 1.0) * rotationY(t * 0.1 + time * 0.1)).xyz;\n          // if (lineIDXER == 0.0) {\n          //   pt += getPointAt_0(t);\n          // }\n\n          float lineIDXER = offset.w;\n          // pt += getPointAt_0(t);\n\n          ${getLinesPointAtT()}\n\n          // pt = getPointAt_2(t);\n\n          return pt;\n        }\n\n        void createTube (float t, vec2 volume, out vec3 pos, out vec3 normal) {\n          // find next sample along curve\n          float nextT = t + (1.0 / lengthSegments);\n\n          // sample the curve in two places\n          vec3 cur = sampleFnc(t);\n          vec3 next = sampleFnc(nextT);\n\n          // compute the Frenet-Serret frame\n          vec3 T = normalize(next - cur);\n          vec3 B = normalize(cross(T, next + cur));\n          vec3 N = -normalize(cross(B, T));\n\n          // extrude outward to create a tube\n          float tubeAngle = angle;\n          float circX = cos(tubeAngle);\n          float circY = sin(tubeAngle);\n\n          // compute position and normal\n          normal.xyz = normalize(B * circX + N * circY);\n          pos.xyz = cur + B * volume.x * circX + N * volume.y * circY;\n        }\n\n        varying float vT;\n        varying vec3 vViewPosition;\n\n        void main (void) {\n          vec3 transformed;\n          vec3 objectNormal;\n\n          float t = tubeInfo + 0.5;\n\n          vT = t;\n\n          vec2 volume = vec2(0.0333, 0.0333);\n          createTube(t, volume, transformed, objectNormal);\n\n          vec3 transformedNormal = normalMatrix * objectNormal;\n          vNormal = normalize(transformedNormal);\n\n          // vUv = uv.yx;\n\n          vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n          vViewPosition = -mvPosition.xyz;\n        }\n      `,\n      fragmentShader: /* glsl */ `\n        varying float vT;\n        // varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vViewPosition;\n        // uniform sampler2D matcap;\n        uniform vec3 tailColor;\n        void main (void) {\n\n          // vec3 viewDir = normalize( vViewPosition );\n          // vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n          // vec3 y = cross( viewDir, x );\n          // vec2 uv = vec2( dot( x, vNormal ), dot( y, vNormal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n          // vec4 matcapColor = texture2D( matcap, uv );\n\n          gl_FragColor = vec4(tailColor, (1.0 - vT));\n        }\n      `,\n      transparent: true,\n      // blending: AdditiveBlending,\n      depthTest: false\n    })\n\n    let line0 = new Mesh(geometry, matLine0)\n    line0.frustumCulled = false\n    line0.userData.enableBloom = true\n\n    mounter.add(line0)\n    node.onClean(() => {\n      mounter.remove(line0)\n    })\n\n    this.sim.wait.then(() => {\n      node.onLoop(() => {\n        let result = this.sim.getTextureAfterCompute()\n        matLine0.uniforms.posTexture.value = result.posTexture\n        matLine0.uniforms.time.value = window.performance.now() / 1000\n      })\n    })\n  }\n\n  // async enableMousePlane() {\n  //   let raycaster = await node.ready.raycaster;\n  //   let mouse = await node.ready.mouse;\n  //   let camera = await node.ready.camera;\n  //   let viewport = await node.ready.viewport;\n\n  //   let geoPlane = new PlaneBufferGeometry(\n  //     2.0 * viewport.width,\n  //     2.0 * viewport.height,\n  //     2,\n  //     2\n  //   );\n\n  //   let matPlane = new MeshBasicMaterial({\n  //     transparent: true,\n  //     opacity: 0.25,\n  //     color: 0xff0000,\n  //   });\n\n  //   let planeMesh = new Mesh(geoPlane, matPlane);\n  //   planeMesh.position.z = -camera.position.z / 2;\n\n  //   scene.add(planeMesh);\n  //   node.onClean(() => {\n  //     scene.remove(planeMesh);\n  //   });\n\n  //   let temppos = new Vector3();\n  //   node.onLoop(() => {\n  //     planeMesh.lookAt(camera.position);\n  //     raycaster.setFromCamera(mouse, camera);\n  //     let res = raycaster.intersectObject(planeMesh);\n  //     if (res && res[0]) {\n  //       temppos.copy(res[0].point);\n  //     }\n  //   });\n  // }\n\n  // enableHandTexture() {\n  //   const width = this.sim.WIDTH\n  //   const height = this.sim.HEIGHT\n  //   const size = width * height\n\n  //   let handMovement = []\n  //   let temppos = new Vector3()\n  //   for (let i = 0; i < size; i++) {\n  //     AvatarHead.getWorldPosition(temppos)\n\n  //     let x = temppos.x || 0\n  //     let y = temppos.y || 0\n  //     let z = temppos.z || 0\n  //     //\n  //     handMovement.unshift(x, y, z)\n  //   }\n\n  //   const textureArray = new Uint16Array(3 * size)\n  //   const handTexture = new DataTexture(\n  //     textureArray,\n  //     width,\n  //     height,\n  //     RGBFormat,\n  //     HalfFloatType\n  //   )\n  //   handTexture.needsUpdate = true\n\n  //   node.onLoop(() => {\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.x) || 0)\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.y) || 0)\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.z) || 0)\n\n  //     handMovement.shift()\n  //     handMovement.shift()\n  //     handMovement.shift()\n\n  //     textureArray.set(handMovement, 0)\n  //     handTexture.needsUpdate = true\n  //     mat.uniforms.handTexture.value = handTexture\n  //   })\n  // }\n}\n\nclass NoodleGeo {\n  constructor(props) {\n    let {\n      count = 20,\n      numSides = 4,\n      subdivisions = 50,\n      openEnded = true\n    } = props\n    const radius = 1\n    const length = 1\n\n    const cylinderBufferGeo = new CylinderBufferGeometry(\n      radius,\n      radius,\n      length,\n      numSides,\n      subdivisions,\n      openEnded\n    )\n\n    let baseGeometry = new Geometry()\n    baseGeometry = baseGeometry.fromBufferGeometry(cylinderBufferGeo)\n\n    baseGeometry.rotateZ(Math.PI / 2)\n\n    // compute the radial angle for each position for later extrusion\n    const tmpVec = new Vector2()\n    const xPositions = []\n    const angles = []\n    const uvs = []\n    const vertices = baseGeometry.vertices\n    const faceVertexUvs = baseGeometry.faceVertexUvs[0]\n    const oPositions = []\n\n    // Now go through each face and un-index the geometry.\n    baseGeometry.faces.forEach((face, i) => {\n      const { a, b, c } = face\n      const v0 = vertices[a]\n      const v1 = vertices[b]\n      const v2 = vertices[c]\n      const verts = [v0, v1, v2]\n      const faceUvs = faceVertexUvs[i]\n\n      // For each vertex in this face...\n      verts.forEach((v, j) => {\n        tmpVec.set(v.y, v.z).normalize()\n\n        // the radial angle around the tube\n        const angle = Math.atan2(tmpVec.y, tmpVec.x)\n        angles.push(angle)\n\n        // \"arc length\" in range [-0.5 .. 0.5]\n        xPositions.push(v.x)\n        oPositions.push(v.x, v.y, v.z)\n\n        // copy over the UV for this vertex\n        uvs.push(faceUvs[j].toArray())\n      })\n    })\n\n    // build typed arrays for our attributes\n    const posArray = new Float32Array(xPositions)\n    const angleArray = new Float32Array(angles)\n    const uvArray = new Float32Array(uvs.length * 2)\n\n    const origPosArray = new Float32Array(oPositions)\n\n    // unroll UVs\n    for (let i = 0; i < posArray.length; i++) {\n      const [u, v] = uvs[i]\n      uvArray[i * 2 + 0] = u\n      uvArray[i * 2 + 1] = v\n    }\n\n    const lineGeo = new InstancedBufferGeometry()\n    lineGeo.instanceCount = count\n\n    lineGeo.setAttribute('position', new BufferAttribute(origPosArray, 3))\n    lineGeo.setAttribute('tubeInfo', new BufferAttribute(posArray, 1))\n    lineGeo.setAttribute('angle', new BufferAttribute(angleArray, 1))\n    lineGeo.setAttribute('uv', new BufferAttribute(uvArray, 2))\n\n    let offset = []\n    let ddxyz = Math.floor(Math.pow(count, 1 / 3))\n    let iii = 0\n    for (let z = 0; z < ddxyz; z++) {\n      for (let y = 0; y < ddxyz; y++) {\n        for (let x = 0; x < ddxyz; x++) {\n          offset.push(\n            0.0, //  * (x / ddxyz) * 2.0 - 1.0,\n            0.0, //  * (y / ddxyz) * 2.0 - 1.0,\n            0.0, //  * (z / ddxyz) * 2.0 - 1.0,\n            iii\n          )\n          iii++\n        }\n      }\n    }\n\n    // let ddxyz = Math.floor(Math.pow(count, 1 / 2));\n    // for (let y = 0; y < ddxyz; y++) {\n    //   for (let x = 0; x < ddxyz; x++) {\n    //     offset.push(0.0, (x / ddxyz) * 2.0 - 1.0, (y / ddxyz) * 2.0 - 1.0);\n    //   }\n    // }\n\n    lineGeo.setAttribute(\n      'offset',\n      new InstancedBufferAttribute(new Float32Array(offset), 4)\n    )\n\n    let eachLineIdx = []\n    for (let c = 0; c < count; c++) {\n      eachLineIdx.push(c)\n    }\n\n    // lineGeo.setAttribute(\n    //   \"lineIDXER\",\n    //   new InstancedBufferAttribute(new Float32Array(eachLineIdx), 1)\n    // );\n\n    return {\n      ...props,\n      dataLength: posArray.length,\n      geometry: lineGeo\n    }\n  }\n}\n\nexport class CursorTrackerTail {\n  constructor({ mini, mounter, cursor, color = new Color('#ffffff') }) {\n    let node = mini\n    let SCAN_COUNT = 8\n    let TAIL_LENGTH = 64\n\n    //\n    let sim = new LokLokWiggleSimulation({\n      node,\n      mounter,\n      numberOfScans: SCAN_COUNT,\n      trailSize: TAIL_LENGTH\n    })\n\n    let display = new LokLokWiggleDisplay({ node, sim, mounter, color })\n    this.display = display\n\n    let trackers = []\n\n    let makeTracker = ({ update, setup }) => {\n      let looker = new Object3D()\n      cursor.add(looker)\n      mini.onClean(() => {\n        cursor.remove(looker)\n      })\n\n      let origin = new Object3D()\n      looker.add(origin)\n      let orbit = new Object3D()\n      origin.add(orbit)\n      let worldPos = new Vector3()\n      let lerpWorldPos = new Vector3()\n\n      setup({ origin, orbit })\n\n      node.onLoop(() => {\n        update({ origin, orbit })\n\n        if (mini.now?.camera) {\n          looker.lookAt(mini.now.camera.position)\n        }\n        orbit.getWorldPosition(worldPos)\n\n        lerpWorldPos.lerp(worldPos, 0.3)\n      })\n      trackers.push(lerpWorldPos)\n    }\n\n    let count = 3\n    for (let i = 0; i < count; i++) {\n      makeTracker({\n        setup: ({ origin, orbit }) => {\n          origin.rotation.z += ((Math.PI * 2.0) / count) * i\n        },\n        update: ({ origin, orbit }) => {\n          origin.rotation.z += 0.1\n          orbit.position.x =\n            0.85 + 0.85 * Math.sin((window.performance.now() / 1000) * 1)\n        }\n      })\n    }\n\n    // let makeCross = () => {\n    //   let looker = new Object3D();\n    //   cursor.add(looker);\n    //   mini.onClean(() => {\n    //     cursor.remove(looker);\n    //   });\n\n    //   let cross1 = new Mesh(\n    //     new BoxBufferGeometry(0.02, 1, 0.02),\n    //     new MeshBasicMaterial({ depthTest: false, color: 0xffffff })\n    //   );\n    //   looker.add(cross1);\n\n    //   let cross2 = new Mesh(\n    //     new BoxBufferGeometry(1, 0.02, 0.02),\n    //     new MeshBasicMaterial({ depthTest: false, color: 0xffffff })\n    //   );\n    //   looker.add(cross2);\n\n    //   cross1.userData.enableBloom = true;\n    //   cross2.userData.enableBloom = true;\n\n    //   looker.scale.setScalar(2.0);\n\n    //   node.onLoop(() => {\n    //     if (mini.now?.camera) {\n    //       looker.lookAt(mini.now.camera.position);\n    //     }\n\n    //     let ss = 2 * Math.sin(Math.PI - window.performance.now() / 1000);\n    //     cross1.scale.setScalar(ss);\n    //     cross2.scale.setScalar(ss);\n    //   });\n    // };\n    // makeCross();\n\n    sim.wait.then(() => {\n      node.onLoop(() => {\n        sim.render({\n          trackers\n        })\n      })\n    })\n  }\n}\n","import { useFrame } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { CursorTrackerTail } from '../lib/CursorTrackerTail'\nimport { Color } from 'three'\n\nexport function TailCursor({ Now, color }) {\n  let { mini } = useMiniEngine()\n  let cursor = useRef()\n\n  let colorObj = useRef(new Color(color))\n\n  useEffect(() => {\n    colorObj.current.set(color)\n  }, [color])\n\n  useEffect(() => {\n    let mouse = cursor.current\n    console.log(123)\n    if (mouse) {\n      mini.ready.scene.then((scene) => {\n        return new CursorTrackerTail({\n          mini,\n          cursor: mouse,\n          mounter: scene,\n          color: colorObj.current\n        })\n      })\n    }\n  }, [])\n\n  // let time = 0\n  useFrame((st, dt) => {\n    // time += dt\n    if (cursor.current) {\n      let mouse = cursor.current\n\n      mouse.position.lerp(Now.cursorPos, 0.2)\n\n      // mouse.scale.setScalar(0.15);\n\n      // mouse.lookAt(\n      //   Now.cursorPos.x + Now.cursorNormal.x,\n      //   Now.cursorPos.y + Now.cursorNormal.y,\n      //   Now.cursorPos.z + Now.cursorNormal.z\n      // );\n\n      mouse.lookAt(st.camera.position)\n    }\n  })\n\n  return <group ref={cursor}>{/*  */}</group>\n}\n","import { useEffect, useRef } from 'react'\n\nimport { useFrame } from '@react-three/fiber'\nimport {\n  Color,\n  Layers,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  MeshMatcapMaterial,\n  MeshPhongMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MeshToonMaterial,\n  ShaderMaterial,\n  sRGBEncoding,\n  Vector2,\n  WebGLRenderTarget\n} from 'three'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass'\n\nexport const ENTIRE_SCENE = 0\nexport const BLOOM_SCENE = 1\nexport const DARK_SCENE = 2\n\nexport const enableBloom = (item) => {\n  item.layers.enable(BLOOM_SCENE)\n}\n\nexport const enableDarken = (item) => {\n  item.layers.enable(DARK_SCENE)\n}\n\nexport class BloomLayer {\n  constructor({ mini }) {\n    let { get } = mini.now\n\n    let reducedRes = 0.75\n    let resBloom = new Vector2()\n    resBloom.copy({\n      x: get().gl.domElement.width,\n      y: get().gl.domElement.height\n    })\n    resBloom.multiplyScalar(reducedRes)\n\n    let EffectComposer =\n      require('three/examples/jsm/postprocessing/EffectComposer').EffectComposer\n    let RenderPass =\n      require('three/examples/jsm/postprocessing/RenderPass').RenderPass\n    let UnrealBloomPass =\n      require('three/examples/jsm/postprocessing/UnrealBloomPass').UnrealBloomPass\n\n    let efComposer = new EffectComposer(get().gl)\n    mini.onResize(() => {\n      efComposer.setPixelRatio(get().gl.getPixelRatio() * reducedRes)\n    })\n\n    let renderPass = new RenderPass(get().scene, get().camera)\n    mini.onResize(() => {\n      resBloom.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n      resBloom.multiplyScalar(reducedRes)\n      renderPass.setSize(resBloom.x, resBloom.y)\n    })\n    efComposer.addPass(renderPass)\n\n    let unrealPass = new UnrealBloomPass(resBloom, 1.5, 1, 0.1)\n    mini.onResize(() => {\n      resBloom.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n      resBloom.multiplyScalar(reducedRes)\n      unrealPass.setSize(resBloom.x, resBloom.y)\n    })\n\n    efComposer.addPass(unrealPass)\n    efComposer.renderToScreen = false\n\n    let dark = new Color('#000000')\n    // let darkMat = new MeshBasicMaterial({ color: 0x000000, skinning: true })\n    let baseLayer = new Layers()\n    baseLayer.disableAll()\n    baseLayer.enable(ENTIRE_SCENE)\n\n    let bloomLayer = new Layers()\n    bloomLayer.disableAll()\n    bloomLayer.enable(BLOOM_SCENE)\n    let darkLayer = new Layers()\n    darkLayer.disableAll()\n    darkLayer.enable(DARK_SCENE)\n\n    let onBeforeCompileForStdMat = (globalDarkening) => (shader) => {\n      shader.uniforms.globalDarkening = globalDarkening\n      let atBegin = `\n        uniform bool globalDarkening;\n\n      `\n      let atEnd = `\n        if (globalDarkening) {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n      `\n\n      shader.fragmentShader = `${atBegin.trim()}\\n${shader.fragmentShader}`\n      shader.fragmentShader = shader.fragmentShader.replace(\n        `#include <dithering_fragment>`,\n        `#include <dithering_fragment>\\n${atEnd.trim()}`\n      )\n    }\n\n    let uniqueMaterialMap = new Map()\n    let setup = () => {\n      let { scene } = get()\n      scene.traverse((it) => {\n        if (\n          it.material &&\n          (it.material instanceof MeshStandardMaterial ||\n            it.material instanceof MeshPhongMaterial ||\n            it.material instanceof MeshBasicMaterial ||\n            it.material instanceof MeshLambertMaterial ||\n            it.material instanceof MeshMatcapMaterial ||\n            it.material instanceof MeshPhysicalMaterial ||\n            it.material instanceof MeshToonMaterial)\n        ) {\n          if (!uniqueMaterialMap.has(it.uuid + it.material.uuid)) {\n            if (it.material?.clone) {\n              it.material = it.material.clone()\n              uniqueMaterialMap.set(it.uuid + it.material.uuid, true)\n            }\n          }\n        }\n      })\n    }\n\n    let enableDarkenMap = new Map()\n\n    let darken = (it) => {\n      // if (!it.text) {\n      //   it.material = darkMat\n      //   darkMat.needsUpdate = true\n      // }\n      // darkMat.needsUpdate = true;\n\n      if (!enableDarkenMap.has(it.uuid)) {\n        if (\n          it.material &&\n          (it.material instanceof MeshStandardMaterial ||\n            it.material instanceof MeshPhongMaterial ||\n            it.material instanceof MeshBasicMaterial ||\n            it.material instanceof MeshLambertMaterial ||\n            it.material instanceof MeshMatcapMaterial ||\n            it.material instanceof MeshPhysicalMaterial ||\n            it.material instanceof MeshToonMaterial)\n        ) {\n          let str = it.material.onBeforeCompile.toString()\n          if (str !== onBeforeCompileForStdMat.toString()) {\n            let globalDarkening = { value: false }\n            it.userData.globalDarkening = globalDarkening\n\n            enableDarkenMap.set(it.uuid, globalDarkening)\n\n            it.material.onBeforeCompile =\n              onBeforeCompileForStdMat(globalDarkening)\n            it.material.needsUpdate = true\n          }\n        }\n      }\n\n      if (enableDarkenMap.has(it.uuid)) {\n        enableDarkenMap.get(it.uuid).value = true\n      }\n    }\n\n    let setBloomSceneMat = () => {\n      let { scene } = get()\n      scene.traverse((it) => {\n        if (it?.userData?.discard) {\n          it.visible = false\n        }\n\n        if (it?.userData?.disableBloom) {\n          it.visible = false\n        }\n\n        if (it.material) {\n          if (it?.userData?.enableDarken) {\n            darken(it)\n          } else if (it?.userData?.enableBloom) {\n          } else if (darkLayer.test(it.layers) || !bloomLayer.test(it.layers)) {\n            darken(it)\n          } else {\n          }\n        }\n      })\n    }\n\n    let renderToTexture = () => {\n      let { scene, clock } = get()\n      let dt = clock.getDelta()\n      let origBG = scene.background\n      scene.background = dark\n      efComposer.render(dt)\n      scene.background = origBG\n    }\n\n    let restore = () => {\n      let { scene } = get()\n\n      scene.traverse((it) => {\n        if (enableDarkenMap.has(it.uuid)) {\n          enableDarkenMap.get(it.uuid).value = false\n        }\n\n        if (it?.userData?.discard) {\n          it.visible = true\n        }\n        if (it?.userData?.disableBloom) {\n          it.visible = true\n        }\n      })\n    }\n\n    this.renderTexture = () => {\n      let { gl } = get()\n      gl.shadowMap.enabled = false\n\n      // bloom with occulsion image\n      setup()\n      setBloomSceneMat()\n      renderToTexture()\n      restore()\n\n      gl.shadowMap.enabled = true\n    }\n    this.getTex = () => {\n      return efComposer.readBuffer.texture\n    }\n  }\n}\n\nexport class BaseLayer {\n  constructor({ mini }) {\n    let { size, gl, get } = mini.now\n\n    let resBase = new Vector2()\n\n    resBase.copy({ x: size.width, y: size.height })\n    resBase.multiplyScalar(gl.getPixelRatio())\n\n    this.rtt = new WebGLRenderTarget(resBase.width, resBase.height, {\n      encoding: sRGBEncoding,\n      generateMipmaps: false\n    })\n    mini.onClean(() => {\n      this.rtt.dispose()\n    })\n    mini.onResize(() => {\n      resBase.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n\n      resBase.multiplyScalar(gl.getPixelRatio())\n\n      this.rtt = new WebGLRenderTarget(resBase.width, resBase.height, {\n        encoding: sRGBEncoding,\n        generateMipmaps: false\n      })\n    })\n\n    this.renderTexture = () => {\n      let { gl, camera, scene } = get()\n\n      // base image\n      let orig = gl.getRenderTarget()\n      gl.setRenderTarget(this.rtt)\n      gl.render(scene, camera)\n      gl.setRenderTarget(orig)\n    }\n\n    this.getTex = () => {\n      return this.rtt.texture\n    }\n  }\n}\n\nexport class Compositor {\n  constructor({ mini }) {\n    //\n    let quadMat = new ShaderMaterial({\n      //\n      uniforms: {\n        bloomDiffuse: { value: null },\n        baseDiffuse: { value: null }\n      },\n\n      //\n      vertexShader: `\n        varying vec2 vUv;\n        void main (void) {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vUv = uv;\n        }\n      `,\n\n      fragmentShader: `\n        uniform sampler2D baseDiffuse;\n        uniform sampler2D bloomDiffuse;\n\n        varying vec2 vUv;\n          void main (void) {\n            vec4 baseDiffuseColor = texture2D(baseDiffuse, vUv);\n            vec4 bloomDiffuseColor = texture2D(bloomDiffuse, vUv);\n\n            gl_FragColor = vec4(baseDiffuseColor.rgb * 1.0,  baseDiffuseColor.a);\n\n            gl_FragColor.r += 0.45 * pow(bloomDiffuseColor.r, 0.75);\n            gl_FragColor.g += 0.45 * pow(bloomDiffuseColor.g, 0.75);\n            gl_FragColor.b += 0.45 * pow(bloomDiffuseColor.b, 0.75);\n          }\n        `\n    })\n\n    let fsQuad = new FullScreenQuad(quadMat)\n\n    this.render = ({ baseTex, bloomTex }) => {\n      let { gl } = mini.now\n      if (gl) {\n        quadMat.uniforms.bloomDiffuse.value = bloomTex\n        quadMat.uniforms.baseDiffuse.value = baseTex\n        fsQuad.render(gl)\n      }\n    }\n  }\n}\n\nexport function SimpleBloomer() {\n  let { mini } = useMiniEngine()\n\n  let looer = useRef(() => {})\n\n  useEffect(() => {\n    mini.ready.get.then(() => {\n      //\n      let base = new BaseLayer({ mini })\n      let bloom = new BloomLayer({ mini })\n      let compositor = new Compositor({ mini })\n\n      //\n      looer.current = () => {\n        base.renderTexture()\n        bloom.renderTexture()\n\n        compositor.render({\n          baseTex: base.getTex(),\n          bloomTex: bloom.getTex()\n        })\n      }\n    })\n  }, [])\n\n  // invalidate orignal loop\n  useFrame(() => {\n    looer.current()\n  }, 1000)\n\n  return null\n}\n","import { Sphere } from '@react-three/drei'\nimport { useFrame } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { DoubleSide } from 'three'\n\nexport function StarSky() {\n  let shaders = {\n    vertexShader: /* glsl */ `\n    varying vec3 vPos;\n    varying vec3 vUv3;\n\n    void main() {\n      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n      gl_Position = projectionMatrix * mvPosition;\n      vPos = position;\n      vUv3 = uv.xyx;\n    }\n    `,\n    fragmentShader: `\n      precision highp float;\n\n      vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n      vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n      float cnoise(vec3 P){\n        vec3 Pi0 = floor(P); // Integer part for indexing\n        vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n        Pi0 = mod(Pi0, 289.0);\n        Pi1 = mod(Pi1, 289.0);\n        vec3 Pf0 = fract(P); // Fractional part for interpolation\n        vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n        vec4 iy = vec4(Pi0.yy, Pi1.yy);\n        vec4 iz0 = Pi0.zzzz;\n        vec4 iz1 = Pi1.zzzz;\n\n        vec4 ixy = permute(permute(ix) + iy);\n        vec4 ixy0 = permute(ixy + iz0);\n        vec4 ixy1 = permute(ixy + iz1);\n\n        vec4 gx0 = ixy0 / 7.0;\n        vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n        gx0 = fract(gx0);\n        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n        vec4 sz0 = step(gz0, vec4(0.0));\n        gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n        gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n        vec4 gx1 = ixy1 / 7.0;\n        vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n        gx1 = fract(gx1);\n        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n        vec4 sz1 = step(gz1, vec4(0.0));\n        gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n        gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n        g000 *= norm0.x;\n        g010 *= norm0.y;\n        g100 *= norm0.z;\n        g110 *= norm0.w;\n        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n        g001 *= norm1.x;\n        g011 *= norm1.y;\n        g101 *= norm1.z;\n        g111 *= norm1.w;\n\n        float n000 = dot(g000, Pf0);\n        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n        float n111 = dot(g111, Pf1);\n\n        vec3 fade_xyz = fade(Pf0);\n        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n        return 2.2 * n_xyz;\n      }\n\n      varying vec3 vPos;\n      uniform float time;\n      varying vec3 vUv3;\n\n      void main() {\n        float speed = time / 3.5;\n        vec3 pp = vUv3.xyx * 600.0;\n        // pp = vPos * 0.25 + speed;\n        float noise = clamp(cnoise(speed + pp / 250.0 + 0.0 ), 0.0, 1.0);\n\n        vec3 colorA = vec3(81.0, 135.0, 228.0) * 0.2 / 255.0;\n        vec3 colorB = vec3(0.0, 150.0, 136.0) * 0.2 / 255.0;\n\n        vec4 backgroundColor = vec4(mix(colorA, colorB, noise), 1.0);\n\n        gl_FragColor = backgroundColor;\n\n        float starNoise = (noise) * pow(cnoise(speed + pp * 2.0) * 0.5 + 0.5, 15.5) * 30.0;\n\n        gl_FragColor.rgb += vec3(pow(starNoise, 1.3)) * 1.5;\n      }\n      `\n  }\n\n  let ref = useRef()\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.needsUpdate = true\n    }\n  }, [shaders, shaders.fragmentShader, shaders.vertexShader])\n\n  let uniforms = useRef({\n    time: { value: 0 }\n  })\n\n  useFrame(() => {\n    uniforms.current.time.value += 1 / 60\n  })\n\n  return (\n    <Sphere\n      frustumCulled={false}\n      userData={{\n        enableBloom: true\n      }}\n      scale={1}\n      args={[800, 20, 20]}\n    >\n      <shaderMaterial\n        ref={ref}\n        uniforms={uniforms.current}\n        fragmentShader={shaders.fragmentShader}\n        vertexShader={shaders.vertexShader}\n        side={DoubleSide}\n      >\n        {/*  */}\n        {/*  */}\n      </shaderMaterial>\n    </Sphere>\n  )\n}\n","import { useTexture } from '@react-three/drei'\nimport { useThree } from '@react-three/fiber'\nimport { useEffect } from 'react'\n\nimport { PMREMGenerator, sRGBEncoding } from 'three'\n\nexport function EnvLightByImage({ imageURL }) {\n  let { scene, gl } = useThree()\n  let texture = useTexture(imageURL)\n  useEffect(() => {\n    const pmremGenerator = new PMREMGenerator(gl)\n    pmremGenerator.compileEquirectangularShader()\n\n    const envMap = pmremGenerator.fromEquirectangular(texture).texture\n    envMap.encoding = sRGBEncoding\n    // scene.background = envMap;\n    scene.environment = envMap\n\n    return () => {\n      scene.environment = null\n      scene.background = null\n    }\n  }, [])\n\n  return null\n}\n","import React from 'react'\nimport { createPortal, useThree } from '@react-three/fiber'\nimport { Text } from '@react-three/drei'\n\nexport function Tooltip({ Now, ...props }) {\n  Now.makeKeyReactive('tooltip')\n  let { camera } = useThree()\n  return createPortal(\n    <group position={[0.03, -0.03, -3]}>\n      <Text\n        anchorX='left'\n        anchorY='top'\n        userData={{ disableBloom: true }}\n        outlineWidth={0.002}\n        fontSize={0.04}\n        {...props}\n      >\n        {Now.hoverData?.website ? 'Click to Open:\\n' : ''}\n        {Now.tooltip || ''}\n      </Text>\n    </group>,\n    camera\n  )\n}\n","import { useFrame, useThree } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { MathUtils } from 'three'\nimport { useAutoEvent } from '../utils/use-auto-event'\n\nexport function TheHelper({ Now }) {\n  return (\n    <group>\n      <TheCursor Now={Now}>\n        {/*  */}\n        {/*  */}\n      </TheCursor>\n      <ClickToOpen Now={Now}>\n        {/*  */}\n        {/*  */}\n      </ClickToOpen>\n\n      <HideCursor>\n        {/*  */}\n        {/*  */}\n      </HideCursor>\n    </group>\n  )\n}\n\nfunction TheCursor({ Now }) {\n  let core = useRef()\n  let orbit = useRef()\n\n  useFrame(({ camera }) => {\n    if (core.current) {\n      core.current.position.copy(camera.position)\n      core.current.rotation.copy(camera.rotation)\n    }\n  })\n\n  return (\n    <group>\n      <group ref={core}>\n        <group ref={orbit} scale={[1, 1, 1]} position={[0, 0, -1]}>\n          {/* <Text\n            fontSize={0.01}\n            outlineColor='black'\n            outlineWidth={0.001}\n            color='white'\n          >\n            +\n          </Text> */}\n          <group scale={0.001} rotation={[0, 0, Math.PI * 0.25]}>\n            <Floating Now={Now}>\n              {/*  */}\n              <mesh position={[0, -9 / 2, 0]}>\n                <coneBufferGeometry args={[4, 9, 3, 1]}></coneBufferGeometry>\n                <meshBasicMaterial color='#000000'></meshBasicMaterial>\n              </mesh>\n              {/*  */}\n              <mesh position={[0, -11, 0]}>\n                <boxBufferGeometry args={[2, 5, 2]}></boxBufferGeometry>\n                <meshBasicMaterial color='#000000'></meshBasicMaterial>\n              </mesh>\n            </Floating>\n          </group>\n        </group>\n      </group>\n    </group>\n  )\n}\n\nfunction Floating({ Now, children }) {\n  const ref = useRef()\n  useFrame(({ clock }) => {\n    let time = clock.getElapsedTime()\n    if (ref.current) {\n      //\n      let target = 0\n      if (Now?.hoverData?.website) {\n        target = -3 + Math.cos(time * 5.0) * 3\n      }\n      ref.current.position.y = MathUtils.lerp(\n        ref.current.position.y,\n        target,\n        0.5\n      )\n    }\n  })\n  //\n  return <group ref={ref}>{children}</group>\n}\n\nfunction ClickToOpen({ Now }) {\n  let { gl } = useThree()\n\n  let move = 0\n  let isDown = false\n  useAutoEvent(\n    'pointerdown',\n    () => {\n      isDown = true\n      move = 0\n    },\n    { passive: false },\n    gl.domElement\n  )\n  useAutoEvent(\n    'pointerup',\n    () => {\n      isDown = false\n    },\n    { passive: false },\n    gl.domElement\n  )\n\n  useAutoEvent(\n    'pointermove',\n    () => {\n      if (isDown) {\n        move++\n      }\n    },\n    { passive: false },\n    gl.domElement\n  )\n\n  useAutoEvent(\n    'pointerup',\n    () => {\n      //\n      if (Now && move <= 10) {\n        if (Now?.hoverData?.website) {\n          let href = document.createElement('a')\n          href.href = Now.hoverData.website\n          href.target = '_blank'\n          href.click()\n        }\n      }\n    },\n    { passive: false },\n    gl.domElement\n  )\n\n  return null\n}\n\nfunction HideCursor() {\n  useAutoEvent(\n    'pointerdown',\n    () => {\n      document.body.style.cursor = 'none'\n    },\n    { passive: false },\n    document.body\n  )\n  useAutoEvent(\n    'pointerup',\n    () => {\n      document.body.style.cursor = 'grabbing'\n    },\n    { passive: false },\n    document.body\n  )\n\n  useEffect(() => {\n    //\n    document.body.style.cursor = 'grabbing'\n\n    return () => {\n      document.body.style.cursor = ''\n      //\n    }\n  }, [])\n  return null\n}\n","import React, { Suspense, useMemo } from 'react'\nimport { Canvas } from '@react-three/fiber'\nimport { useGLTF, PerspectiveCamera } from '@react-three/drei'\nimport {\n  Map3D,\n  UserContorls,\n  TailCursor,\n  SimpleBloomer,\n  StarSky,\n  EnvLightByImage,\n  Tooltip,\n  TheHelper\n} from 'effectnode-3dworld'\nimport { SkeletonUtils } from 'three/examples/jsm/utils/SkeletonUtils'\nimport { Vector3 } from 'three'\n\n//\n// needs trailing slash\nexport const BASE_URL =\n  process.env.NODE_ENV === 'production'\n    ? `https://wonglok.github.io/effectnode-3dworld/`\n    : `/`\n\nconst App = () => {\n  return (\n    <Canvas dpr={[0, 1.5]} style={{ width: '100%', height: '100%' }}>\n      <Suspense fallback={<LoadingScreen></LoadingScreen>}>\n        <Content3D></Content3D>\n      </Suspense>\n    </Canvas>\n  )\n}\n\nfunction Content3D() {\n  let gltf = useGLTF(`${BASE_URL}map/demo-map-000.glb`)\n\n  let { floor, startAt, startLookAt } = useMemo(() => {\n    let floor = SkeletonUtils.clone(gltf.scene)\n    let startAt = new Vector3(0, 0, 0)\n    let startLookAt = new Vector3(0, 0, 0)\n\n    floor.traverse((it) => {\n      if (it) {\n        if (it?.userData?.startAt) {\n          it.getWorldPosition(startAt)\n        }\n        if (it?.userData?.startLookAt) {\n          it.getWorldPosition(startLookAt)\n        }\n      }\n    })\n\n    return { floor, startAt, startLookAt }\n  }, [gltf])\n\n  return (\n    <group>\n      <SimpleBloomer></SimpleBloomer>\n\n      {floor && (\n        <Map3D floor={floor} startLookAt={startLookAt} startAt={startAt}>\n          {({ Now }) => {\n            return (\n              <group>\n                <TailCursor Now={Now} color={'#bababa'}></TailCursor>\n                <UserContorls\n                  higherCamera={1.5}\n                  avatarSpeed={2}\n                  Now={Now}\n                  startAt={startAt}\n                  startLookAt={startLookAt}\n                ></UserContorls>\n                <Tooltip Now={Now}></Tooltip>\n                <TheHelper Now={Now}></TheHelper>\n                <primitive object={floor}></primitive>\n              </group>\n            )\n          }}\n        </Map3D>\n      )}\n\n      <directionalLight position={[10, 10, 10]}></directionalLight>\n      <EnvLightByImage imageURL={`${BASE_URL}image/sky.png`}></EnvLightByImage>\n      <StarSky></StarSky>\n    </group>\n  )\n}\n\nfunction LoadingScreen() {\n  return (\n    <group>\n      <group rotation-x={Math.PI * 0}>\n        <gridHelper args={[150, 50, 0x232323, 0xbababa]}></gridHelper>\n      </group>\n\n      <PerspectiveCamera\n        position={[0, 30, 30]}\n        rotation-x={Math.PI * -0.25}\n        makeDefault={true}\n      ></PerspectiveCamera>\n    </group>\n  )\n}\n\nexport default App\n\n//\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}