{"version":3,"sources":["../../src/utils/make-shallow-store.js","../../src/utils/get-id.js","../../src/lib/Mini.js","../../src/utils/use-mini-engine.js","../../src/utils/use-auto-event.js","../../src/lib/Collider.js","../../src/lib/MapPlayer.js","../../src/compos/Map3D.js","../../src/utils/make-now.js","../../src/lib/CursorTrackerTail.js","../../src/compos/UserContorls.js","../../src/compos/TailCursor.js","../../src/compos/SimpleBloomer.js","../../src/compos/StarSky.js","../../src/compos/EnvLightByImage.js","App.js","index.js"],"names":["makeShallowStore","myObject","___NameSpaceID","Math","Utils","exportJSON","JSON","getNameSpcaeID","onEvent","evName","hh","func","window","makeKeyReactive","useState","vv","setSt","useEffect","s","reloadKey","CustomEvent","detail","Proxy","get","o","set","Mini","parent","this","Promise","ttt","setInterval","clearInterval","resolve","isAborted","num","fnc","intv","clearTimeout","setTimeout","e","isPaused","console","name","duration","start","t","lt","dt","useMiniEngine","useThree","mini","useFrame","st","useAutoEvent","settings","passive","dom","applyAutoEvent","Collider","floor","scene","collider","makeCollider","BufferGeometryUtils","require","environment","SkeletonUtils","geometries","c","cloned","key","it","mergedGeometry","MeshBVH","color","scanCenter","camera","raycaster","center","result","source","first","MapPlayer","startAt","Now","RoundedBoxGeometry","player","transparent","opacity","radius","segment","avatarDir","playerVelocity","tempVector","tempVector2","tempBox","tempMat","tempSegment","rotationCopier","delta","size","capsuleInfo","intersectsBounds","box","intersectsTriangle","triPoint","capsulePoint","distance","tri","depth","direction","newPosition","deltaVector","playerIsOnGround","clock","i","updatePlayer","Map3D","children","colliderRef","useRef","nowRef","mapPlayerRef","colliderManager","moved","goingTo","camAt","avatarAt","avatarHead","avatarRot","avatarFaceLook","avatarLoading","avatarMode","avatarSpeed","keyW","keyA","keyS","keyD","cursorPos","cursorNormal","cursorType","hoverData","isDown","camMode","overlay","profile","user","reload","onlineUID","mapPlayer","hit","object","current","LokLokWiggleSimulation","node","numberOfScans","trailSize","WIDTH","setup","GPUComputationRenderer","gpu","dtPosition","lookUpTexture","value","h","ii","error","positionShader","str","mouseUniforms","lookupRightLine","fillPositionTexture","theArray","texture","y","x","fillLookupTexture","items","lastOneInArray","render","trackers","uniform","getTextureAfterCompute","posTexture","getCurrentRenderTarget","LokLokWiggleDisplay","sim","mounter","count","numSides","subdivisions","openEnded","geometry","getPointAtByT","controlPointsResolution","lineIdx","lineCount","HEIGHT","textureName","floatval","Number","matLine0","uniforms","time","matcap","vertexShader","pointLineMaker","getLinesPointAtT","fragmentShader","blending","depthTest","line0","NoodleGeo","props","cylinderBufferGeo","baseGeometry","tmpVec","xPositions","angles","uvs","vertices","faceVertexUvs","oPositions","a","face","b","verts","faceUvs","v","angle","posArray","Float32Array","angleArray","uvArray","origPosArray","u","lineGeo","offset","ddxyz","iii","z","dataLength","CursorTrackerTail","cursor","display","update","looker","origin","orbit","worldPos","lerpWorldPos","makeTracker","UserContorls","higherCamera","gl","works","ev","orig","fakeCam","OrbitControls","joystick","document","note","manager","zone","mode","position","left","bottom","forward","up","isUsing","nippleAngle","evt","nipple","cte","cts","keyBoardForward","scaler","MathUtils","Object","fov","near","far","rotation-x","makeDefault","TailCursor","mouse","ref","BloomLayer","resBloom","height","EffectComposer","RenderPass","UnrealBloomPass","efComposer","renderPass","unrealPass","dark","darkMat","skinning","baseLayer","bloomLayer","darkLayer","darken","origBG","renderToTexture","BaseLayer","resBase","encoding","generateMipmaps","Compositor","quadMat","bloomDiffuse","baseDiffuse","fsQuad","baseTex","bloomTex","SimpleBloomer","looer","base","bloom","compositor","StarSky","shaders","frustumCulled","userData","enableBloom","scale","args","side","DoubleSide","EnvLightByImage","imageURL","pmremGenerator","loader","envMap","BASE_URL","Content3D","gltf","useGLTF","useMemo","clone","traverse","material","isFloor","App","style","width","fallback","PI","PerspectiveCamera","ReactDOM","getElementById"],"mappings":"yUAEaA,EAAmB,SAACC,QAAkB,IAAlBA,MAAW,IAC1C,IAAIC,ECDF,IACAC,oCADA,GAEAA,oCAHF,GDGIC,EAAQ,CACVC,WAAY,WACV,OAAOC,WAAWA,eAAlB,KAEFC,eAAgB,WACd,UAGFC,QAAS,cACP,IAAIC,EAAS,GAAb,EACIC,EAAK,WACPC,EAAKV,EAALU,KAIF,OADAC,wBAA2BH,EAA3BG,SACO,WACLA,2BAA8BH,EAA9BG,WAIJC,gBAAiB,YACf,MAAkBC,mBAAlB,GAAKC,EAAL,KAASC,EAAT,KACAC,qBAAU,WACR,IAAIR,EAAS,GAAb,EAEIC,EAAK,WACPM,GAAM,YACJ,OAAOE,EAAP,MAKJ,OADAN,wBAA2BH,EAA3BG,SACO,WACLA,2BAA8BH,EAA9BG,YAED,CAbHK,KAgBFE,UAAW,YACTP,qBACE,IAAIQ,YAAelB,EAAnB,MAA4C,CAAEmB,OAAQ,QA+B5D,OA1BY,IAAIC,MAAMrB,EAAU,CAC9BsB,IAAK,cAEH,OAAInB,EAAJ,GACSA,EAAP,GAGKoB,EAAP,IAEFC,IAAK,gBAaH,OAZiBD,EAAjB,KAEA,IACEA,OAEA,qBAAWZ,QACTA,qBACE,IAAIQ,YAAelB,EAAnB,MAA4C,CAAEmB,OAAQ,QAK5D,MEvEOK,EACX,YAAgC,eAAlBC,cAAkB,SAC9BC,KAAA,SACAA,KAAA,SAAgB,IAAhB,IACAA,KAAA,IAAW,YACT,OAAO,IAAIC,SAAQ,YACjB,IAAIC,EAAJ,EACAA,EAAMC,aAAY,WACZ,EAAJ,QACM,mBAAwB,sBAA5B,MACEC,iBACAC,EAAQ,mBAAwB,sBAAhCA,KAGE,eAAJ,KACED,iBACAC,EAAQ,eAARA,YAMVL,KAAA,IAAW,cACT,qBAEFA,KAAA,cAEA,IAAIM,GAAJ,EACAN,KAAA,SACAA,KAAA,eACAA,KAAA,cACAA,KAAA,OAAc,mBAAkB,IAAZO,MAAM,GACpBA,GAAJ,EACE,gBAEA,oBAIJP,KAAA,SAAgB,YACdQ,IACA,uBAGFR,KAAA,QAAe,YACb,sBAGF,IAAIS,EAAJ,EAQAzB,kCAAkC,WANhC0B,gBACAD,EAAOE,YAAW,WAChB,uBAAyB,mBAAOC,SADlCH,YASF,IAAII,GAAJ,EACAb,KAAA,OAAc,WACZa,MAEFb,KAAA,MAAa,WACXa,MAEFb,KAAA,KAAY,WACVa,MAGFb,KAAA,MAAa,WACXM,KACA,IACE,sBAAwB,mBAAOM,OAC/B,MAAOA,GACPE,mBAIJd,KAAA,SAAgBhB,mBAAhB,MACAgB,KAAA,KAAY,WAEV,GADA,UAAehB,mBAAf,MACA,EACE,MAAO,CACL+B,KAAM,EADD,KAELC,SAAU,GAGd,KACE,MAAO,CACLD,KAAM,EADD,KAELC,SAAU,GAGd,IAAMC,EAAQjC,mBAAd,MACA,IACE,IAAIkC,EAAI,EAAR,QACMC,EAAK,EAAX,SACIC,EAAKF,EAAT,EACA,WAAAA,EAEAA,QADAE,SAEA,MACEA,OAGF,iBAAmB,mBAAOR,EAAEM,EAAT,MACnB,MAAON,GACPE,iBAEF,IACME,EADMhC,mBAAZ,MACA,EAEA,MAAO,CACL+B,KAAM,EADD,KAELC,aAIJhB,KAAA,MAAa,IAAIN,MAAM,GAErB,CACEC,IAAK,cACH,OAAO,MAAP,MAINK,KAAA,IAAW,IAAIN,MAAM,GAEnB,CACEC,IAAK,cACH,OAAI,EAAJ,OACS,mBAA0B,sBAAjC,GAEO,eAAP,OCnIL,SAAS0B,IACd,IAAQ1B,EAAQ2B,cAAhB,IACOC,EAAQrC,oBAAS,WACtB,OAAO,IAAIY,EAAX,OADF,GAkBA,OAdAT,qBAAU,WACR,OAAO,WACLkC,aAFJlC,IAMAmC,aAAS,WACP,IAAMC,EAAK9B,IACX,IAAK,IAAL,OACE4B,QAAaE,EAAbF,IAEFA,YAGK,CAAEA,Q,ICtBEG,EAAe,uBAK1B,IAFAC,MAAW,CAAEC,SAAS,IAGtBvC,qBAAU,WAGR,OAFAwC,EAAMA,GAANA,QACAA,wBACO,YACLA,EAAMA,GAANA,QACAA,4BALJxC,KAUWyC,EAAiB,kBAQ5B,YAHA,IADAH,MAAW,CAAEC,SAAS,KAEtBC,EAAMA,GAANA,QACAA,wBACO,YACLA,EAAMA,GAANA,QACAA,2BC1BSE,EAAb,WACE,cAA8B,IAAhBC,EAAgB,EAAhBA,MAAOC,EAAS,EAATA,MACnBjC,KAAA,QACAA,KAAA,OAAc,IAAI,EAAJ,UAAd,GACAA,KAAA,UAAiB,IAAjB,YACAA,KAAA,QAEA,IAAMkC,EAAWlC,KAAjB,eACAA,KAAA,WACAA,KAAA,UATJ,wCAYEmC,WACE,IAAQF,EAAR,WAAeD,EAAf,WACMI,EACJC,MADF,oBAKMC,EAFJD,MADF,cAGoBE,MAApB,GAEMC,EAAN,GAEAF,sBACAA,YAAqB,YACnB,GAAIG,aAAeA,WAAnB,WAA0C,CACxC,IAAMC,EAASD,WAAf,QAGA,IAAK,IAAL,KAFAC,eAAoBD,EAApBC,aAEkBA,EAAlB,WACMC,gBAAJ,UAA0BA,GAExBD,qBAIJF,cAIJP,YAAe,YACb,GAAIW,GAAMA,EAANA,UAAqBA,WAArBA,SAA4CA,EAAhD,SAA6D,CAC3D,IAAMF,EAASE,WAAf,QAIA,IAAK,IAAL,KAHAA,sBAEAF,eAAoBE,EAApBF,aACkBA,EAAlB,WACE,aAAIC,GACFD,qBAGJF,cAIJ,IAAMK,EAAiBT,2BAAvB,GAKAS,aAA4B,IAAIC,EAAJ,EAA5BD,GAEA,IAAMX,EAAW,IAAI,EAAJ,OAEf,IAAI,EAAJ,kBAAsB,CAAEa,MAAO,YAOjC,OALAb,wBACAA,sBACAA,0BACAA,sBAEA,GAvEJ,aA2EEc,YAA8B,IAAjBC,EAAiB,EAAjBA,OAAQhB,EAAS,EAATA,MACXiB,EAAR,eAAmBC,EAAnB,YAA2BjB,EAA3B,cAEAgB,qBACA,IAAME,EAAN,GACMC,EAAN,GACApB,YAAe,YACTW,YAAeA,WAAnB,aACES,aAGJH,2BAEAhB,uCAGEgB,EAHFhB,KAMA,IAAMoB,EAAQF,EAAd,GAEA,WAGE,GAnGN,KCSaG,EACX,YAAwC,IAA1BrB,EAA0B,EAA1BA,SAAUsB,EAAgB,EAAhBA,QAASC,EAAO,EAAPA,IAE/BA,mBACAA,kBAEAzD,KAAA,WACA,IAAM0D,EACJrB,MADF,mBAOMsB,EAAS,IAAI,EAAJ,KACb,IAAID,EAJQ,EACC,EACD,EAEiC,EALhC,KAMb,IAAI,EAAJ,oBAAwB,CAAEE,aAAF,EAAqBC,QAAS,KAExDF,wBARe,IAQfA,GACAA,gBAEAA,cAAqB,CACnBG,OAZa,IAabC,QAAS,IAAI,EAAJ,MAAU,IAAV,UAAyB,IAAI,EAAJ,aAAzB,KAEX/D,KAAA,SAEA2D,mBACAA,gBAEAA,gCACAA,YAAkB,IAAI,EAAJ,WAAgBA,WAAlCA,aAEA,IAAMK,EAAY,IAAlB,UACMC,EAAiB,IAAI,EAAJ,YAAvB,GAEMC,EAAa,IAAnB,UACMC,EAAc,IAApB,UACMC,EAAU,IAAhB,OACMC,EAAU,IAAhB,UACMC,EAAc,IAApB,QACMC,EAAiB,IAAvB,WAGA,cAAyC,IAAjBC,EAAiB,EAAjBA,MAAOb,EAAU,EAAVA,OAE7BM,UAAoBO,EAEpBb,gCAEIA,eAAJ,KAEEA,mBACAF,kBACAA,eACAQ,OAGFD,OAAeP,EAAfO,aAAgCL,EAAhCK,UACAA,MACA,IAAMS,EAAOT,EAAb,SACAA,cACAA,MAEAA,iBAAyBP,EAAzBO,aAEIS,GAAJ,IACEd,kCACAF,wBAEAA,wBAGFE,sBAGA,IAAMe,EAAcf,EAApB,YACAS,cACAC,OAAanC,EAAbmC,sBACAC,OAAiBI,EAAjBJ,SAGAA,qBAA+BX,EAA/BW,6BACAA,mBAA6BX,EAA7BW,6BAGAF,gBAAsBE,EAAtBF,OACAA,gBAAsBE,EAAtBF,KAEAA,iBAAuBM,EAAvBN,QACAA,gBAAsBM,EAAtBN,QAEAlC,kCAAiD,CAC/CyC,iBAAkB,mBAASC,gBAAT,IAElBC,mBAAoB,YAGlB,IAAMC,EAAN,EACMC,EAAN,EAEMC,EAAWC,4BAAjB,GAKA,GAAID,EAAWN,EAAf,OAAmC,CACjC,IAAMQ,EAAQR,SAAd,EACMS,EAAYJ,SAAlB,YAEAT,6BACAA,+BAQN,IAAMc,EAAN,EACAA,OAAiBd,EAAjBc,oBAAiDlD,EAAjDkD,aAGA,IAAMC,EAAN,EACAA,eAAoC1B,EAApC0B,UAGA1B,mBAGAF,gBAAkBE,EAAlBF,UAGAc,gBAA6BZ,EAA7BY,UACAA,SAEEd,UAFFc,EAGEZ,WAHFY,EAIEd,UAJFc,GAOAd,cAAkBc,WAAlBd,EACAA,cAAkBc,WAAlBd,EACAA,cAAkBc,WAAlBd,EAIE4B,IAAgB9G,SAASiG,EAAQP,EAARO,EAD3Bc,KAWErB,cAPAoB,cACApB,qBAEGoB,MAFHpB,KAUJ,IACMsB,EAAQ,IAAd,QAEAvF,KAAA,WAAkB,WAChB,IAAIoB,EAAKmE,EAAT,WACInE,GAAM,EAAV,KACEA,EAAK,EAALA,IAGF,IAAK,IAAIoE,EAAT,EAAgBA,EATlB,EAS6BA,IACzBC,EAAa,CAAEjB,MAAOpD,EAV1B,EAUsCuC,aC/K7B+B,EAAQ,SAAC,GAAiC,IAA/BC,EAA+B,EAA/BA,SAAU3D,EAAqB,EAArBA,MAAOwB,EAAc,EAAdA,QAC/B7D,EAAQ2B,cAAhB,IAGQC,EAASF,IAAjB,KACMuE,EAAcC,mBACdC,EAASD,mBACTE,EAAeF,mBAyCrB,OAxCAxG,qBAAU,WAER,IAAM2G,EAAmBJ,UAAsB,IAAI,EAAS,CAC1D5D,MAD0D,EAE1DC,MAAOtC,IAAMsC,QAGTwB,EAAOqC,UClBR1H,EAAiB,CAEtB6H,MAFsB,EAGtBC,QAAS,IAHa,UAItBC,MAAO,IAJe,UAKtBC,SAAU,IALY,UAMtBC,WAAY,IANU,UAOtBC,UAAW,IAPW,UAQtBC,eAAgB,IARM,UAStBC,eATsB,EAUtBC,WAVsB,WAWtBC,YAXsB,EAatBC,MAbsB,EActBC,MAdsB,EAetBC,MAfsB,EAgBtBC,MAhBsB,EAiBtBC,UAAW,IAjBW,UAkBtBC,aAAc,IAlBQ,UAmBtBC,WAnBsB,OAoBtBC,WApBsB,EAqBtBC,QArBsB,EAyBtBC,QAzBsB,QA2BtBC,QA3BsB,GA6BtBC,SA7BsB,EA8BtBC,MA9BsB,EAgCtBC,OAhCsB,GAiCtBC,UAAW,KDbLC,EAAa3B,UAAuB,IAAI,EAAU,CACtD7D,SAAU8D,EAD4C,SAEtDxC,QAFsD,EAGtDC,QAmBF,OAhBAlC,UAAY,WAAM,MAS6B,EAR7C,EAA0B5B,IAAlBsD,EAAR,SAAgBhB,EAAhB,QACM0F,EAAM3B,EAAA,WAA2B,CAAE/C,OAAF,EAAUhB,WAEjD,IACEwB,iBAAmBkE,EAAnBlE,OACAA,oBAAsBkE,OAAtBlE,SAGEA,sBAAkBkE,QAAlBlE,IAAkBkE,GAAlBlE,UAAkBkE,EAAlBlE,2BAAkBkE,EAAtB,aACElE,aAAgB,OAAAkE,QAAG,IAAHA,GAAA,UAAAA,EAAA,wCAAhBlE,MAGFiE,kBAGK,WACLnG,aAhCJlC,IAyCE,+BACE,+BAAWuI,OAAQ5F,IAIlB8D,+BACQH,GACPA,EAAS,CAAElC,IAAKqC,EAAO+B,Y,mNE1CzBC,aACJ,cAA0D,IAA5CC,EAA4C,EAA5CA,KAA4C,IAAtCC,qBAAsC,MAAtB,GAAsB,MAAlBC,iBAAkB,MAAN,GAAM,EACxDjI,KAAA,OACAA,KAAA,QACAA,KAAA,SACAA,KAAA,MAAaA,KAAKkI,MAAQlI,KAA1B,OACAA,KAAA,OAAc,IAAI,EAAJ,YAAd,GACAA,KAAA,KAAYA,KAAKmI,MAAM,CAAEJ,S,2BAGrBI,kB,IAAQJ,S,IAAQ,kCACCA,QADD,uBAGT,MAAW,IAAIK,EAAJ,EACpB,EADoB,MAEpB,EAFoB,OAAtB,IAMAC,6BAEA,IAAMC,EAAa,MAAnB,gBACMC,EAAgB,MAAtB,gBACA,yBACA,uBAEA,mBAAwB,oCAEtB,EAFsB,iBAAxB,GAKA,8BAAiC,EAAjC,iBAAwD,CACtD,EADF,mBAIA,mBAAwB,4BAAxB,SACA,0BAA+B,CAAEC,MAAOD,GAGxC,IADA,IAAIE,EAAI,EAAR,OACSC,EAAT,EAAiBA,EAAjB,EAAyBA,IACvB,mBAAsB,QAAtB,GAAsC,CAAEF,MAAO,IAAI,EAAJ,gBAGjD,wBAA6B,CAAEA,MAAO,GACtCF,yBACAA,yBAGA,IAAMK,EAAQ,MAAd,OAtCoB,OAuChBA,GACF7H,oBAEH,S,6BAED8H,0BAAiB,WAyBf,iBAXoB,WAGlB,IAFA,IAAIC,EAAJ,GACIJ,EAAI,EAAR,OACSC,EAAT,EAAiBA,EAAjB,EAAyBA,IACvBG,GAAO,iCACeH,UADnB,GAAHG,cAKF,SAGEC,GADJ,2qBAxBsB,WAGpB,IAFA,IAAID,EAAJ,gBACIJ,EAAI,EAAR,OACSC,EAAT,EAAiBA,EAAjB,EAAyBA,IACvBG,GAAO,uCACqBH,UADzB,kDAE4BA,UAF5B,GAAHG,iCAMF,SAmCME,GArBR,iL,EAgCFC,gCAIE,IAHA,IAAIxD,EAAJ,EACMyD,EAAWC,QAAjB,KAESC,EAAT,EAAgBA,EAAInJ,KAApB,OAAiCmJ,IAC/B,IAAK,IAAIC,EAAT,EAAgBA,EAAIpJ,KAApB,MAAgCoJ,IAC9BH,EAASzD,KAATyD,EACAA,EAASzD,KAATyD,EACAA,EAASzD,KAATyD,EACAA,EAASzD,KAATyD,EAGJC,kB,EAGFG,8BAKE,IAJA,IAAI7D,EAAJ,EACMyD,EAAWC,QAAjB,KACII,EAAJ,GAESH,EAAT,EAAgBA,EAAInJ,KAApB,OAAiCmJ,IAC/B,IAAK,IAAIC,EAAT,EAAgBA,EAAIpJ,KAApB,MAAgCoJ,IAAK,CACnC,IAAIG,EAAiBD,EAAMA,SAANA,IAA2B,CAAC,EAAjD,GACAL,EAASzD,KAAO+D,EAAhBN,GACAA,EAASzD,KAAO+D,EAAhBN,GACAA,EAASzD,KAAOxF,KAAhBiJ,MACAA,EAASzD,KAAOxF,KAAhBiJ,OACAK,OAAW,CAACF,EAAIpJ,KAAL,MAAiBmJ,EAAInJ,KAAhCsJ,SAGJJ,kB,EAGFM,mBAAqB,WAAZC,EAAY,EAAZA,SACPzJ,KAAA,4BAAmChB,yBAAnC,IAEAyK,WAAiB,cACf,IAAIC,EAAU,mBAAsB,QAApC,GACIA,GAAWA,EAAf,OACEA,mBAKJ1J,KAAA,e,EAGF2J,kCACE,MAAO,CACLC,WAAY5J,KAAKqI,IAAIwB,uBAAuB7J,KAAhC,kBAAuDkJ,U,EAhKnEpB,GAqKAgC,aACJ,cAAoC,IAAtB/B,EAAsB,EAAtBA,KAAMgC,EAAgB,EAAhBA,IAAKC,EAAW,EAAXA,QACvBhK,KAAA,UACAA,KAAA,OACAA,KAAA,MACAA,KAAA,KAAYA,KAAKmI,MAAM,CAAEJ,S,mBAGrBI,kB,IAAQJ,S,IAAQ,WAChBiC,EAAU,EAAd,QAKA,EAAwC,IAAI,EAAU,CACpDC,MAAO,MAD6C,OAEpDC,SAFoD,EAGpDC,aAHoD,EAGtC,YACdC,WAAW,IAJPC,EAAN,WAAgBF,EAAhB,eAA8BF,EAA9B,QAOAI,kBAEA,IAAIC,EAAgB,SAAC,GAKf,QAJJC,+BAII,MAJsB,GAItB,MAHJC,eAGI,MAHM,EAGN,MAFJC,iBAEI,MAFQ,MAASC,OAEjB,MADJC,mBACI,MADU,iBACV,EACJJ,EAA0BhM,WAA1BgM,GAEA,IAAIK,EAAW,GAAGC,kBAAlB,GAwDA,MAtDU,yBAAH,MACwBL,UADxB,wIAMSD,UANT,qBAOCC,UAPD,SAOyBC,UAPzB,+dAyBWD,UAzBX,+dA0CgCA,UA1ChC,iDA2CgCA,UA3ChC,iDA4CgCA,UA5ChC,iDA6CgCA,UA7ChC,+DAAP,iFAsFEM,EAAW,IAAI,EAAJ,eAAmB,CAChCC,SAAU,CACRC,KAAM,CAAExC,MAAO,GACfyC,OAAQ,CACNzC,MAAO,MAIToB,WAAY,CAAEpB,MAAO,OAGvB0C,aAAc,kEAEaf,UAFf,i3DAzBO,WAEnB,IADA,IAAItB,EAAJ,GACSrD,EAAT,EAAgBA,EAAI,MAApB,OAAqCA,IACnCqD,GACEyB,EAAc,CACZE,QADY,EAEZC,UAAW,MAFC,OAGZF,wBAHY,EAIZI,YAAa,eALjB9B,KAQF,SAgEIsC,GAlDQ,iWAxCS,WAGrB,IAFA,IAAItC,EAAJ,4BAESrD,EAAT,EAAgBA,EAAI,MAApB,OAAqCA,IACnCqD,GAAO,qCACmBrD,UADvB,wCAEoBA,UAFpB,GAAHqD,8BAQF,SA2FMuC,GA1E0B,gjDAgIhCC,eAhIgC,qoBAkJhCzH,aAlJgC,EAmJhC0H,SAnJgC,mBAoJhCC,WAAW,IAGTC,EAAQ,IAAI,EAAJ,OAAZ,GAtQoB,OAuQpBA,mBACAA,0BAEAxB,SACAjC,WAAa,WACXiC,eAGF,iBAAmB,WACjBjC,UAAY,WACV,IAAI3E,EAAS,MAAb,yBACA0H,4BAAqC1H,EAArC0H,WACAA,sBAA+B9L,yBAA/B8L,UAnRgB,kBAsRrB,S,6BA9RGhB,GAiXA2B,EACJ,YACE,MAKIC,EALJ,MACEzB,OADF,aAKIyB,EALJ,SAEExB,OAFF,YAKIwB,EALJ,aAGEvB,OAHF,aAKIuB,EALJ,UAIEtB,OAJF,SASMuB,EAAoB,IAAI,EAAJ,uBAH1B,IACA,EAE0B,IAA1B,GASIC,EAAe,IAAnB,KACAA,EAAeA,qBAAfA,IAEAA,QAAqBrN,QAArBqN,GAGA,IAAMC,EAAS,IAAf,UACMC,EAAN,GACMC,EAAN,GACMC,EAAN,GACMC,EAAWL,EAAjB,SACMM,EAAgBN,gBAAtB,GACMO,EAAN,GAGAP,iBAA2B,cACzB,IAAQQ,EAAYC,EAApB,EAAWC,EAASD,EAApB,EAAc5J,EAAM4J,EAApB5J,EAIM8J,EAAQ,CAHHN,EAAX,GACWA,EAAX,GACWA,EAAXxJ,IAEM+J,EAAUN,EAAhB,GAGAK,WAAc,cACZV,MAAWY,EAAXZ,EAAgBY,EAAhBZ,eAGA,IAAMa,EAAQnO,WAAWsN,EAAXtN,EAAqBsN,EAAnC,GACAE,UAGAD,OAAgBW,EAAhBX,GACAK,OAAgBM,EAAhBN,EAAqBM,EAArBN,EAA0BM,EAA1BN,GAGAH,OAASQ,KAATR,iBAYJ,IAPA,IAAMW,EAAW,IAAIC,aAArB,GACMC,EAAa,IAAID,aAAvB,GACME,EAAU,IAAIF,aAApB,EAAiCZ,UAE3Be,EAAe,IAAIH,aAAzB,GAGSpH,EAAT,EAAgBA,EAAImH,EAApB,OAAqCnH,IAAK,CACxC,MAAewG,EAAf,GAAOgB,EAAP,KAAUP,EAAV,KACAK,EAAQtH,IAARsH,KACAA,EAAQtH,IAARsH,KAGF,IAAMG,EAAU,IAAhB,0BACAA,kBAEAA,0BAAiC,IAAI,EAAJ,kBAAjCA,IACAA,0BAAiC,IAAI,EAAJ,kBAAjCA,IACAA,uBAA8B,IAAI,EAAJ,kBAA9BA,IACAA,oBAA2B,IAAI,EAAJ,kBAA3BA,IAKA,IAHA,IAAIC,EAAJ,GACIC,EAAQ5O,WAAWA,WAAgB,EAAvC,IACI6O,EAAJ,EACSC,EAAT,EAAgBA,EAAhB,EAA2BA,IACzB,IAAK,IAAIlE,EAAT,EAAgBA,EAAhB,EAA2BA,IACzB,IAAK,IAAIC,EAAT,EAAgBA,EAAhB,EAA2BA,IACzB8D,gBAMAE,IA2BN,OAfAH,wBAEE,IAAI,EAAJ,yBAA6B,IAAIL,aAAjC,GAFFK,IAeA,QAEEK,WAAYX,EAFd,OAGEtC,SAAU4C,KAKHM,EACX,YAAuC,IAAzBhM,EAAyB,EAAzBA,KAAMyI,EAAmB,EAAnBA,QAASwD,EAAU,EAAVA,OACvBzF,EAAJ,EAKIgC,EAAM,IAAI,EAAuB,CACnChC,KADmC,EAEnCiC,QAFmC,EAGnChC,cAPF,EAQEC,UAPF,KAUIwF,EAAU,IAAI,EAAoB,CAAE1F,KAAF,EAAQgC,IAAR,EAAaC,YACnDhK,KAAA,UAkCA,IAhCA,IAAIyJ,EAAJ,GAhBqC,eAkBnB,SAAC,GAAsB,IAApBiE,EAAoB,EAApBA,OAAQvF,EAAY,EAAZA,MACvBwF,EAAS,IAAb,WACAH,SACAjM,WAAa,WACXiM,eAGF,IAAII,EAAS,IAAb,WACAD,SACA,IAAIE,EAAQ,IAAZ,WACAD,SACA,IAAIE,EAAW,IAAf,UACIC,EAAe,IAAnB,UAEA5F,EAAM,CAAEyF,OAAF,EAAUC,UAEhB9F,UAAY,WAAM,MAChB2F,EAAO,CAAEE,OAAF,EAAUC,UAEjB,UAAItM,EAAJ,kBAAIA,EAAJ,QACEoM,SAAcpM,aAAdoM,UAEFE,sBAEAE,gBAEFtE,UAKAuE,CAAY,CACV7F,MAAO,YAAuB,EAApByF,OACRA,YAAsB,EAACrP,QAJ7B,EAIMqP,GAEFF,OAAQ,YAAuB,IAApBE,EAAoB,EAApBA,OAAQC,EAAY,EAAZA,MACjBD,iBAEAC,aAAmB,EAAItP,SAASS,yBAAhC6O,SARGrI,EAAT,EAAgBA,EADhB,EAC2BA,IAAK,EAAvBA,GAiDTuE,aAAc,WACZhC,UAAY,WACVgC,SAAW,CACTN,oBCxwBH,SAASwE,EAAa,GAA8C,IAA5CxK,EAA4C,EAA5CA,IAA4C,IAAvCiD,mBAAuC,MAAzB,EAAyB,MAAtBwH,oBAAsB,MAAP,IAAO,EACzE,EAAkB5M,cAAZ3B,EAAN,MAAWwO,EAAX,KACIC,EAAQvI,iBAAZ,IAoRA,OAhRAnE,EAAa,cAEX,YACE2M,qBAEF,CAAEzM,SAAS,IAGbF,EAAa,aAEX,YACE2M,qBAEF,CAAEzM,SAAS,IAGbF,EAAa,YAEX,YACE2M,qBAEF,CAAEzM,SAAS,IAGbvC,qBAAU,WACR,IAAIiP,EAAO7K,EAAX,QAGA,OAFAA,kBACAA,gBACO,WACLA,gBACAA,gBAIJ/B,EAAa,WAAW,YAGtB,MAAI2M,QACF5K,WAEF,MAAI4K,QACF5K,WAEF,MAAI4K,QACF5K,WAEF,MAAI4K,QACF5K,cAGJ/B,EAAa,SAAS,YAGpB,MAAI2M,QACF5K,WAEF,MAAI4K,QACF5K,WAEF,MAAI4K,QACF5K,WAEF,MAAI4K,QACF5K,cAIJpE,qBAAU,WACR,IAAI4D,EAAStD,IAAb,OACAsD,UACAA,UACAA,SACAA,2BAEA,IAAIsL,EAAU,IAAd,SACAA,eACA,IAAIV,EAAQ,IAAIW,EAAJ,IAA2BL,EAAvC,YACAN,kBACAA,eACAA,gBAEAA,mBACAA,iBAEA,IAAIY,EAAWC,uBAAf,OAEAA,6BACAD,wMAWA,IAAIE,EAAOD,uBAAX,OACAA,6BACAC,wPAYAA,mCAEA,IACIC,EADWvM,EAAf,IACc,OAAgB,CAC5BwM,KAD4B,EAE5B9L,MAF4B,QAG5B+L,KAH4B,SAI5BC,SAAU,CAAEC,KAAF,OAAgBC,OAAQ,UAGhCC,EAAU,IAAI,EAAJ,YAAd,GACIC,EAAK,IAAI,EAAJ,YAAT,GAEIjP,EAAJ,EACIkP,GAAJ,EACIC,EAAJ,EASAT,6BAAmC,SAAUU,EAAKC,GAAQ,MAC7B,EAA3B,OAAIA,QAAJ,IAAIA,GAAJ,UAAIA,EAAJ,oBAAIA,EAAJ,SACEF,EAAW,OAAGE,QAAH,IAAGA,GAAH,UAAGA,EAAH,0BAAGA,EAAdF,OACAxB,kBAEAuB,KAGA1O,gBACAR,EAAMS,YAAW,WACfyO,OADFlP,SAMJ0O,YAAkB,WAChBS,IACAjB,qBAA2B,WACzBc,sBAGFrB,kBACAuB,QAGF,IAAII,EAAM1N,EACRqM,aADsB,0BAGtB,YACE,IACEN,qBAGJ,CAAEjM,SAAS,IAET6N,EAAM3N,EACRqM,aADsB,4BAGtB,YACE,IACEN,qBAGJ,CAAEjM,SAAS,IAGT8N,EAAkB,IAAI,EAAJ,YAAtB,GACIC,EAAJ,GAyEA,OAvEAvB,gBAAsB,WACpB,IACEc,cACAA,mBAEErB,2BAA0CtP,SAF5C2Q,IAOAS,EADElM,QAAYA,EAAZA,MAAwBA,EAAxBA,MAAoCA,EAAxC,KACWmM,sBAATD,IAESC,qBAATD,IAIElM,EAAJ,MACEiM,WAA2B,EAA3BA,GACAA,aAA2BzM,EAA3ByM,UACAA,MACAjM,qCACSA,EAAJ,MACLiM,OAAqB,EAArBA,OACAA,aAA2BzM,EAA3ByM,UACAA,MAEAjM,qCACSA,EAAJ,MACLiM,UAA0B,EAA1BA,GACAA,aAA2BzM,EAA3ByM,UACAA,MAEAjM,qCACSA,EAAJ,OACLiM,MAAoB,EAApBA,OACAA,aAA2BzM,EAA3ByM,UACAA,MAEAjM,qCAGFA,eAAiBA,EAAjBA,WAQF2K,gBAAsB,WACpB,UAGI3K,eACFA,aAJF,UAQF2K,eAAqB,WACnBP,WAEApK,iBAEAR,aAAoBQ,WAApBR,EACAA,aAAoBQ,aAApBR,EACAA,aAAoBQ,WAApBR,EAEAA,gBAAqBsL,EAArBtL,WAGFQ,uBACO,WACLA,uBACAmL,kCACAA,YACAF,6BAEAD,WACAE,WACAa,IACAC,OAtMJpQ,IA0MAmC,aAAS,WACPqO,cAAczB,EAAdyB,kBAAqC,mBAAOjP,UAG5C,+BAGE,uBACEkP,IADF,GAEEC,KAFF,GAGEC,IAHF,IAIEjB,SAAU,CAAC,EAAG,GAJhB,IAKEkB,cALF,IAKc1R,QACZ2R,aAAW,KCpSZ,SAASC,EAAW,GAAS,IAAP1M,EAAO,EAAPA,IACrBlC,EAASF,IAAf,KACImM,EAAS3H,mBAgCb,OA9BAxG,qBAAU,WACR,IAAI+Q,EAAQ5C,EAAZ,QACA1M,iBACA,GACES,oBAAsB,YACpB,OAAO,IAAI,EAAkB,CAAEA,KAAF,EAAQiM,OAAR,EAAuBxD,QAAS/H,SALnE5C,IAWAmC,aAAS,cAEP,GAAIgM,EAAJ,QAAoB,CAClB,IAAI4C,EAAQ5C,EAAZ,QAEA4C,gBAAoB3M,EAApB2M,cAUAA,SAAa3O,SAAb2O,cAIG,2BAAOC,IAAK7C,ICxBd,IAYM8C,EACX,YAAsB,IAAR/O,EAAQ,EAARA,KACN5B,EAAQ4B,EAAd,QAGIgP,EAAW,IAAf,UACAA,OAAc,CACZnH,EAAGzJ,kBADS,MAEZwJ,EAAGxJ,kBAAoB6Q,SAEzBD,iBANA,KAQA,IAAIE,EACFpO,MADF,eAEIqO,EACFrO,MADF,WAEIsO,EACFtO,MADF,gBAGIuO,EAAa,IAAIH,EAAe9Q,IAApC,IACA4B,YAAc,WACZqP,gBAAyBjR,OAAzBiR,oBAGF,IAAIC,EAAa,IAAIH,EAAW/Q,IAAf,MAA4BA,IAA7C,QACA4B,YAAc,WACZgP,OAAc,CACZnH,EAAGzJ,kBADS,MAEZwJ,EAAGxJ,kBAAoB6Q,SAEzBD,iBA1BF,KA2BEM,UAAmBN,EAAnBM,EAA+BN,EAA/BM,MAEFD,aAEA,IAAIE,EAAa,IAAIH,EAAgBJ,EAAU,EAAG,EAAlD,IACAhP,YAAc,WACZgP,OAAc,CACZnH,EAAGzJ,kBADS,MAEZwJ,EAAGxJ,kBAAoB6Q,SAEzBD,iBArCF,KAsCEO,UAAmBP,EAAnBO,EAA+BP,EAA/BO,MAGFF,aACAA,oBAEA,IAAIG,EAAO,IAAI,EAAJ,MAAX,WACIC,EAAU,IAAI,EAAJ,kBAAsB,CAAEjO,MAAF,EAAmBkO,UAAU,IAC7DC,EAAY,IAAhB,SACAA,eACAA,SAhEG,GAkEH,IAAIC,EAAa,IAAjB,SACAA,eACAA,SAnEG,GAoEH,IAAIC,EAAY,IAAhB,SACAA,eACAA,SArEG,GAuEH,IAAIC,EAAS,SAACzO,GACPA,EAAL,OACEA,aACAoO,mBAsFJhR,KAAA,cAAqB,WACnB,IAAamO,EAAOxO,IAApB,GACAwO,uBAlFgBxO,IAAhB,MAEAsC,UAAe,YACI,UAAbW,EAAJ,WACEA,4BAA+BA,EAA/BA,SACAA,6BAAgCA,WAAhCA,UACAA,6BAAgCA,WAAhCA,UACAA,yBAA4BA,kBAAqB,IAAI,EAAJ,MAAjDA,WACA,UAAIA,EAAJ,iCAAIA,EAAJ,iCAAIA,EAAJ,oBAAIA,EAAJ,QACEA,gCAAmCA,0BAAnCA,WAOUjD,IAAhB,MAEAsC,UAAe,YAAQ,MASrB,GARIW,EAAJ,UACEA,cAGF,OAAIA,QAAJ,IAAIA,GAAJ,UAAIA,EAAJ,uBAAIA,EAAJ,UACEA,cAGEA,EAAJ,SAAiB,SACf,UAAIA,QAAJ,IAAIA,GAAJ,UAAIA,EAAJ,uBAAIA,EAAJ,aAEE,YADAyO,KAEK,OAAIzO,QAAJ,IAAIA,GAAJ,UAAIA,EAAJ,uBAAIA,EAAJ,YACLA,WAAcA,WAAdA,iBACSwO,OAAexO,EAAfwO,UAA8BD,OAAgBvO,EAAlD,QACLyO,KAEAzO,WAAcA,WAAdA,qBAMc,WACpB,MAAuBjD,IAAjBsC,EAAN,QACIb,EADJ,QACA,WACIkQ,EAASrP,EAAb,WACAA,eACA2O,YACA3O,eAuCAsP,GAnCgB5R,IAAhB,MACAsC,UAAe,YAAQ,MACwC,aAAxDW,EAAD,MAAYA,EAAZ,UAA2BA,WAA/B,mBACEA,WAAcA,WAAdA,iBAEIA,eAAE,IAAFA,sDAAuBA,QAAvBA,IAAuBA,GAAvBA,UAAuBA,EAAvBA,uBAAuBA,EAA3B,gBACEA,iBAAoBA,WAApBA,eAGF,OAAIA,QAAJ,IAAIA,GAAJ,UAAIA,EAAJ,uBAAIA,EAAJ,oBACEA,qBAAwBA,WAAxBA,kBACAA,qBAAwBA,WAAxBA,mBAGF,UAAIA,EAAJ,iCAAIA,EAAJ,iCAAIA,EAAJ,oBAAIA,EAAJ,QACEA,gCAAmCA,WAAnCA,uBAGAA,EAAJ,UACEA,cAGF,OAAIA,QAAJ,IAAIA,GAAJ,UAAIA,EAAJ,uBAAIA,EAAJ,UACEA,iBAeJuL,wBAEFnO,KAAA,OAAc,WACZ,OAAO4Q,aAAP,UAKOY,EACX,YAAsB,WAARjQ,EAAQ,EAARA,KACZ,EAAwBA,EAAxB,IAAMkD,EAAN,OAAY0J,EAAZ,KAAgBxO,EAAhB,MAEI8R,EAAU,IAAd,UAEAA,OAAa,CAAErI,EAAG3E,EAAL,MAAiB0E,EAAG1E,EAAK+L,SACtCiB,iBAAuBtD,EAAvBsD,iBAEAzR,KAAA,IAAW,IAAI,EAAJ,kBAAsByR,EAAtB,MAAqCA,EAArC,OAAqD,CAC9DC,SAD8D,eAE9DC,iBAAiB,IAEnBpQ,WAAa,WACX,mBAEFA,YAAc,WACZkQ,OAAa,CACXrI,EAAGzJ,kBADQ,MAEXwJ,EAAGxJ,kBAAoB6Q,SAEzBiB,iBAAuBtD,EAAvBsD,iBAEA,MAAW,IAAI,EAAJ,kBAAsBA,EAAtB,MAAqCA,EAArC,OAAqD,CAC9DC,SAD8D,eAE9DC,iBAAiB,OAIrB3R,KAAA,cAAqB,WACnB,MAA4BL,IAAtBwO,EAAN,KAAUlL,EAAV,SAAkBhB,EAAlB,QAGIqM,EAAOH,EAAX,kBACAA,kBAAmB,EAAnBA,KACAA,cACAA,sBAGFnO,KAAA,OAAc,WACZ,OAAO,MAAP,UAIO4R,EACX,YAAsB,IAARrQ,EAAQ,EAARA,KAERsQ,EAAU,IAAI,EAAJ,eAAmB,CAE/B9G,SAAU,CACR+G,aAAc,CAAEtJ,MAAO,MACvBuJ,YAAa,CAAEvJ,MAAO,OAIxB0C,aAR+B,qLAgB/BG,eAAgB,ulBAkBd2G,EAAS,IAAI,EAAJ,EAAb,GAEAhS,KAAA,OAAc,YAA2B,IAAxBiS,EAAwB,EAAxBA,QAASC,EAAe,EAAfA,SAClB/D,EAAO5M,EAAb,OACA,IACEsQ,gCACAA,+BACAG,eAMD,SAASG,IACd,IAAM5Q,EAASF,IAAf,KAEI+Q,EAAQvM,kBAAO,eA2BnB,OAzBAxG,qBAAU,WACRkC,kBAAoB,WAElB,IAAI8Q,EAAO,IAAI,EAAU,CAAE9Q,SACvB+Q,EAAQ,IAAI,EAAW,CAAE/Q,SACzBgR,EAAa,IAAI,EAAW,CAAEhR,SAGlC6Q,UAAgB,WACdC,kBACAC,kBAEAC,SAAkB,CAChBN,QAASI,EADO,SAEhBH,SAAUI,mBAdlBjT,IAqBAmC,aAAS,WACP4Q,cADF5Q,KAIA,KC1TK,SAASgR,IACd,IAAIC,EAAU,CACZvH,aADY,yPAYZG,eAAgB,0lHAmGdgF,EAAMxK,mBAEVxG,qBAAU,WACJgR,EAAJ,UACEA,4BAED,CAACoC,EAASA,EAAV,eAAkCA,EAJrCpT,eAMA,IAAI0L,EAAWlF,iBAAO,CACpBmF,KAAM,CAAExC,MAAO,KAOjB,OAJAhH,aAAS,WACPuJ,sBAA+B,EAA/BA,MAIA,uBACE2H,eADF,EAEEC,SAAU,CACRC,aAAa,GAEfC,MALF,EAMEC,KAAM,CAAC,IAAK,GAAI,KAEhB,oCACEzC,IADF,EAEEtF,SAAUA,EAFZ,QAGEM,eAAgBoH,EAHlB,eAIEvH,aAAcuH,EAJhB,aAKEM,KAAMC,gBC9IP,SAASC,EAAgB,GAAc,IAAZC,EAAY,EAAZA,SAEhC,EAAoB5R,cAAdW,EAAN,QAAakM,EAAb,KAoBA,OAnBA9O,qBAAU,WACR,IAAM8T,EAAiB,IAAI,EAAJ,eAAvB,GAYA,OAXAA,kCAEa,IAAb,iBAEAC,QAAsB,YACpB,IAAMC,EAASF,yBAAf,QACAE,0BAEApR,mBAGK,WACLA,mBACAA,qBAED,CAjBH5C,IAmBA,K,YCZWiU,EAAQ,gDA0BrB,SAASC,IACP,IAAIC,EAAOC,YAAQ,GAAD,OAAIH,EAAJ,yBAEdtR,EAAQ0R,mBAAQ,WAClB,IAAI1R,EAAQO,gBAAcoR,MAAMH,EAAKvR,OAarC,OAXAD,EAAM4R,UAAS,SAAChR,GACVA,IACEA,EAAGiR,WACLjR,EAAGiR,SAAWjR,EAAGiR,SAASF,SAExB/Q,EAAGyH,WACLzH,EAAG+P,SAASmB,SAAU,OAKrB9R,IACN,CAACwR,IAEJ,OACE,+BACGxR,GACC,kBAAC,EAAD,CAAOA,MAAOA,EAAOwB,QAAS,CAAE4F,EAAG,EAAGD,EAAG,EAAGkE,EAAG,KAC5C,YAAc,IAAX5J,EAAU,EAAVA,IACF,OACE,+BACE,kBAACwK,EAAD,CACEC,aAAc,IACdxH,YAAa,EACbjD,IAAKA,IAEP,kBAAC0M,EAAD,CAAY1M,IAAKA,QAO3B,+BAAWmE,OAAQ5F,IACnB,sCAAkB+M,SAAU,CAAC,GAAI,GAAI,MACrC,kBAACkE,EAAD,CAAiBC,SAAQ,UAAKI,EAAL,mBAGzB,kBAACd,EAAD,MACA,kBAACL,EAAD,OAKS4B,MA1EH,WACV,OACE,kBAAC,IAAD,CAAQC,MAAO,CAAEC,MAAO,OAAQzD,OAAQ,SACtC,kBAAC,WAAD,CACE0D,SAEE,+BACE,2BAAOjE,aAAsB,EAAV1R,KAAK4V,IACtB,gCAAYrB,KAAM,CAAC,IAAK,GAAI,QAAU,aAExC,kBAACsB,EAAA,EAAD,CACErF,SAAU,CAAC,EAAG,GAAI,IAClBkB,cAAuB,IAAX1R,KAAK4V,GACjBjE,aAAa,MAKnB,kBAACqD,EAAD,SC7BRc,IAAS7K,OAAO,kBAAC,EAAD,MAASkF,SAAS4F,eAAe,W","file":"static/js/main.0b8b2c5f.chunk.js","sourcesContent":["import { useEffect, useState } from 'react'\nimport { getID } from './get-id'\nexport const makeShallowStore = (myObject = {}) => {\n  let ___NameSpaceID = getID()\n  let Utils = {\n    exportJSON: () => {\n      return JSON.parse(JSON.stringify(myObject))\n    },\n    getNameSpcaeID: () => {\n      return ___NameSpaceID\n    },\n    /* */\n    onEvent: (key, func) => {\n      let evName = `${___NameSpaceID}`\n      let hh = () => {\n        func(myObject[key])\n      }\n\n      window.addEventListener(`${evName}-${key}`, hh)\n      return () => {\n        window.removeEventListener(`${evName}-${key}`, hh)\n      }\n    },\n\n    makeKeyReactive: (key) => {\n      let [vv, setSt] = useState(0)\n      useEffect(() => {\n        let evName = `${___NameSpaceID}`\n\n        let hh = () => {\n          setSt((s) => {\n            return s + 1\n          })\n        }\n\n        window.addEventListener(`${evName}-${key}`, hh)\n        return () => {\n          window.removeEventListener(`${evName}-${key}`, hh)\n        }\n      }, [vv])\n    },\n\n    reloadKey: (key) => {\n      window.dispatchEvent(\n        new CustomEvent(`${___NameSpaceID}-${key}`, { detail: {} })\n      )\n    }\n  }\n\n  let proxy = new Proxy(myObject, {\n    get: (o, k) => {\n      //\n      if (Utils[k]) {\n        return Utils[k]\n      }\n\n      return o[k]\n    },\n    set: (o, key, val) => {\n      let currentVal = o[key]\n\n      if (currentVal !== val) {\n        o[key] = val\n\n        if (typeof window !== 'undefined') {\n          window.dispatchEvent(\n            new CustomEvent(`${___NameSpaceID}-${key}`, { detail: {} })\n          )\n        }\n      }\n\n      return true\n    }\n  })\n\n  return proxy\n}\n","export const getID = function () {\n  return (\n    '_' +\n    Math.random().toString(36).substr(2, 9) +\n    Math.random().toString(36).substr(2, 9)\n  )\n}\n","export class Mini {\n  constructor({ parent = false }) {\n    this.parent = parent\n    this.resource = new Map()\n    this.get = (k) => {\n      return new Promise((resolve) => {\n        let ttt = 0\n        ttt = setInterval(() => {\n          if (this.parent) {\n            if (this.resource.has(k) || this.parent.resource.has(k)) {\n              clearInterval(ttt)\n              resolve(this.resource.get(k) || this.parent.resource.get(k))\n            }\n          } else {\n            if (this.resource.has(k)) {\n              clearInterval(ttt)\n              resolve(this.resource.get(k))\n            }\n          }\n        })\n      })\n    }\n    this.set = (k, v) => {\n      this.resource.set(k, v)\n    }\n    this.name = 'ENMini'\n\n    let isAborted = false\n    this.tasks = []\n    this.resizeTasks = []\n    this.cleanTasks = []\n    this.onLoop = (fnc, num = 0) => {\n      if (num >= 0) {\n        this.tasks.push(fnc)\n      } else {\n        this.tasks.unshift(fnc)\n      }\n    }\n\n    this.onResize = (fnc) => {\n      fnc()\n      this.resizeTasks.push(fnc)\n    }\n\n    this.onClean = (func) => {\n      this.cleanTasks.push(func)\n    }\n\n    let intv = 0\n    const internalResize = () => {\n      clearTimeout(intv)\n      intv = setTimeout(() => {\n        this.resizeTasks.forEach((e) => e())\n      }, 16.8888)\n    }\n\n    window.addEventListener('resize', () => {\n      internalResize()\n    })\n\n    let isPaused = false\n    this.toggle = () => {\n      isPaused = !isPaused\n    }\n    this.pause = () => {\n      isPaused = true\n    }\n    this.play = () => {\n      isPaused = false\n    }\n\n    this.clean = () => {\n      isAborted = true\n      try {\n        this.cleanTasks.forEach((e) => e())\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    this.lastTime = window.performance.now()\n    this.work = () => {\n      this.timeNow = window.performance.now()\n      if (isAborted) {\n        return {\n          name: this.name,\n          duration: 0\n        }\n      }\n      if (isPaused) {\n        return {\n          name: this.name,\n          duration: 0\n        }\n      }\n      const start = window.performance.now()\n      try {\n        let t = this.timeNow\n        const lt = this.lastTime\n        let dt = t - lt\n        this.lastTime = t\n        dt = dt / 1000\n        t = t / 1000\n        if (dt >= 100) {\n          dt = 100\n        }\n\n        this.tasks.forEach((e) => e(t, dt))\n      } catch (e) {\n        console.error(e)\n      }\n      const end = window.performance.now()\n      const duration = end - start\n\n      return {\n        name: this.name,\n        duration\n      }\n    }\n\n    this.ready = new Proxy(\n      {},\n      {\n        get: (obj, key) => {\n          return this.get(key)\n        }\n      }\n    )\n    this.now = new Proxy(\n      {},\n      {\n        get: (obj, key) => {\n          if (this.parent) {\n            return this.resource.get(key) || this.parent.resource.get(key)\n          } else {\n            return this.resource.get(key)\n          }\n        }\n      }\n    )\n  }\n}\n\n// let mini = new Mini({ name: \"base\", domElement: ref.current, window });\n//\n\n//\n//\n//\n","import { useFrame, useThree } from '@react-three/fiber'\nimport { useEffect, useState } from 'react'\nimport { Mini } from '../lib/Mini'\n\nexport function useMiniEngine() {\n  const { get } = useThree()\n  const [mini] = useState(() => {\n    return new Mini({})\n  })\n\n  useEffect(() => {\n    return () => {\n      mini.clean()\n    }\n  }, [])\n\n  useFrame(() => {\n    const st = get()\n    for (const kn in st) {\n      mini.set(kn, st[kn])\n    }\n    mini.work()\n  })\n\n  return { mini }\n}\n","import { useEffect } from 'react'\n\nexport const useAutoEvent = function (\n  ev,\n  fnc,\n  settings = { passive: false },\n  dom\n) {\n  useEffect(() => {\n    dom = dom || window\n    dom.addEventListener(ev, fnc, settings)\n    return () => {\n      dom = dom || window\n      dom.removeEventListener(ev, fnc)\n    }\n  }, [])\n}\n\nexport const applyAutoEvent = function (\n  dom,\n  ev,\n  fnc,\n  settings = { passive: false }\n) {\n  dom = dom || window\n  dom.addEventListener(ev, fnc, settings)\n  return () => {\n    dom = dom || window\n    dom.removeEventListener(ev, fnc)\n  }\n}\n","import { Mesh, MeshBasicMaterial, Raycaster, Vector2 } from 'three'\nimport { MeshBVH } from 'three-mesh-bvh'\nexport class Collider {\n  constructor({ floor, scene }) {\n    this.floor = floor\n    this.center = new Vector2(0, 0)\n    this.raycaster = new Raycaster()\n    this.scene = scene\n\n    const collider = this.makeCollider()\n    this.collider = collider\n    this.preview = collider\n  }\n\n  makeCollider() {\n    const { scene, floor } = this\n    const BufferGeometryUtils =\n      require('three/examples/jsm/utils/BufferGeometryUtils').BufferGeometryUtils\n    const SkeletonUtils =\n      require('three/examples/jsm/utils/SkeletonUtils').SkeletonUtils\n\n    const environment = SkeletonUtils.clone(floor)\n\n    const geometries = []\n\n    environment.updateMatrixWorld()\n    environment.traverse((c) => {\n      if (c.geometry && !c.userData.isNotFloor) {\n        const cloned = c.geometry.clone()\n        cloned.applyMatrix4(c.matrixWorld)\n\n        for (const key in cloned.attributes) {\n          if (key === 'position' || key === 'index') {\n          } else {\n            cloned.deleteAttribute(key)\n          }\n        }\n\n        geometries.push(cloned)\n      }\n    })\n\n    scene.traverse((it) => {\n      if (it && it.userData && it.userData.isFloor && it.geometry) {\n        const cloned = it.geometry.clone()\n        it.updateMatrixWorld()\n\n        cloned.applyMatrix4(it.matrixWorld)\n        for (const key in cloned.attributes) {\n          if (key !== 'position') {\n            cloned.deleteAttribute(key)\n          }\n        }\n        geometries.push(cloned)\n      }\n    })\n\n    const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(\n      geometries,\n      false\n    )\n\n    mergedGeometry.boundsTree = new MeshBVH(mergedGeometry)\n\n    const collider = new Mesh(\n      mergedGeometry,\n      new MeshBasicMaterial({ color: 0xffffff })\n    )\n    collider.material.wireframe = true\n    collider.material.opacity = 0.5\n    collider.material.transparent = true\n    collider.updateMatrixWorld()\n\n    return collider\n  }\n\n  //\n  scanCenter({ camera, scene }) {\n    const { raycaster, center, collider } = this\n\n    raycaster.setFromCamera(center, camera)\n    const result = []\n    const source = []\n    scene.traverse((it) => {\n      if (it.geometry && it.userData.isHoverable) {\n        source.push(it)\n      }\n    })\n    raycaster.intersectObjects(source, false, result)\n\n    collider.geometry.boundsTree.raycastFirst(\n      collider,\n      raycaster,\n      raycaster.ray\n    )\n\n    const first = result[0]\n\n    if (first) {\n      return first\n    } else {\n      return false\n    }\n  }\n}\n","import {\n  Box3,\n  Clock,\n  Line3,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  Object3D,\n  Vector3\n} from 'three'\n\nexport class MapPlayer {\n  constructor({ collider, startAt, Now }) {\n    //\n    Now.avatarAt.copy(startAt)\n    Now.goingTo.copy(startAt)\n\n    this.collider = collider\n    const RoundedBoxGeometry =\n      require('three/examples/jsm/geometries/RoundedBoxGeometry.js').RoundedBoxGeometry\n    const scale = 1\n    const radius = 1.3 * scale\n    const width = 1 * scale\n    const height = 2 * scale\n    const depth = 1 * scale\n    const player = new Mesh(\n      new RoundedBoxGeometry(width, height, depth, 8, radius),\n      new MeshLambertMaterial({ transparent: true, opacity: 1 })\n    )\n    player.geometry.translate(0, -radius, 0)\n    player.castShadow = true\n\n    player.capsuleInfo = {\n      radius: radius,\n      segment: new Line3(new Vector3(), new Vector3(0, -1.0, 0.0))\n    }\n    this.player = player\n\n    player.position.copy(startAt)\n    player.position.y += 5\n\n    player.geometry.computeBoundingBox()\n    player.collider = new Box3().copy(player.geometry.boundingBox)\n\n    const avatarDir = new Vector3()\n    const playerVelocity = new Vector3(0, 0, 0)\n    // const upVector = new Vector3(0, 1, 0);\n    const tempVector = new Vector3()\n    const tempVector2 = new Vector3()\n    const tempBox = new Box3()\n    const tempMat = new Matrix4()\n    const tempSegment = new Line3()\n    const rotationCopier = new Object3D()\n    let playerIsOnGround = true\n\n    function updatePlayer({ delta, player }) {\n      // fall down\n      playerVelocity.y += delta * -9.8\n\n      player.position.addScaledVector(playerVelocity, delta)\n\n      if (player.position.y <= -50) {\n        // player.position.y = 0;\n        player.position.copy(startAt)\n        Now.goingTo.copy(startAt)\n        Now.goingTo.z += 1\n        playerVelocity.y = 0.0\n      }\n\n      avatarDir.copy(Now.goingTo).sub(player.position)\n      avatarDir.y = 0\n      const size = avatarDir.length()\n      avatarDir.normalize()\n      avatarDir.y = 0\n\n      avatarDir.multiplyScalar(Now.avatarSpeed)\n\n      if (size >= 0.1) {\n        player.position.addScaledVector(avatarDir, 0.04)\n        Now.avatarMode = 'running'\n      } else {\n        Now.avatarMode = 'standing'\n      }\n\n      player.updateMatrixWorld()\n\n      // adjust player position based on collisions\n      const capsuleInfo = player.capsuleInfo\n      tempBox.makeEmpty()\n      tempMat.copy(collider.matrixWorld).invert()\n      tempSegment.copy(capsuleInfo.segment)\n\n      // get the position of the capsule in the local space of the collider\n      tempSegment.start.applyMatrix4(player.matrixWorld).applyMatrix4(tempMat)\n      tempSegment.end.applyMatrix4(player.matrixWorld).applyMatrix4(tempMat)\n\n      // get the axis aligned bounding box of the capsule\n      tempBox.expandByPoint(tempSegment.start)\n      tempBox.expandByPoint(tempSegment.end)\n\n      tempBox.min.addScalar(-capsuleInfo.radius)\n      tempBox.max.addScalar(capsuleInfo.radius)\n\n      collider.geometry.boundsTree.shapecast(collider, {\n        intersectsBounds: (box) => box.intersectsBox(tempBox),\n\n        intersectsTriangle: (tri) => {\n          // check if the triangle is intersecting the capsule and adjust the\n          // capsule position if it is.\n          const triPoint = tempVector\n          const capsulePoint = tempVector2\n\n          const distance = tri.closestPointToSegment(\n            tempSegment,\n            triPoint,\n            capsulePoint\n          )\n          if (distance < capsuleInfo.radius) {\n            const depth = capsuleInfo.radius - distance\n            const direction = capsulePoint.sub(triPoint).normalize()\n\n            tempSegment.start.addScaledVector(direction, depth)\n            tempSegment.end.addScaledVector(direction, depth)\n          }\n        }\n      })\n\n      // get the adjusted position of the capsule collider in world space after checking\n      // triangle collisions and moving it. capsuleInfo.segment.start is assumed to be\n      // the origin of the player model.\n      const newPosition = tempVector\n      newPosition.copy(tempSegment.start).applyMatrix4(collider.matrixWorld)\n\n      // check how much the collider was moved\n      const deltaVector = tempVector2\n      deltaVector.subVectors(newPosition, player.position)\n\n      // adjust the player model\n      player.position.copy(newPosition)\n\n      //\n      Now.avatarAt.copy(player.position)\n      // Now.avatarAt.y += 0.1;\n\n      rotationCopier.position.copy(player.position)\n      rotationCopier.lookAt(\n        //\n        Now.goingTo.x,\n        player.position.y,\n        Now.goingTo.z\n      )\n\n      Now.avatarRot.x = rotationCopier.rotation.x\n      Now.avatarRot.y = rotationCopier.rotation.y\n      Now.avatarRot.z = rotationCopier.rotation.z\n\n      // if the player was primarily adjusted vertically we assume it's on something we should consider gound\n      playerIsOnGround =\n        deltaVector.y > Math.abs(delta * playerVelocity.y * 0.25)\n\n      if (!playerIsOnGround) {\n        deltaVector.normalize()\n        playerVelocity.addScaledVector(\n          deltaVector,\n          -deltaVector.dot(playerVelocity)\n        )\n        //\n      } else {\n        playerVelocity.set(0, 0, 0)\n      }\n    }\n\n    const steps = 4\n    const clock = new Clock()\n\n    this.onSimulate = () => {\n      let dt = clock.getDelta()\n      if (dt >= 1 / 30) {\n        dt = 1 / 30\n      }\n\n      for (let i = 0; i < steps; i++) {\n        updatePlayer({ delta: dt / steps, player })\n      }\n    }\n  }\n}\n","import { useThree } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { Collider } from '../lib/Collider'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { makeNow } from '../utils/make-now'\nimport { MapPlayer } from '../lib/MapPlayer'\n\nexport const Map3D = ({ children, floor, startAt }) => {\n  const { get } = useThree()\n  //\n  //\n  const { mini } = useMiniEngine()\n  const colliderRef = useRef()\n  const nowRef = useRef()\n  const mapPlayerRef = useRef()\n  useEffect(() => {\n    //\n    const colliderManager = (colliderRef.current = new Collider({\n      floor,\n      scene: get().scene\n    }))\n\n    const Now = (nowRef.current = makeNow())\n\n    const mapPlayer = (mapPlayerRef.current = new MapPlayer({\n      collider: colliderManager.collider,\n      startAt,\n      Now\n    }))\n\n    mini.onLoop(() => {\n      const { camera, scene } = get()\n      const hit = colliderManager.scanCenter({ camera, scene })\n\n      if (hit) {\n        Now.cursorPos.copy(hit.point)\n        Now.cursorNormal.copy(hit.face.normal)\n      }\n\n      if (Now.hoverData !== hit?.object?.userData) {\n        Now.hoverData = hit?.object?.userData || null\n      }\n\n      mapPlayer.onSimulate()\n    })\n\n    return () => {\n      mini.clean()\n    }\n  }, [])\n\n  //\n\n  //\n  //\n  return (\n    <group>\n      <primitive object={floor}>\n        {/*  */}\n        {/*  */}\n      </primitive>\n      {nowRef.current &&\n        typeof children === 'function' &&\n        children({ Now: nowRef.current })}\n\n      {/*  */}\n      {/*  */}\n      {/*  */}\n    </group>\n  )\n}\n","import { Vector3 } from 'three'\nimport { makeShallowStore } from './make-shallow-store'\n\nexport const makeNow = () => {\n  return makeShallowStore({\n    //\n    moved: 0,\n    goingTo: new Vector3(),\n    camAt: new Vector3(),\n    avatarAt: new Vector3(),\n    avatarHead: new Vector3(),\n    avatarRot: new Vector3(),\n    avatarFaceLook: new Vector3(),\n    avatarLoading: true,\n    avatarMode: 'standing',\n    avatarSpeed: 1.0,\n\n    keyW: false,\n    keyA: false,\n    keyS: false,\n    keyD: false,\n    cursorPos: new Vector3(),\n    cursorNormal: new Vector3(),\n    cursorType: 'hide',\n    hoverData: false,\n    isDown: false,\n\n    // avatarAtPhy: new Vector3(),\n\n    camMode: 'first',\n\n    overlay: '',\n\n    profile: false,\n    user: false,\n\n    reload: [],\n    onlineUID: []\n  })\n}\n","import {\n  HalfFloatType,\n  Vector3,\n  BufferAttribute,\n  CylinderBufferGeometry,\n  InstancedBufferAttribute,\n  InstancedBufferGeometry,\n  Vector2,\n  RepeatWrapping,\n  ShaderMaterial,\n  Mesh,\n  // DataTexture,\n  // DataUtils,\n  // RGBFormat,\n  AdditiveBlending,\n  Object3D\n} from 'three'\n// import { GPUComputationRenderer } from 'three-stdlib'\nimport { Geometry } from 'three/examples/jsm/deprecated/Geometry.js'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer'\n\nclass LokLokWiggleSimulation {\n  constructor({ node, numberOfScans = 10, trailSize = 32 }) {\n    this.node = node\n    this.WIDTH = trailSize\n    this.HEIGHT = numberOfScans // number of trackers\n    this.COUNT = this.WIDTH * this.HEIGHT\n    this.v3v000 = new Vector3(0, 0, 0)\n    this.wait = this.setup({ node })\n  }\n\n  async setup({ node }) {\n    let renderer = await node.ready.gl\n\n    let gpu = (this.gpu = new GPUComputationRenderer(\n      this.WIDTH,\n      this.HEIGHT,\n      renderer\n    ))\n\n    gpu.setDataType(HalfFloatType)\n\n    const dtPosition = this.gpu.createTexture()\n    const lookUpTexture = this.gpu.createTexture()\n    this.fillPositionTexture(dtPosition)\n    this.fillLookupTexture(lookUpTexture)\n\n    this.positionVariable = this.gpu.addVariable(\n      'texturePosition',\n      this.positionShader(),\n      dtPosition\n    )\n    this.gpu.setVariableDependencies(this.positionVariable, [\n      this.positionVariable\n    ])\n\n    this.positionUniforms = this.positionVariable.material.uniforms\n    this.positionUniforms.lookup = { value: lookUpTexture }\n\n    let h = this.HEIGHT\n    for (let ii = 0; ii < h; ii++) {\n      this.positionUniforms['mouse' + ii] = { value: new Vector3(0, 0, 0) }\n    }\n\n    this.positionUniforms.time = { value: 0 }\n    dtPosition.wrapS = RepeatWrapping\n    dtPosition.wrapT = RepeatWrapping\n\n    //\n    const error = this.gpu.init()\n    if (error !== null) {\n      console.error(error)\n    }\n  }\n\n  positionShader() {\n    let lookupRightLine = () => {\n      let str = `if (false) {}`\n      let h = this.HEIGHT\n      for (let ii = 0; ii < h; ii++) {\n        str += `\n          else if (currentLine == ${ii.toFixed(0)}.0) {\n            gl_FragColor = vec4(mouse${ii.toFixed(0)}, 1.0);\n          }\n        `\n      }\n      return str\n    }\n\n    let mouseUniforms = () => {\n      let str = ``\n      let h = this.HEIGHT\n      for (let ii = 0; ii < h; ii++) {\n        str += `\n          uniform vec3 mouse${ii.toFixed(0)};\n        `\n      }\n\n      return str\n    }\n    return /* glsl */ `\n      ${mouseUniforms()}\n\n      uniform sampler2D lookup;\n      uniform float time;\n\n\t\t\tvoid main()\t{\n        // const float width = resolution.x;\n        // const float height = resolution.y;\n        // float xID = floor(gl_FragCoord.x);\n        // float yID = floor(gl_FragCoord.y);\n\n        vec2 uvCursor = vec2(gl_FragCoord.x, gl_FragCoord.y) / resolution.xy;\n        // vec4 positionHead = texture2D( texturePosition, uvCursor );\n\n        vec4 lookupData = texture2D(lookup, uvCursor);\n        vec2 nextUV = lookupData.xy;\n        float currentIDX = floor(gl_FragCoord.x);\n        float currentLine = floor(gl_FragCoord.y);\n\n        if (floor(currentIDX) == 0.0) {\n          ${lookupRightLine()}\n        } else {\n          vec3 positionChain = texture2D( texturePosition,nextUV ).xyz;\n          gl_FragColor = vec4(positionChain, 1.0);\n        }\n\n\n\t\t\t}\n    `\n  }\n\n  fillPositionTexture(texture) {\n    let i = 0\n    const theArray = texture.image.data\n\n    for (let y = 0; y < this.HEIGHT; y++) {\n      for (let x = 0; x < this.WIDTH; x++) {\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n        theArray[i++] = 0.0\n      }\n    }\n    texture.needsUpdate = true\n  }\n\n  fillLookupTexture(texture) {\n    let i = 0\n    const theArray = texture.image.data\n    let items = []\n\n    for (let y = 0; y < this.HEIGHT; y++) {\n      for (let x = 0; x < this.WIDTH; x++) {\n        let lastOneInArray = items[items.length - 1] || [0, 0]\n        theArray[i++] = lastOneInArray[0]\n        theArray[i++] = lastOneInArray[1]\n        theArray[i++] = this.WIDTH\n        theArray[i++] = this.HEIGHT\n        items.push([x / this.WIDTH, y / this.HEIGHT])\n      }\n    }\n    texture.needsUpdate = true\n  }\n\n  render({ trackers }) {\n    this.positionUniforms.time.value = window.performance.now() / 1000\n\n    trackers.forEach((track, idx) => {\n      let uniform = this.positionUniforms['mouse' + idx]\n      if (uniform && uniform.value) {\n        uniform.value.copy(track)\n        // console.log(idx, track.toArray().join(\"-\"));\n      }\n    })\n\n    this.gpu.compute()\n  }\n\n  getTextureAfterCompute() {\n    return {\n      posTexture: this.gpu.getCurrentRenderTarget(this.positionVariable).texture\n    }\n  }\n}\n\nclass LokLokWiggleDisplay {\n  constructor({ node, sim, mounter }) {\n    this.mounter = mounter\n    this.node = node\n    this.sim = sim\n    this.wait = this.setup({ node })\n  }\n\n  async setup({ node }) {\n    let mounter = this.mounter\n\n    // let camera = await node.ready.camera;\n    // let renderer = await node.ready.gl;\n\n    let { geometry, subdivisions, count } = new NoodleGeo({\n      count: this.sim.HEIGHT,\n      numSides: 4,\n      subdivisions: this.sim.WIDTH * 2,\n      openEnded: false\n    })\n\n    geometry.instanceCount = count\n\n    let getPointAtByT = ({\n      controlPointsResolution = 20,\n      lineIdx = 0,\n      lineCount = this.sim.HEIGHT,\n      textureName = 'CONTROL_POINTS'\n    }) => {\n      controlPointsResolution = Math.floor(controlPointsResolution)\n\n      let floatval = `${Number(controlPointsResolution).toFixed(1)}`\n\n      let res = `\n      vec3 pointIDX_${textureName}_${lineIdx.toFixed(0)} (float index) {\n        vec3 result = vec3(0.0);\n\n        vec4 color = texture2D(${textureName},\n          vec2(\n            index / ${controlPointsResolution.toFixed(1)},\n            ${lineIdx.toFixed(1)} / ${lineCount.toFixed(1)}\n          )\n        );\n\n        result = color.rgb;\n\n        return result;\n      }\n\n      vec3 catmullRom_${textureName}_${lineIdx} (vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n          vec3 v0 = (p2 - p0) * 0.5;\n          vec3 v1 = (p3 - p1) * 0.5;\n          float t2 = t * t;\n          float t3 = t * t * t;\n\n          return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n      }\n\n      vec3 getPointAt_${lineIdx.toFixed(0)} (float t) {\n        bool closed = false;\n        float ll = ${floatval};\n        float minusOne = 1.0;\n        if (closed) {\n          minusOne = 0.0;\n        }\n\n        float p = (ll - minusOne) * t;\n        float intPoint = floor(p);\n        float weight = p - intPoint;\n\n        float idx0 = intPoint + -1.0;\n        float idx1 = intPoint +  0.0;\n        float idx2 = intPoint +  1.0;\n        float idx3 = intPoint +  2.0;\n\n        vec3 pt0 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx0);\n        vec3 pt1 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx1);\n        vec3 pt2 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx2);\n        vec3 pt3 = pointIDX_${textureName}_${lineIdx.toFixed(0)}(idx3);\n\n        vec3 pointoutput = catmullRom_${textureName}_${lineIdx}(pt0, pt1, pt2, pt3, weight);\n\n        return pointoutput;\n      }\n      `\n\n      // console.log(res);\n      return res\n    }\n\n    let getLinesPointAtT = () => {\n      let str = `\n          if (false) {}`\n      for (let i = 0; i < this.sim.HEIGHT; i++) {\n        str += `\n          else if (lineIDXER == ${i.toFixed(1)}) {\n            pt += getPointAt_${i.toFixed(0)}(t);\n          }\n        `\n      }\n      // console.log(str);\n\n      return str\n    }\n\n    let pointLineMaker = () => {\n      let str = ''\n      for (let i = 0; i < this.sim.HEIGHT; i++) {\n        str +=\n          getPointAtByT({\n            lineIdx: i,\n            lineCount: this.sim.HEIGHT,\n            controlPointsResolution: subdivisions,\n            textureName: 'posTexture'\n          }) + '\\n'\n      }\n      return str\n    }\n\n    let matLine0 = new ShaderMaterial({\n      uniforms: {\n        time: { value: 0 },\n        matcap: {\n          value: null\n          // value: new TextureLoader().load(\"/matcap/golden2.png\"),\n          // value: await node.ready.RainbowTexture,\n        },\n        posTexture: { value: null }\n        // handTexture: { value: null },\n      },\n      vertexShader: /* glsl */ `\n        // #include <common>\n        #define lengthSegments ${subdivisions.toFixed(1)}\n\n        attribute float angle;\n        attribute float newPosition;\n        attribute float tubeInfo;\n\n        // varying vec2 vUv;\n        varying vec3 vNormal;\n        attribute vec4 offset;\n\n        uniform sampler2D posTexture;\n        // uniform sampler2D handTexture;\n\n        uniform float time;\n\n        mat4 rotationX( in float angle ) {\n          return mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n                  0, \tcos(angle),\t-sin(angle),\t\t0,\n                  0, \tsin(angle),\t cos(angle),\t\t0,\n                  0, \t\t\t0,\t\t\t  0, \t\t1);\n        }\n\n        mat4 rotationY( in float angle ) {\n          return mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n                      0,\t\t1.0,\t\t\t 0,\t0,\n                  -sin(angle),\t0,\t\tcos(angle),\t0,\n                      0, \t\t0,\t\t\t\t0,\t1);\n        }\n\n        mat4 rotationZ( in float angle ) {\n          return mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n                  sin(angle),\t\tcos(angle),\t\t0,\t0,\n                      0,\t\t\t\t0,\t\t1,\t0,\n                      0,\t\t\t\t0,\t\t0,\t1);\n        }\n\n        mat4 rotationMatrix (vec3 axis, float angle) {\n            axis = normalize(axis);\n            float s = sin(angle);\n            float c = cos(angle);\n            float oc = 1.0 - c;\n\n            return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                        0.0,                                0.0,                                0.0,                                1.0);\n        }\n\n        ${pointLineMaker()}\n\n        vec3 sampleFnc (float t) {\n          vec3 pt = (offset.xyz + 0.5) * 0.0;\n\n          // pt = vec4(vec4(pt, 1.0) * rotationY(t * 0.1 + time * 0.1)).xyz;\n          // if (lineIDXER == 0.0) {\n          //   pt += getPointAt_0(t);\n          // }\n\n          float lineIDXER = offset.w;\n          // pt += getPointAt_0(t);\n\n          ${getLinesPointAtT()}\n\n          // pt = getPointAt_2(t);\n\n          return pt;\n        }\n\n        void createTube (float t, vec2 volume, out vec3 pos, out vec3 normal) {\n          // find next sample along curve\n          float nextT = t + (1.0 / lengthSegments);\n\n          // sample the curve in two places\n          vec3 cur = sampleFnc(t);\n          vec3 next = sampleFnc(nextT);\n\n          // compute the Frenet-Serret frame\n          vec3 T = normalize(next - cur);\n          vec3 B = normalize(cross(T, next + cur));\n          vec3 N = -normalize(cross(B, T));\n\n          // extrude outward to create a tube\n          float tubeAngle = angle;\n          float circX = cos(tubeAngle);\n          float circY = sin(tubeAngle);\n\n          // compute position and normal\n          normal.xyz = normalize(B * circX + N * circY);\n          pos.xyz = cur + B * volume.x * circX + N * volume.y * circY;\n        }\n\n        varying float vT;\n        varying vec3 vViewPosition;\n\n        void main (void) {\n          vec3 transformed;\n          vec3 objectNormal;\n\n          float t = tubeInfo + 0.5;\n\n          vT = t;\n\n          vec2 volume = vec2(0.0333, 0.0333);\n          createTube(t, volume, transformed, objectNormal);\n\n          vec3 transformedNormal = normalMatrix * objectNormal;\n          vNormal = normalize(transformedNormal);\n\n          // vUv = uv.yx;\n\n          vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n          vViewPosition = -mvPosition.xyz;\n        }\n      `,\n      fragmentShader: /* glsl */ `\n        varying float vT;\n        // varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vViewPosition;\n        uniform sampler2D matcap;\n        void main (void) {\n\n          vec3 viewDir = normalize( vViewPosition );\n          vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n          vec3 y = cross( viewDir, x );\n          vec2 uv = vec2( dot( x, vNormal ), dot( y, vNormal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n          vec4 matcapColor = texture2D( matcap, uv );\n\n          gl_FragColor = vec4(vec3(1.0, 1.0, 1.0), (1.0 - vT));\n        }\n      `,\n      transparent: true,\n      blending: AdditiveBlending,\n      depthTest: false\n    })\n\n    let line0 = new Mesh(geometry, matLine0)\n    line0.frustumCulled = false\n    line0.userData.enableBloom = true\n\n    mounter.add(line0)\n    node.onClean(() => {\n      mounter.remove(line0)\n    })\n\n    this.sim.wait.then(() => {\n      node.onLoop(() => {\n        let result = this.sim.getTextureAfterCompute()\n        matLine0.uniforms.posTexture.value = result.posTexture\n        matLine0.uniforms.time.value = window.performance.now() / 1000\n      })\n    })\n  }\n\n  // async enableMousePlane() {\n  //   let raycaster = await node.ready.raycaster;\n  //   let mouse = await node.ready.mouse;\n  //   let camera = await node.ready.camera;\n  //   let viewport = await node.ready.viewport;\n\n  //   let geoPlane = new PlaneBufferGeometry(\n  //     2.0 * viewport.width,\n  //     2.0 * viewport.height,\n  //     2,\n  //     2\n  //   );\n\n  //   let matPlane = new MeshBasicMaterial({\n  //     transparent: true,\n  //     opacity: 0.25,\n  //     color: 0xff0000,\n  //   });\n\n  //   let planeMesh = new Mesh(geoPlane, matPlane);\n  //   planeMesh.position.z = -camera.position.z / 2;\n\n  //   scene.add(planeMesh);\n  //   node.onClean(() => {\n  //     scene.remove(planeMesh);\n  //   });\n\n  //   let temppos = new Vector3();\n  //   node.onLoop(() => {\n  //     planeMesh.lookAt(camera.position);\n  //     raycaster.setFromCamera(mouse, camera);\n  //     let res = raycaster.intersectObject(planeMesh);\n  //     if (res && res[0]) {\n  //       temppos.copy(res[0].point);\n  //     }\n  //   });\n  // }\n\n  // enableHandTexture() {\n  //   const width = this.sim.WIDTH\n  //   const height = this.sim.HEIGHT\n  //   const size = width * height\n\n  //   let handMovement = []\n  //   let temppos = new Vector3()\n  //   for (let i = 0; i < size; i++) {\n  //     AvatarHead.getWorldPosition(temppos)\n\n  //     let x = temppos.x || 0\n  //     let y = temppos.y || 0\n  //     let z = temppos.z || 0\n  //     //\n  //     handMovement.unshift(x, y, z)\n  //   }\n\n  //   const textureArray = new Uint16Array(3 * size)\n  //   const handTexture = new DataTexture(\n  //     textureArray,\n  //     width,\n  //     height,\n  //     RGBFormat,\n  //     HalfFloatType\n  //   )\n  //   handTexture.needsUpdate = true\n\n  //   node.onLoop(() => {\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.x) || 0)\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.y) || 0)\n  //     handMovement.push(DataUtils.toHalfFloat(temppos.z) || 0)\n\n  //     handMovement.shift()\n  //     handMovement.shift()\n  //     handMovement.shift()\n\n  //     textureArray.set(handMovement, 0)\n  //     handTexture.needsUpdate = true\n  //     mat.uniforms.handTexture.value = handTexture\n  //   })\n  // }\n}\n\nclass NoodleGeo {\n  constructor(props) {\n    let {\n      count = 20,\n      numSides = 4,\n      subdivisions = 50,\n      openEnded = true\n    } = props\n    const radius = 1\n    const length = 1\n\n    const cylinderBufferGeo = new CylinderBufferGeometry(\n      radius,\n      radius,\n      length,\n      numSides,\n      subdivisions,\n      openEnded\n    )\n\n    let baseGeometry = new Geometry()\n    baseGeometry = baseGeometry.fromBufferGeometry(cylinderBufferGeo)\n\n    baseGeometry.rotateZ(Math.PI / 2)\n\n    // compute the radial angle for each position for later extrusion\n    const tmpVec = new Vector2()\n    const xPositions = []\n    const angles = []\n    const uvs = []\n    const vertices = baseGeometry.vertices\n    const faceVertexUvs = baseGeometry.faceVertexUvs[0]\n    const oPositions = []\n\n    // Now go through each face and un-index the geometry.\n    baseGeometry.faces.forEach((face, i) => {\n      const { a, b, c } = face\n      const v0 = vertices[a]\n      const v1 = vertices[b]\n      const v2 = vertices[c]\n      const verts = [v0, v1, v2]\n      const faceUvs = faceVertexUvs[i]\n\n      // For each vertex in this face...\n      verts.forEach((v, j) => {\n        tmpVec.set(v.y, v.z).normalize()\n\n        // the radial angle around the tube\n        const angle = Math.atan2(tmpVec.y, tmpVec.x)\n        angles.push(angle)\n\n        // \"arc length\" in range [-0.5 .. 0.5]\n        xPositions.push(v.x)\n        oPositions.push(v.x, v.y, v.z)\n\n        // copy over the UV for this vertex\n        uvs.push(faceUvs[j].toArray())\n      })\n    })\n\n    // build typed arrays for our attributes\n    const posArray = new Float32Array(xPositions)\n    const angleArray = new Float32Array(angles)\n    const uvArray = new Float32Array(uvs.length * 2)\n\n    const origPosArray = new Float32Array(oPositions)\n\n    // unroll UVs\n    for (let i = 0; i < posArray.length; i++) {\n      const [u, v] = uvs[i]\n      uvArray[i * 2 + 0] = u\n      uvArray[i * 2 + 1] = v\n    }\n\n    const lineGeo = new InstancedBufferGeometry()\n    lineGeo.instanceCount = count\n\n    lineGeo.setAttribute('position', new BufferAttribute(origPosArray, 3))\n    lineGeo.setAttribute('tubeInfo', new BufferAttribute(posArray, 1))\n    lineGeo.setAttribute('angle', new BufferAttribute(angleArray, 1))\n    lineGeo.setAttribute('uv', new BufferAttribute(uvArray, 2))\n\n    let offset = []\n    let ddxyz = Math.floor(Math.pow(count, 1 / 3))\n    let iii = 0\n    for (let z = 0; z < ddxyz; z++) {\n      for (let y = 0; y < ddxyz; y++) {\n        for (let x = 0; x < ddxyz; x++) {\n          offset.push(\n            0.0, //  * (x / ddxyz) * 2.0 - 1.0,\n            0.0, //  * (y / ddxyz) * 2.0 - 1.0,\n            0.0, //  * (z / ddxyz) * 2.0 - 1.0,\n            iii\n          )\n          iii++\n        }\n      }\n    }\n\n    // let ddxyz = Math.floor(Math.pow(count, 1 / 2));\n    // for (let y = 0; y < ddxyz; y++) {\n    //   for (let x = 0; x < ddxyz; x++) {\n    //     offset.push(0.0, (x / ddxyz) * 2.0 - 1.0, (y / ddxyz) * 2.0 - 1.0);\n    //   }\n    // }\n\n    lineGeo.setAttribute(\n      'offset',\n      new InstancedBufferAttribute(new Float32Array(offset), 4)\n    )\n\n    let eachLineIdx = []\n    for (let c = 0; c < count; c++) {\n      eachLineIdx.push(c)\n    }\n\n    // lineGeo.setAttribute(\n    //   \"lineIDXER\",\n    //   new InstancedBufferAttribute(new Float32Array(eachLineIdx), 1)\n    // );\n\n    return {\n      ...props,\n      dataLength: posArray.length,\n      geometry: lineGeo\n    }\n  }\n}\n\nexport class CursorTrackerTail {\n  constructor({ mini, mounter, cursor }) {\n    let node = mini\n    let SCAN_COUNT = 8\n    let TAIL_LENGTH = 64\n\n    //\n    let sim = new LokLokWiggleSimulation({\n      node,\n      mounter,\n      numberOfScans: SCAN_COUNT,\n      trailSize: TAIL_LENGTH\n    })\n\n    let display = new LokLokWiggleDisplay({ node, sim, mounter })\n    this.display = display\n\n    let trackers = []\n\n    let makeTracker = ({ update, setup }) => {\n      let looker = new Object3D()\n      cursor.add(looker)\n      mini.onClean(() => {\n        cursor.remove(looker)\n      })\n\n      let origin = new Object3D()\n      looker.add(origin)\n      let orbit = new Object3D()\n      origin.add(orbit)\n      let worldPos = new Vector3()\n      let lerpWorldPos = new Vector3()\n\n      setup({ origin, orbit })\n\n      node.onLoop(() => {\n        update({ origin, orbit })\n\n        if (mini.now?.camera) {\n          looker.lookAt(mini.now.camera.position)\n        }\n        orbit.getWorldPosition(worldPos)\n\n        lerpWorldPos.lerp(worldPos, 0.3)\n      })\n      trackers.push(lerpWorldPos)\n    }\n\n    let count = 7\n    for (let i = 0; i < count; i++) {\n      makeTracker({\n        setup: ({ origin, orbit }) => {\n          origin.rotation.z += ((Math.PI * 2.0) / count) * i\n        },\n        update: ({ origin, orbit }) => {\n          origin.rotation.z += 0.1\n          // origin.rotation[\"y\"] += 0.1;\n          orbit.position.y = 2 * Math.sin(window.performance.now() / 1000)\n        }\n      })\n    }\n\n    // let makeCross = () => {\n    //   let looker = new Object3D();\n    //   cursor.add(looker);\n    //   mini.onClean(() => {\n    //     cursor.remove(looker);\n    //   });\n\n    //   let cross1 = new Mesh(\n    //     new BoxBufferGeometry(0.02, 1, 0.02),\n    //     new MeshBasicMaterial({ depthTest: false, color: 0xffffff })\n    //   );\n    //   looker.add(cross1);\n\n    //   let cross2 = new Mesh(\n    //     new BoxBufferGeometry(1, 0.02, 0.02),\n    //     new MeshBasicMaterial({ depthTest: false, color: 0xffffff })\n    //   );\n    //   looker.add(cross2);\n\n    //   cross1.userData.enableBloom = true;\n    //   cross2.userData.enableBloom = true;\n\n    //   looker.scale.setScalar(2.0);\n\n    //   node.onLoop(() => {\n    //     if (mini.now?.camera) {\n    //       looker.lookAt(mini.now.camera.position);\n    //     }\n\n    //     let ss = 2 * Math.sin(Math.PI - window.performance.now() / 1000);\n    //     cross1.scale.setScalar(ss);\n    //     cross2.scale.setScalar(ss);\n    //   });\n    // };\n    // makeCross();\n\n    sim.wait.then(() => {\n      node.onLoop(() => {\n        sim.render({\n          trackers\n        })\n      })\n    })\n  }\n}\n","import { useFrame, useThree } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { Camera, MathUtils, Vector3 } from 'three'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\nimport { applyAutoEvent, useAutoEvent } from '../utils/use-auto-event'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { CursorTrackerTail } from '../lib/CursorTrackerTail'\nimport { PerspectiveCamera } from '@react-three/drei'\n\nexport function UserContorls({ Now, avatarSpeed = 2, higherCamera = 1.5 }) {\n  let { get, gl } = useThree()\n  let works = useRef({\n    //\n  })\n\n  useAutoEvent(\n    `touchstart`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useAutoEvent(\n    `touchmove`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useAutoEvent(\n    `touchend`,\n    (ev) => {\n      ev.preventDefault()\n    },\n    { passive: false }\n  )\n\n  useEffect(() => {\n    let orig = Now.camMode\n    Now.camMode = 'first'\n    Now.avatarSpeed = avatarSpeed\n    return () => {\n      Now.avatarSpeed = 1\n      Now.camMode = orig\n    }\n  })\n  //\n  useAutoEvent('keydown', (ev) => {\n    // console.log(ev.key);\n\n    if (ev.key === 'w') {\n      Now.keyW = true\n    }\n    if (ev.key === 'a') {\n      Now.keyA = true\n    }\n    if (ev.key === 's') {\n      Now.keyS = true\n    }\n    if (ev.key === 'd') {\n      Now.keyD = true\n    }\n  })\n  useAutoEvent('keyup', (ev) => {\n    // console.log(ev.key);\n\n    if (ev.key === 'w') {\n      Now.keyW = false\n    }\n    if (ev.key === 'a') {\n      Now.keyA = false\n    }\n    if (ev.key === 's') {\n      Now.keyS = false\n    }\n    if (ev.key === 'd') {\n      Now.keyD = false\n    }\n  })\n\n  useEffect(() => {\n    let camera = get().camera\n    camera.near = 0.1\n    camera.far = 10000\n    camera.fov = 45\n    camera.updateProjectionMatrix()\n\n    let fakeCam = new Camera()\n    fakeCam.position.z = 5\n    let orbit = new OrbitControls(fakeCam, gl.domElement)\n    orbit.enableRotate = true\n    orbit.enablePan = false\n    orbit.enableZoom = false\n\n    orbit.enableDamping = true\n    orbit.rotateSpeed = 0.5\n\n    let joystick = document.createElement('div')\n\n    document.body.appendChild(joystick)\n    joystick.style.cssText = `\n      position: absolute;\n      bottom: 30px;\n      left: 30px;\n      width: 80px;\n      height: 80px;\n      color: white;\n      user-select: none;\n      z-index: 20;\n    `\n\n    let note = document.createElement('div')\n    document.body.appendChild(note)\n    note.style.cssText = `\n      position: absolute;\n      bottom: 50px;\n      left: 50px;\n      width: 80px;\n      height: 80px;\n      color: white;\n      user-select: none;\n      z-index: 10;\n      text-align: center;\n      opacity: 0.4;\n    `\n    note.innerHTML = `Walk Around JoyStick`\n\n    let nipplejs = require('nipplejs')\n    var manager = nipplejs.create({\n      zone: joystick,\n      color: 'white',\n      mode: 'static',\n      position: { left: '60px', bottom: '60px' }\n    })\n\n    let forward = new Vector3(0, 0, 0)\n    let up = new Vector3(0, 1, 0)\n\n    let ttt = 0\n    let isUsing = false\n    let nippleAngle = 0\n\n    // window.addEventListener('touchstart', () => {\n    //   isDown = true\n    // })\n    // window.addEventListener('touchend', () => {\n    //   isDown = false\n    // })\n\n    manager.on('start move dir plain', function (evt, nipple) {\n      if (nipple?.angle?.radian) {\n        nippleAngle = nipple?.angle?.radian\n        orbit.enableRotate = false\n\n        isUsing = true\n        // Now.isDown = true;\n\n        clearTimeout(ttt)\n        ttt = setTimeout(() => {\n          isUsing = false\n        }, 100)\n      }\n    })\n\n    manager.on('end', () => {\n      nippleAngle = 0\n      works.current.endForward = () => {\n        forward.multiplyScalar(0.8)\n      }\n      // Now.isDown = false;\n      orbit.enableRotate = true\n      isUsing = false\n    })\n\n    let cte = applyAutoEvent(\n      gl.domElement.parentElement,\n      `touchend`,\n      (ev) => {\n        if (!isUsing) {\n          orbit.enableRotate = true\n        }\n      },\n      { passive: false }\n    )\n    let cts = applyAutoEvent(\n      gl.domElement.parentElement,\n      `touchstart`,\n      (ev) => {\n        if (!isUsing) {\n          orbit.enableRotate = true\n        }\n      },\n      { passive: false }\n    )\n\n    let keyBoardForward = new Vector3(0, 0, 1)\n    let scaler = 0.3\n\n    works.current.ctrl2 = () => {\n      if (isUsing) {\n        forward.set(0, 0, -1)\n        forward.applyAxisAngle(\n          up,\n          orbit.getAzimuthalAngle() + nippleAngle - Math.PI * 0.5 || 0.0\n        )\n      }\n      //\n      if (Now.keyW || Now.keyA || Now.keyS || Now.keyD) {\n        scaler = MathUtils.lerp(scaler, 0.3, 0.1)\n      } else {\n        scaler = MathUtils.lerp(scaler, 0.0, 0.1)\n      }\n\n      // controls.getDirection(dir);\n      if (Now.keyW) {\n        keyBoardForward.set(0, 0, -1 * scaler)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyA) {\n        keyBoardForward.set(-1 * scaler, 0, 0)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyS) {\n        keyBoardForward.set(0, 0, 1 * scaler)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      } else if (Now.keyD) {\n        keyBoardForward.set(1 * scaler, 0, 0)\n        keyBoardForward.applyEuler(camera.rotation)\n        keyBoardForward.y = 0.0\n\n        Now.avatarAt.add(keyBoardForward).multiplyScalar(1)\n      }\n\n      Now.goingTo.copy(Now.avatarAt)\n      // if (!(Now.keyW || Now.keyA || Now.keyS || Now.keyD)) {\n      //   Now.avatarAt.copy(Now.avatarAt);\n      // }\n    }\n\n    // grid of raycaster\n\n    works.current.ctrl3 = () => {\n      let newType = 'floor'\n\n      // let upness = Now.cursorNormal.y || 0;\n      if (Now.cursorType !== newType) {\n        Now.cursorType = newType\n      }\n    }\n\n    works.current.ctrl = () => {\n      orbit.update()\n\n      Now.goingTo.add(forward)\n\n      camera.position.x = Now.avatarAt.x\n      camera.position.y = Now.avatarAt.y + higherCamera\n      camera.position.z = Now.avatarAt.z\n\n      camera.rotation.copy(fakeCam.rotation)\n    }\n\n    Now.enableFloorCursor = false\n    return () => {\n      Now.enableFloorCursor = true\n      manager.off('start move end dir plain')\n      manager.destroy()\n      document.body.removeChild(joystick)\n\n      joystick.remove()\n      note.remove()\n      cte()\n      cts()\n    }\n  }, [])\n\n  useFrame(() => {\n    Object.values(works.current).forEach((e) => e())\n  })\n  return (\n    <group>\n      {/*  */}\n      {/*  */}\n      <PerspectiveCamera\n        fov={45}\n        near={0.1}\n        far={10000}\n        position={[0, 20, 20]}\n        rotation-x={Math.PI * -0.25}\n        makeDefault\n      />\n    </group>\n  )\n}\n\nexport function TailCursor({ Now }) {\n  // let { get } = useThree();\n  let { mini } = useMiniEngine()\n  let cursor = useRef()\n\n  useEffect(() => {\n    let mouse = cursor.current\n    console.log(123)\n    if (mouse) {\n      mini.ready.scene.then((scene) => {\n        return new CursorTrackerTail({ mini, cursor: mouse, mounter: scene })\n      })\n    }\n  }, [])\n\n  // let time = 0\n  useFrame((st, dt) => {\n    // time += dt\n    if (cursor.current) {\n      let mouse = cursor.current\n\n      mouse.position.lerp(Now.cursorPos, 0.4)\n\n      // mouse.scale.setScalar(0.15);\n\n      // mouse.lookAt(\n      //   Now.cursorPos.x + Now.cursorNormal.x,\n      //   Now.cursorPos.y + Now.cursorNormal.y,\n      //   Now.cursorPos.z + Now.cursorNormal.z\n      // );\n\n      mouse.lookAt(st.camera.position)\n    }\n  })\n  //\n\n  return <group ref={cursor}>{/*  */}</group>\n}\n/* <HoverDisplay></HoverDisplay> */\n\n// function HoverDisplay({}) {\n//   let { get } = useThree()\n//   Now.makeKeyReactive('hoverData')\n\n//   let ref = useRef()\n\n//   useFrame(({ camera }) => {\n//     if (ref.current) {\n//       ref.current.lookAt(camera.position)\n//     }\n//   })\n\n//   useEffect(() => {\n//     let { scene, camera } = get()\n//     scene.add(camera)\n//     return () => {\n//       scene.remove(camera)\n//     }\n//   })\n\n//   return (\n//     <>\n//       <group position={[0, 0, 10]} ref={ref}></group>\n\n//       {Now.hoverData?.hoverText &&\n//         createPortal(\n//           <group position={[0.1, -0.1, -get().viewport.distance]}>\n//             <Text\n//               outlineWidth={0.00333}\n//               anchorX={'left'}\n//               font={`/font/Cronos-Pro-Light_12448.ttf`}\n//               anchorY={'top'}\n//             >\n//               {`  > ${Now.hoverData?.hoverText || '  '} < `}\n//             </Text>\n//           </group>,\n//           get().camera\n//         )}\n//     </>\n//   )\n// }\n\n// function Floating({ offset = 0, children }) {\n//   let ref = useRef()\n\n//   let time = 0\n//   useFrame((st, dt) => {\n//     time += dt * 2.0\n//     if (ref.current) {\n//       ref.current.position.x = -0.5 + 1.5 * Math.sin(time + offset)\n//     }\n//   })\n\n//   return <group ref={ref}>{children}</group>\n// }\n","import { useFrame } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { CursorTrackerTail } from '../lib/CursorTrackerTail'\n\nexport function TailCursor({ Now }) {\n  let { mini } = useMiniEngine()\n  let cursor = useRef()\n\n  useEffect(() => {\n    let mouse = cursor.current\n    console.log(123)\n    if (mouse) {\n      mini.ready.scene.then((scene) => {\n        return new CursorTrackerTail({ mini, cursor: mouse, mounter: scene })\n      })\n    }\n  }, [])\n\n  // let time = 0\n  useFrame((st, dt) => {\n    // time += dt\n    if (cursor.current) {\n      let mouse = cursor.current\n\n      mouse.position.lerp(Now.cursorPos, 0.4)\n\n      // mouse.scale.setScalar(0.15);\n\n      // mouse.lookAt(\n      //   Now.cursorPos.x + Now.cursorNormal.x,\n      //   Now.cursorPos.y + Now.cursorNormal.y,\n      //   Now.cursorPos.z + Now.cursorNormal.z\n      // );\n\n      mouse.lookAt(st.camera.position)\n    }\n  })\n\n  return <group ref={cursor}>{/*  */}</group>\n}\n/* <HoverDisplay></HoverDisplay> */\n\n// function HoverDisplay({}) {\n//   let { get } = useThree()\n//   Now.makeKeyReactive('hoverData')\n\n//   let ref = useRef()\n\n//   useFrame(({ camera }) => {\n//     if (ref.current) {\n//       ref.current.lookAt(camera.position)\n//     }\n//   })\n\n//   useEffect(() => {\n//     let { scene, camera } = get()\n//     scene.add(camera)\n//     return () => {\n//       scene.remove(camera)\n//     }\n//   })\n\n//   return (\n//     <>\n//       <group position={[0, 0, 10]} ref={ref}></group>\n\n//       {Now.hoverData?.hoverText &&\n//         createPortal(\n//           <group position={[0.1, -0.1, -get().viewport.distance]}>\n//             <Text\n//               outlineWidth={0.00333}\n//               anchorX={'left'}\n//               font={`/font/Cronos-Pro-Light_12448.ttf`}\n//               anchorY={'top'}\n//             >\n//               {`  > ${Now.hoverData?.hoverText || '  '} < `}\n//             </Text>\n//           </group>,\n//           get().camera\n//         )}\n//     </>\n//   )\n// }\n\n// function Floating({ offset = 0, children }) {\n//   let ref = useRef()\n\n//   let time = 0\n//   useFrame((st, dt) => {\n//     time += dt * 2.0\n//     if (ref.current) {\n//       ref.current.position.x = -0.5 + 1.5 * Math.sin(time + offset)\n//     }\n//   })\n\n//   return <group ref={ref}>{children}</group>\n// }\n","import React, { useEffect, useRef } from 'react'\n\nimport { useFrame } from '@react-three/fiber'\nimport {\n  Color,\n  Layers,\n  MeshBasicMaterial,\n  ShaderMaterial,\n  sRGBEncoding,\n  Vector2,\n  WebGLRenderTarget\n} from 'three'\nimport { useMiniEngine } from '../utils/use-mini-engine'\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass'\n\nexport const ENTIRE_SCENE = 0\nexport const BLOOM_SCENE = 1\nexport const DARK_SCENE = 2\n\nexport const enableBloom = (item) => {\n  item.layers.enable(BLOOM_SCENE)\n}\n\nexport const enableDarken = (item) => {\n  item.layers.enable(DARK_SCENE)\n}\n\nexport class BloomLayer {\n  constructor({ mini }) {\n    let { get } = mini.now\n\n    let reducedRes = 0.35\n    let resBloom = new Vector2()\n    resBloom.copy({\n      x: get().gl.domElement.width,\n      y: get().gl.domElement.height\n    })\n    resBloom.multiplyScalar(reducedRes)\n\n    let EffectComposer =\n      require('three/examples/jsm/postprocessing/EffectComposer').EffectComposer\n    let RenderPass =\n      require('three/examples/jsm/postprocessing/RenderPass').RenderPass\n    let UnrealBloomPass =\n      require('three/examples/jsm/postprocessing/UnrealBloomPass').UnrealBloomPass\n\n    let efComposer = new EffectComposer(get().gl)\n    mini.onResize(() => {\n      efComposer.setPixelRatio(get().gl.getPixelRatio())\n    })\n\n    let renderPass = new RenderPass(get().scene, get().camera)\n    mini.onResize(() => {\n      resBloom.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n      resBloom.multiplyScalar(reducedRes)\n      renderPass.setSize(resBloom.x, resBloom.y)\n    })\n    efComposer.addPass(renderPass)\n\n    let unrealPass = new UnrealBloomPass(resBloom, 2, 1, 0.1)\n    mini.onResize(() => {\n      resBloom.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n      resBloom.multiplyScalar(reducedRes)\n      unrealPass.setSize(resBloom.x, resBloom.y)\n    })\n\n    efComposer.addPass(unrealPass)\n    efComposer.renderToScreen = false\n\n    let dark = new Color('#000000')\n    let darkMat = new MeshBasicMaterial({ color: 0x000000, skinning: true })\n    let baseLayer = new Layers()\n    baseLayer.disableAll()\n    baseLayer.enable(ENTIRE_SCENE)\n\n    let bloomLayer = new Layers()\n    bloomLayer.disableAll()\n    bloomLayer.enable(BLOOM_SCENE)\n    let darkLayer = new Layers()\n    darkLayer.disableAll()\n    darkLayer.enable(DARK_SCENE)\n\n    let darken = (it) => {\n      if (!it.text) {\n        it.material = darkMat\n        darkMat.needsUpdate = true\n      }\n      // darkMat.needsUpdate = true;\n    }\n\n    let backup = () => {\n      let { scene } = get()\n\n      scene.traverse((it) => {\n        if (it.material) {\n          it.userData.originalMaterial = it.material\n          it.userData.originalRoughness = it.material.roughness\n          it.userData.originalMetalness = it.material.metalness\n          it.userData.originalColor = it.material.color || new Color('#ffffff')\n          if (it.material?.uniforms?.color?.value) {\n            it.userData.originalUniformColor = it.material.uniforms.color.value\n          }\n        }\n      })\n    }\n\n    let setBloomSceneMat = () => {\n      let { scene } = get()\n\n      scene.traverse((it) => {\n        if (it.isLight) {\n          it.visible = false\n        }\n\n        if (it?.userData?.discard) {\n          it.visible = false\n        }\n\n        if (it.material) {\n          if (it?.userData?.enableDarken) {\n            darken(it)\n            return\n          } else if (it?.userData?.enableBloom) {\n            it.material = it.userData.originalMaterial\n          } else if (darkLayer.test(it.layers) || !bloomLayer.test(it.layers)) {\n            darken(it)\n          } else {\n            it.material = it.userData.originalMaterial\n          }\n        }\n      })\n    }\n\n    let renderToTexture = () => {\n      let { scene, clock } = get()\n      let dt = clock.getDelta()\n      let origBG = scene.background\n      scene.background = dark\n      efComposer.render(dt)\n      scene.background = origBG\n    }\n\n    let restore = () => {\n      let { scene } = get()\n      scene.traverse((it) => {\n        if (!it.text && it.material && it.userData.originalMaterial) {\n          it.material = it.userData.originalMaterial\n\n          if (it?.material?.color && it?.userData?.originalColor) {\n            it.material.color = it.userData.originalColor\n          }\n\n          if (it?.userData?.originalRoughness) {\n            it.material.roughness = it.userData.originalRoughness\n            it.material.metalness = it.userData.originalMetalness\n          }\n\n          if (it.material?.uniforms?.color?.value) {\n            it.material.uniforms.color.value = it.userData.originalUniformColor\n          }\n        }\n        if (it.isLight) {\n          it.visible = true\n        }\n\n        if (it?.userData?.discard) {\n          it.visible = true\n        }\n      })\n    }\n\n    this.renderTexture = () => {\n      let { scene, gl } = get()\n      gl.shadowMap.enabled = false\n\n      // bloom with occulsion image\n      backup()\n      setBloomSceneMat()\n      renderToTexture()\n      restore()\n\n      gl.shadowMap.enabled = true\n    }\n    this.getTex = () => {\n      return efComposer.readBuffer.texture\n    }\n  }\n}\n\nexport class BaseLayer {\n  constructor({ mini }) {\n    let { size, gl, get } = mini.now\n\n    let resBase = new Vector2()\n\n    resBase.copy({ x: size.width, y: size.height })\n    resBase.multiplyScalar(gl.getPixelRatio())\n\n    this.rtt = new WebGLRenderTarget(resBase.width, resBase.height, {\n      encoding: sRGBEncoding,\n      generateMipmaps: false\n    })\n    mini.onClean(() => {\n      this.rtt.dispose()\n    })\n    mini.onResize(() => {\n      resBase.copy({\n        x: get().gl.domElement.width,\n        y: get().gl.domElement.height\n      })\n      resBase.multiplyScalar(gl.getPixelRatio())\n\n      this.rtt = new WebGLRenderTarget(resBase.width, resBase.height, {\n        encoding: sRGBEncoding,\n        generateMipmaps: false\n      })\n    })\n\n    this.renderTexture = () => {\n      let { gl, camera, scene } = get()\n\n      // base image\n      let orig = gl.getRenderTarget()\n      gl.setRenderTarget(this.rtt)\n      gl.render(scene, camera)\n      gl.setRenderTarget(orig)\n    }\n\n    this.getTex = () => {\n      return this.rtt.texture\n    }\n  }\n}\nexport class Compositor {\n  constructor({ mini }) {\n    //\n    let quadMat = new ShaderMaterial({\n      //\n      uniforms: {\n        bloomDiffuse: { value: null },\n        baseDiffuse: { value: null }\n      },\n\n      //\n      vertexShader: `\n        varying vec2 vUv;\n        void main (void) {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vUv = uv;\n        }\n      `,\n\n      fragmentShader: `\n        uniform sampler2D baseDiffuse;\n        uniform sampler2D bloomDiffuse;\n\n        varying vec2 vUv;\n          void main (void) {\n            vec4 baseDiffuseColor = texture2D(baseDiffuse, vUv);\n            vec4 bloomDiffuseColor = texture2D(bloomDiffuse, vUv);\n\n            gl_FragColor = vec4(baseDiffuseColor.rgb * 1.0,  baseDiffuseColor.a);\n\n            gl_FragColor.r += 0.45 * pow(bloomDiffuseColor.r, 0.75);\n            gl_FragColor.g += 0.45 * pow(bloomDiffuseColor.g, 0.75);\n            gl_FragColor.b += 0.45 * pow(bloomDiffuseColor.b, 0.75);\n          }\n        `\n    })\n\n    let fsQuad = new FullScreenQuad(quadMat)\n\n    this.render = ({ baseTex, bloomTex }) => {\n      let { gl } = mini.now\n      if (gl) {\n        quadMat.uniforms.bloomDiffuse.value = bloomTex\n        quadMat.uniforms.baseDiffuse.value = baseTex\n        fsQuad.render(gl)\n      }\n    }\n  }\n}\n\nexport function SimpleBloomer() {\n  let { mini } = useMiniEngine()\n\n  let looer = useRef(() => {})\n\n  useEffect(() => {\n    mini.ready.get.then(() => {\n      //\n      let base = new BaseLayer({ mini })\n      let bloom = new BloomLayer({ mini })\n      let compositor = new Compositor({ mini })\n\n      //\n      looer.current = () => {\n        base.renderTexture()\n        bloom.renderTexture()\n\n        compositor.render({\n          baseTex: base.getTex(),\n          bloomTex: bloom.getTex()\n        })\n      }\n    })\n  }, [])\n\n  // invalidate orignal loop\n  useFrame(() => {\n    looer.current()\n  }, 1000)\n\n  return null\n}\n","import { Sphere } from '@react-three/drei'\nimport { useFrame } from '@react-three/fiber'\nimport React, { useEffect, useRef } from 'react'\nimport { DoubleSide } from 'three'\n\nexport function StarSky() {\n  let shaders = {\n    vertexShader: /* glsl */ `\n    varying vec3 vPos;\n    varying vec3 vUv3;\n\n    void main() {\n      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n      gl_Position = projectionMatrix * mvPosition;\n      vPos = position;\n      vUv3 = uv.xyx;\n    }\n    `,\n    fragmentShader: `\n      precision highp float;\n\n      vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n      vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n      float cnoise(vec3 P){\n        vec3 Pi0 = floor(P); // Integer part for indexing\n        vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n        Pi0 = mod(Pi0, 289.0);\n        Pi1 = mod(Pi1, 289.0);\n        vec3 Pf0 = fract(P); // Fractional part for interpolation\n        vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n        vec4 iy = vec4(Pi0.yy, Pi1.yy);\n        vec4 iz0 = Pi0.zzzz;\n        vec4 iz1 = Pi1.zzzz;\n\n        vec4 ixy = permute(permute(ix) + iy);\n        vec4 ixy0 = permute(ixy + iz0);\n        vec4 ixy1 = permute(ixy + iz1);\n\n        vec4 gx0 = ixy0 / 7.0;\n        vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n        gx0 = fract(gx0);\n        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n        vec4 sz0 = step(gz0, vec4(0.0));\n        gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n        gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n        vec4 gx1 = ixy1 / 7.0;\n        vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n        gx1 = fract(gx1);\n        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n        vec4 sz1 = step(gz1, vec4(0.0));\n        gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n        gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n        g000 *= norm0.x;\n        g010 *= norm0.y;\n        g100 *= norm0.z;\n        g110 *= norm0.w;\n        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n        g001 *= norm1.x;\n        g011 *= norm1.y;\n        g101 *= norm1.z;\n        g111 *= norm1.w;\n\n        float n000 = dot(g000, Pf0);\n        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n        float n111 = dot(g111, Pf1);\n\n        vec3 fade_xyz = fade(Pf0);\n        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n        return 2.2 * n_xyz;\n      }\n\n      varying vec3 vPos;\n      uniform float time;\n      varying vec3 vUv3;\n\n      void main() {\n        float speed = time / 3.5;\n        vec3 pp = vUv3 * 600.0;\n        // pp = vPos * 0.25 + speed;\n        float noise = clamp(cnoise(speed + pp / 250.0 + 0.0 ), 0.0, 1.0);\n\n        vec3 colorA = vec3(81.0, 135.0, 228.0) * 0.2 / 255.0;\n        vec3 colorB = vec3(0.0, 150.0, 136.0) * 0.2 / 255.0;\n\n        vec4 backgroundColor = vec4(mix(colorA, colorB, noise), 1.0);\n\n        gl_FragColor = backgroundColor;\n\n        float starNoise = (noise) * pow(cnoise(speed + pp * 2.0) * 0.5 + 0.5, 15.5) * 30.0;\n\n        gl_FragColor.rgb += vec3(pow(starNoise, 1.3)) * 1.5;\n      }\n      `\n  }\n\n  let ref = useRef()\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.needsUpdate = true\n    }\n  }, [shaders, shaders.fragmentShader, shaders.vertexShader])\n\n  let uniforms = useRef({\n    time: { value: 0 }\n  })\n\n  useFrame(() => {\n    uniforms.current.time.value += 1 / 60\n  })\n\n  return (\n    <Sphere\n      frustumCulled={false}\n      userData={{\n        enableBloom: true\n      }}\n      scale={1}\n      args={[800, 20, 20]}\n    >\n      <shaderMaterial\n        ref={ref}\n        uniforms={uniforms.current}\n        fragmentShader={shaders.fragmentShader}\n        vertexShader={shaders.vertexShader}\n        side={DoubleSide}\n      >\n        {/*  */}\n        {/*  */}\n      </shaderMaterial>\n    </Sphere>\n  )\n}\n","import { useThree } from '@react-three/fiber'\nimport { useEffect } from 'react'\n\nimport { PMREMGenerator, sRGBEncoding, TextureLoader } from 'three'\n\nexport function EnvLightByImage({ imageURL }) {\n  //\n  let { scene, gl } = useThree()\n  useEffect(() => {\n    const pmremGenerator = new PMREMGenerator(gl)\n    pmremGenerator.compileEquirectangularShader()\n\n    let loader = new TextureLoader()\n    // loader.setDataType(UnsignedByteType);\n    loader.load(imageURL, (texture) => {\n      const envMap = pmremGenerator.fromEquirectangular(texture).texture\n      envMap.encoding = sRGBEncoding\n      // scene.background = envMap;\n      scene.environment = envMap\n    })\n\n    return () => {\n      scene.environment = null\n      scene.background = null\n    }\n  }, [imageURL])\n\n  return null\n}\n","import React, { Suspense, useMemo } from 'react'\nimport { Canvas } from '@react-three/fiber'\nimport { useGLTF, PerspectiveCamera } from '@react-three/drei'\n\nimport {\n  Map3D,\n  UserContorls,\n  TailCursor,\n  SimpleBloomer,\n  StarSky,\n  EnvLightByImage\n} from 'effectnode-3dworld'\nimport { SkeletonUtils } from 'three/examples/jsm/utils/SkeletonUtils'\n\n// needs trailing slash\nexport const BASE_URL = `https://wonglok.github.io/effectnode-3dworld/`\n\nconst App = () => {\n  return (\n    <Canvas style={{ width: '100%', height: '100%' }}>\n      <Suspense\n        fallback={\n          // Loading screen\n          <group>\n            <group rotation-x={Math.PI * 0}>\n              <gridHelper args={[150, 50, 0x232323, 0xaaaaaa]}></gridHelper>\n            </group>\n            <PerspectiveCamera\n              position={[0, 20, 20]}\n              rotation-x={Math.PI * -0.25}\n              makeDefault={true}\n            ></PerspectiveCamera>\n          </group>\n        }\n      >\n        <Content3D></Content3D>\n      </Suspense>\n    </Canvas>\n  )\n}\n\nfunction Content3D() {\n  let gltf = useGLTF(`${BASE_URL}map/demo-map-000.glb`)\n\n  let floor = useMemo(() => {\n    let floor = SkeletonUtils.clone(gltf.scene)\n\n    floor.traverse((it) => {\n      if (it) {\n        if (it.material) {\n          it.material = it.material.clone()\n        }\n        if (it.geometry) {\n          it.userData.isFloor = true\n        }\n      }\n    })\n\n    return floor\n  }, [gltf])\n\n  return (\n    <group>\n      {floor && (\n        <Map3D floor={floor} startAt={{ x: 0, y: 0, z: 0 }}>\n          {({ Now }) => {\n            return (\n              <group>\n                <UserContorls\n                  higherCamera={1.5}\n                  avatarSpeed={2}\n                  Now={Now}\n                ></UserContorls>\n                <TailCursor Now={Now}></TailCursor>\n              </group>\n            )\n          }}\n        </Map3D>\n      )}\n\n      <primitive object={floor}></primitive>\n      <directionalLight position={[10, 10, 10]}></directionalLight>\n      <EnvLightByImage imageURL={`${BASE_URL}image/sky.png`}></EnvLightByImage>\n\n      {/* extras */}\n      <StarSky></StarSky>\n      <SimpleBloomer></SimpleBloomer>\n    </group>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}